<!DOCTYPE html>
<html lang="zh-CN"><head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta name="description" content="附录A-NumPy高级应用 - https://richfan.site/posts/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E9%99%84%E5%BD%95a-numpy%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/">
    <meta name="author" content="richfan - https://richfan.site/">
    
    <meta name="msvalidate.01" content="B46311949B856F2A7015F366FB3CE878" />
    <title>附录A-NumPy高级应用</title>
    <link rel="icon" type="image/png" href="/favicon.ico">
    
    <link rel="stylesheet" href="https://richfan.site/style.min.d252ad53a5e6b2ae6b8c6c1661107189be3668e36c8dd61697bbe008595a7e04.css">
    
    <script type="text/javascript" src="/main.js" defer></script>
    
</head>
<body class="active-animate cool">
        <div id="header"><div class="container-header">
    <div id="vars" class="container-vars" style="display: none;">
	{
		"isSingleColumnOfPostList": true,
		"hasFoldAllCodeBlocks": false,
		"svgColor": "",
		"en": false,
		"dark": true
	}
</div>
    <h1 class="title">
        
            附录A-NumPy高级应用
            
        
    </h1>

    <div class="container-breadcrumb-nav">
    
    <div class="breadcrumb-nav-bar">
        <div><a href="/"><svg t="1656411084410" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2954" width="16" height="16"><path d="M947.5 390.6l-377-290c-34.5-26.5-82.6-26.5-117.1 0l-377 290c-14 10.8-16.6 30.9-5.9 44.9 10.8 14 30.9 16.6 44.9 5.9l28.5-21.9V768c0 88.2 71.8 160 160 160h80c35.3 0 64-28.7 64-64V640c0-17.6 14.4-32 32-32h64c17.6 0 32 14.4 32 32v224c0 35.3 28.7 64 64 64h80c88.2 0 160-71.8 160-160V419.4l28.5 21.9c5.8 4.5 12.7 6.6 19.5 6.6 9.6 0 19.1-4.3 25.4-12.5 10.8-13.9 8.2-34-5.8-44.8zM816 768c0 52.9-43.1 96-96 96h-80V640c0-52.9-43.1-96-96-96h-64c-52.9 0-96 43.1-96 96v224h-80c-52.9 0-96-43.1-96-96V370.2l284.5-218.8c11.5-8.8 27.5-8.8 39 0L816 370.2V768z" fill="#6c757d" p-id="2955"></path></svg></a></div>
        <div><a href="/nav"><svg t="1656411531924" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5827" width="16" height="16"><path d="M849.59197473 125.23018519L139.22930586 391.72854662a23.35052669 23.35052669 0 0 0-14.95414244 21.65490745c-0.12257519 9.70384955 5.61801843 18.46795771 14.40255493 22.04306141l318.42928099 129.25528056 119.51057092 320.39047893c3.06437293 8.23295069 10.35758221 13.89182751 18.7335381 14.87242563l2.7170774 0.14300521a22.79893918 22.79893918 0 0 0 21.20546682-15.36272638l259.51158924-729.54564933a23.8612558 23.8612558 0 0 0-5.31158128-24.55584682 22.3290685 22.3290685 0 0 0-23.9021142-5.43415649zM793.65694081 211.64552314l-196.63064161 552.75171747-91.91077952-246.37564122-253.62799211-102.96295445 542.16941324-203.4131218z" p-id="5828" fill="#6c757d"></path></svg></a></div>
        <div><a href="/search"><svg t="1656411627509" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1730" width="14" height="14"><path d="M469.333333 85.333333c211.968 0 384 172.032 384 384s-172.032 384-384 384-384-172.032-384-384 172.032-384 384-384z m0 682.666667c164.992 0 298.666667-133.674667 298.666667-298.666667 0-165.034667-133.674667-298.666667-298.666667-298.666666-165.034667 0-298.666667 133.632-298.666666 298.666666 0 164.992 133.632 298.666667 298.666666 298.666667z m362.026667 3.029333l120.704 120.661334-60.373333 60.373333-120.661334-120.704 60.330667-60.330667z" p-id="1731" fill="#6c757d"></path></svg></a></div>
        <div><a href="/posts"><svg t="1656411724198" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5655" width="12" height="12"><path d="M811.705761 1024H212.294239c-93.1199 0-174.823046-87.570975-174.823046-187.387854V162.322018C37.471193 69.776145 112.604921 0 212.294239 0H596.190595l7.015883 5.93161c111.74388 95.479788 185.857116 170.741078 279.614824 266.093304 29.65805 30.040735 61.165743 62.122454 96.436499 97.393211l7.271006 7.334787v459.859234c-0.063781 99.816879-81.703145 187.387854-174.823046 187.387854zM212.294239 49.94033c-72.391155 0-124.882716 47.261538-124.882716 112.381688v674.290128c0 71.94469 59.507443 137.383743 124.882716 137.383743h599.411522c65.311492 0 124.882716-65.439053 124.882716-137.383743V397.417876c-32.528184-32.464404-61.73977-62.250016-89.356836-90.377328-90.951355-92.418312-163.278729-165.957521-269.601245-257.163999H212.294239z" fill="#6c757d" p-id="5656"></path><path d="M936.588477 449.526752h-212.326129c-99.753099 0-187.324073-81.703145-187.324073-174.823046V49.94033a25.002055 25.002055 0 0 1 49.94033 0v224.763376c0 65.311492 65.502834 124.882716 137.383743 124.882716h212.326129a25.002055 25.002055 0 1 1 0 49.94033z" fill="#6c757d" p-id="5657"></path></svg></a></div>
        <div><a href="/archive"><svg t="1656411795742" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7334" width="12" height="12"><path d="M884.224 522.24H504.32V141.824c0-16.896-13.824-30.72-30.72-30.72-120.32 0-233.472 47.616-317.952 134.144S26.112 445.952 29.184 566.784c2.56 114.688 49.152 222.72 131.072 304.128 81.92 81.408 189.952 128 304.64 130.56h10.24c117.76 0 227.84-45.568 312.32-128.512 86.528-85.504 133.632-199.68 132.608-321.024-0.512-2.048-1.536-29.696-35.84-29.696z m-140.288 307.712c-74.752 73.728-173.056 112.64-277.504 110.592-205.824-4.608-370.688-169.472-375.296-374.784-3.072-104.448 35.84-202.752 108.544-277.504 65.536-67.072 151.552-107.52 243.712-114.688v378.88c0 16.896 13.824 30.72 30.72 30.72 129.024 0 311.296 0 382.976 0.512-6.144 93.184-46.08 179.712-113.152 246.272z" fill="#6c757d" p-id="7335"></path><path d="M603.136 11.264c-8.192-0.512-15.872 3.072-22.016 8.704-5.632 5.632-9.216 13.824-9.216 22.016v378.88c0 16.896 13.824 30.72 30.72 30.72h378.88c16.896 0 30.72-13.824 30.72-30.72 0-223.744-183.808-407.552-409.088-409.6z m30.208 378.88V74.24c167.424 16.384 301.056 150.016 315.904 315.904h-315.904z" fill="#6c757d" p-id="7336"></path></svg></a></div>
        <div id="light-dark" style="cursor: pointer;"><a><svg t="1656411842215" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="5086" width="12" height="12"><path d="M1007.492874 384.513055c-8.795694-34.58307-21.189627-67.666874-36.682043-99.05151-2.698679-5.397358-10.894667-3.498287-10.894666 2.598728v0.299853c0 32.484098-6.896624 63.868734-19.890263 92.554691-10.694764 23.488501-25.487523 45.077933-43.978471 64.068635-41.779547 42.679107-99.05151 66.967217-158.722299 67.26707-61.869712 0.299853-119.941284-24.188159-162.920244-68.966238-40.280281-41.979449-62.56937-98.251902-62.269516-156.323473 0.399804-59.270984 23.588452-114.94373 65.567901-156.823229 19.59041-19.59041 42.179351-35.082826 66.667364-46.077443C672.956643 71.166451 704.041426 64.469729 736.125719 64.469729h1.299364c6.097015 0 8.096037-8.096037 2.598728-10.794715C708.739126 37.982696 675.655322 25.488812 641.172203 16.493216 599.492607 5.598549 555.714038-0.098662 510.536154 0.001289 222.37722 0.700947-7.41029 237.38508 0.185992 525.444064c7.096526 271.667008 225.889418 490.559851 497.456474 497.856279 287.559228 7.796183 524.14341-220.891864 525.842579-508.551044 0.299853-44.977981-5.297407-88.656599-15.992171-130.236244z m-83.15929 301.552378c-22.588942 53.27392-54.873137 101.250434-95.953027 142.330323-41.179841 41.179841-89.056403 73.464036-142.330324 95.953027-55.172991 23.288599-113.744317 35.182777-174.314666 35.182777s-119.141675-11.794226-174.314666-35.182777c-53.27392-22.588942-101.250434-54.873137-142.330323-95.953027-41.179841-41.179841-73.464036-89.056403-95.953027-142.330323C75.749001 630.892442 63.954774 572.221164 63.954774 511.750767s11.794226-119.141675 35.182777-174.314666c22.588942-53.27392 54.873137-101.250434 95.953027-142.330323 41.179841-41.179841 89.056403-73.464036 142.330323-95.953027C392.593892 75.7642 451.26517 63.969974 511.735567 63.969974c13.99315 0 27.886348 0.599706 41.679596 1.89907C489.246577 118.643209 448.266638 198.704016 448.266638 288.360126c0 159.022152 128.836929 287.859081 287.859081 287.859081 89.156354 0 168.817357-40.580134 221.691473-104.149015 1.099462 13.09359 1.699168 26.387082 1.699168 39.680575 0 60.470397-11.794226 119.141675-35.182776 174.314666z" p-id="5087" fill="#6c757d"></path></svg></a></div>
        
    </div>

    
</div>

            <div id="toc">📜</div>
        
    
    
</div>
</div>
        <div id="content">















<div class="container-main 
     container-page 
">

    <div class="desc">
        
        <span>
            
            <svg t="1656736000388" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="7409" width="12" height="12"><path d="M524.885333 338.986667L200.362667 663.466667c-17.28 15.274667-27.989333 36.693333-29.696 56.234666v133.76l130.730666 0.085334c22.784-1.621333 43.989333-12.245333 61.013334-31.701334l322.688-322.645333-160.213334-160.213333z m60.373334-60.330667l160.170666 160.213333 102.144-102.144a19.712 19.712 0 0 0 0-27.861333L715.093333 176.426667a19.456 19.456 0 0 0-27.605333 0L585.258667 278.613333zM701.312 85.333333c27.946667 0 54.741333 11.136 74.282667 30.848l132.309333 132.309334a105.045333 105.045333 0 0 1 0 148.565333L424.874667 879.957333c-29.824 34.346667-72.106667 55.466667-120.448 58.794667H85.333333v-42.666667l0.128-179.84c3.626667-44.970667 24.576-86.826667 56.448-114.944l485.12-485.034666A104.789333 104.789333 0 0 1 701.269333 85.333333z" p-id="7410" fill="#adb5bd"></path></svg>
            2023-09-25&nbsp;
        </span>
        <span>
            
            <svg t="1656737270708" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="23838" width="11" height="11"><path d="M824.264 95.36c0-23.859 25.043-44.16 48.902-44.16s49.714 20.301 49.714 44.16v190.08c0 23.859-19.054 52.868-42.913 52.868h-190.08c-23.859 0-46.696-25.96-46.696-49.819s22.55-46.249 46.409-46.249h82.025C702.344 175.534 610.22 155.853 512 155.853c-206.775 0-360.398 149.372-360.398 356.147 0 206.775 153.623 358.23 360.398 358.23 206.775 0 357.467-151.455 357.467-358.23 0-23.859 23.634-50.706 53.413-50.706 29.78 0 49.92 26.847 49.92 50.706 0 254.493-206.307 460.8-460.8 460.8-254.493 0-460.8-206.307-460.8-460.8C51.2 257.507 257.507 51.2 512 51.2c122.4 0 226.684 33.296 312.264 117.369 0.358 0.351 0.358-24.052 0-73.209z" p-id="23839" fill="#adb5bd"></path></svg>
            2023-09-25&nbsp;&nbsp;&nbsp;
        </span>
        <span>
            
            <svg t="1656737548689" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="33866" width="12" height="12"><path d="M832.038608 64.662657H192.030028C121.255125 64.662657 63.940169 121.98845 63.940169 192.694717v446.793671C63.940169 710.205493 121.255125 767.643272 192.030028 767.643272h133.353183a63.940169 63.940169 0 0 1 55.219742 31.576328l76.099638 129.83828c12.358154 21.093031 33.790754 31.626903 55.216129 31.626903s42.832688-10.544709 55.198067-31.619678l76.222461-129.870792a63.940169 63.940169 0 0 1 55.212517-31.551041h133.54103c70.576219 0 127.732228-57.289669 127.732227-127.800865V192.391272C959.825022 121.85479 902.643727 64.662657 832.038608 64.662657zM895.884854 639.842407A63.85347 63.85347 0 0 1 832.092795 703.703103h-133.54103a127.753903 127.753903 0 0 0-110.349172 63.09847l-76.222461 129.856342a0.274545 0.274545 0 0 1 0-0.050574h-0.032512s-0.021675 0.061411-0.032512 0.061412l-76.1466-129.85273A127.804477 127.804477 0 0 0 325.383211 703.703103H192.030028A64.207489 64.207489 0 0 1 127.880338 639.488388V192.694717A64.102729 64.102729 0 0 1 192.030028 128.602826h640.00858A63.799284 63.799284 0 0 1 895.884854 192.391272v447.451135z" fill="#adb5bd" p-id="33867"></path><path d="M608.154093 288.092004A31.970084 31.970084 0 0 0 576.184009 320.062089v160.078006l-134.650049-179.278119A31.970084 31.970084 0 0 0 384.002258 320.062089v255.760676a31.970084 31.970084 0 0 0 63.940169 0v-159.958796l134.650048 179.274507a31.970084 31.970084 0 0 0 57.531703-19.200113V320.062089a31.970084 31.970084 0 0 0-31.970085-31.970085z" fill="#adb5bd" p-id="33868"></path></svg>
            12669 字</span>&nbsp;
        <span>
            
            <svg t="1656737462334" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="32892" width="12" height="12"><path d="M512 74.666667C270.933333 74.666667 74.666667 270.933333 74.666667 512S270.933333 949.333333 512 949.333333 949.333333 753.066667 949.333333 512 753.066667 74.666667 512 74.666667z m0 810.666666c-204.8 0-373.333333-168.533333-373.333333-373.333333S307.2 138.666667 512 138.666667 885.333333 307.2 885.333333 512 716.8 885.333333 512 885.333333z" p-id="32893" fill="#adb5bd"></path><path d="M695.466667 567.466667l-151.466667-70.4V277.333333c0-17.066667-14.933333-32-32-32s-32 14.933333-32 32v238.933334c0 12.8 6.4 23.466667 19.2 29.866666l170.666667 81.066667c4.266667 2.133333 8.533333 2.133333 12.8 2.133333 12.8 0 23.466667-6.4 29.866666-19.2 6.4-14.933333 0-34.133333-17.066666-42.666666z" p-id="32894" fill="#adb5bd"></path></svg>
            26 分钟</span>
            <div class="container-ctgtag">
	<div class="taxonomy">
		
		<div class="ctg">
			
			
			<a href="/categories/%E7%A8%8B%E6%8A%80">程技</a>
			
		</div>
		<div class="tag">
			
			 - 
			
			<a href="/tags/python">python</a>
			
		</div>
	</div>
</div>
        
    </div>
    
    <div class="toc">
        
        <div class="page-operation">
            <div><a href="#"><img src="/imgs/icons/arrow-up-circle.svg" alt=""></a></div>
            <div><a href="https://richfan.site/posts/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch04-numpy%E5%9F%BA%E7%A1%80%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A2%E9%87%8F%E8%AE%A1%E7%AE%97/"><img src="/imgs/icons/arrow-left-circle.svg" alt=""></a></div>
            <div><a href="https://richfan.site/posts/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E9%99%84%E5%BD%95b-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8Eipython%E7%9A%84%E5%86%85%E5%AE%B9/"><img src="/imgs/icons/arrow-right-circle.svg" alt=""></a></div>
        </div>
        
        <nav id="TableOfContents">
  <ul>
    <li><a href="#a1-ndarray对象的内部机理">A.1 ndarray对象的内部机理</a>
      <ul>
        <li><a href="#numpy数据类型体系">NumPy数据类型体系</a></li>
      </ul>
    </li>
    <li><a href="#a2-高级数组操作">A.2 高级数组操作</a>
      <ul>
        <li><a href="#数组重塑">数组重塑</a></li>
        <li><a href="#c和fortran顺序">C和Fortran顺序</a></li>
        <li><a href="#数组的合并和拆分">数组的合并和拆分</a></li>
        <li><a href="#堆叠辅助类r_和c_">堆叠辅助类：r_和c_</a></li>
        <li><a href="#元素的重复操作tile和repeat">元素的重复操作：tile和repeat</a></li>
        <li><a href="#花式索引的等价函数take和put">花式索引的等价函数：take和put</a></li>
      </ul>
    </li>
    <li><a href="#a3-广播">A.3 广播</a>
      <ul>
        <li><a href="#沿其它轴向广播">沿其它轴向广播</a></li>
        <li><a href="#通过广播设置数组的值">通过广播设置数组的值</a></li>
      </ul>
    </li>
    <li><a href="#a4-ufunc高级应用">A.4 ufunc高级应用</a>
      <ul>
        <li><a href="#ufunc实例方法">ufunc实例方法</a></li>
        <li><a href="#编写新的ufunc">编写新的ufunc</a></li>
      </ul>
    </li>
    <li><a href="#a5-结构化和记录式数组">A.5 结构化和记录式数组</a>
      <ul>
        <li><a href="#嵌套dtype和多维字段">嵌套dtype和多维字段</a></li>
        <li><a href="#为什么要用结构化数组">为什么要用结构化数组</a></li>
      </ul>
    </li>
    <li><a href="#a6-更多有关排序的话题">A.6 更多有关排序的话题</a>
      <ul>
        <li><a href="#间接排序argsort和lexsort">间接排序：argsort和lexsort</a></li>
        <li><a href="#其他排序算法">其他排序算法</a></li>
        <li><a href="#部分排序数组">部分排序数组</a></li>
        <li><a href="#numpysearchsorted在有序数组中查找元素">numpy.searchsorted：在有序数组中查找元素</a></li>
        <li><a href="#用numba创建自定义numpyufunc对象">用Numba创建自定义numpy.ufunc对象</a></li>
      </ul>
    </li>
    <li><a href="#a8-高级数组输入输出">A.8 高级数组输入输出</a>
      <ul>
        <li><a href="#内存映像文件">内存映像文件</a></li>
        <li><a href="#hdf5及其他数组存储方式">HDF5及其他数组存储方式</a></li>
      </ul>
    </li>
    <li><a href="#a9-性能建议">A.9 性能建议</a>
      <ul>
        <li><a href="#连续内存的重要性">连续内存的重要性</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>

    <div class='content  content '>
        <p>在这篇附录中，我会深入NumPy库的数组计算。这会包括ndarray更内部的细节，和更高级的数组操作和算法。</p>
<p>本章包括了一些杂乱的章节，不需要仔细研究。</p>
<h2 id="a1-ndarray对象的内部机理">A.1 ndarray对象的内部机理</h2>
<p>NumPy的ndarray提供了一种将同质数据块（可以是连续或跨越）解释为多维数组对象的方式。正如你之前所看到的那样，数据类型（dtype）决定了数据的解释方式，比如浮点数、整数、布尔值等。</p>
<p>ndarray如此强大的部分原因是所有数组对象都是数据块的一个跨度视图（strided view）。你可能想知道数组视图arr[::2,::-1]不复制任何数据的原因是什么。简单地说，ndarray不只是一块内存和一个dtype，它还有跨度信息，这使得数组能以各种步幅（step size）在内存中移动。更准确地讲，ndarray内部由以下内容组成：</p>
<ul>
<li>一个指向数据（内存或内存映射文件中的一块数据）的指针。</li>
<li>数据类型或dtype，描述在数组中的固定大小值的格子。</li>
<li>一个表示数组形状（shape）的元组。</li>
<li>一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要“跨过”的字节数。</li>
</ul>
<p>图A-1简单地说明了ndarray的内部结构。</p>
<p><img src="https://gitee.com/wugenqiang/images/raw/master/01/1240-20201013185150181.png" alt="图A-1 Numpy的ndarray对象"></p>
<p>例如，一个10×5的数组，其形状为(10,5)：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">10</span>]: np<span style="color:#000;font-weight:bold">.</span>ones((<span style="color:#099">10</span>, <span style="color:#099">5</span>))<span style="color:#000;font-weight:bold">.</span>shape
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">10</span>]: (<span style="color:#099">10</span>, <span style="color:#099">5</span>)
</span></span></code></pre></div><p>一个典型的（C顺序，稍后将详细讲解）3×4×5的float64（8个字节）数组，其跨度为(160,40,8) —— 知道跨度是非常有用的，通常，<strong>跨度在一个轴上越大，沿这个轴进行计算的开销就越大</strong>：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">11</span>]: np<span style="color:#000;font-weight:bold">.</span>ones((<span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>), dtype<span style="color:#000;font-weight:bold">=</span>np<span style="color:#000;font-weight:bold">.</span>float64)<span style="color:#000;font-weight:bold">.</span>strides
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">11</span>]: (<span style="color:#099">160</span>, <span style="color:#099">40</span>, <span style="color:#099">8</span>)
</span></span></code></pre></div><p>虽然NumPy用户很少会对数组的跨度信息感兴趣，但它们却是构建非复制式数组视图的重要因素。跨度甚至可以是负数，这样会使数组在内存中后向移动，比如在切片obj[::-1]或obj[:,::-1]中就是这样的。</p>
<h3 id="numpy数据类型体系">NumPy数据类型体系</h3>
<p>你可能偶尔需要检查数组中所包含的是否是<strong>整数、浮点数、字符串或Python对象</strong>。因为浮点数的种类很多（从float16到float128），判断dtype是否属于某个大类的工作非常繁琐。幸运的是，dtype都有一个超类（比如np.integer和np.floating），它们可以跟np.issubdtype函数结合使用：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">12</span>]: ints <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>ones(<span style="color:#099">10</span>, dtype<span style="color:#000;font-weight:bold">=</span>np<span style="color:#000;font-weight:bold">.</span>uint16)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">13</span>]: floats <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>ones(<span style="color:#099">10</span>, dtype<span style="color:#000;font-weight:bold">=</span>np<span style="color:#000;font-weight:bold">.</span>float32)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">14</span>]: np<span style="color:#000;font-weight:bold">.</span>issubdtype(ints<span style="color:#000;font-weight:bold">.</span>dtype, np<span style="color:#000;font-weight:bold">.</span>integer)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">14</span>]: <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">15</span>]: np<span style="color:#000;font-weight:bold">.</span>issubdtype(floats<span style="color:#000;font-weight:bold">.</span>dtype, np<span style="color:#000;font-weight:bold">.</span>floating)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">15</span>]: <span style="color:#000;font-weight:bold">True</span>
</span></span></code></pre></div><p>调用dtype的mro方法即可查看其所有的父类：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">16</span>]: np<span style="color:#000;font-weight:bold">.</span>float64<span style="color:#000;font-weight:bold">.</span>mro()
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">16</span>]:
</span></span><span style="display:flex;"><span>[numpy<span style="color:#000;font-weight:bold">.</span>float64,
</span></span><span style="display:flex;"><span> numpy<span style="color:#000;font-weight:bold">.</span>floating,
</span></span><span style="display:flex;"><span> numpy<span style="color:#000;font-weight:bold">.</span>inexact,
</span></span><span style="display:flex;"><span> numpy<span style="color:#000;font-weight:bold">.</span>number,
</span></span><span style="display:flex;"><span> numpy<span style="color:#000;font-weight:bold">.</span>generic,
</span></span><span style="display:flex;"><span> <span style="color:#0086b3">float</span>,
</span></span><span style="display:flex;"><span> <span style="color:#0086b3">object</span>]
</span></span></code></pre></div><p>然后得到：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">17</span>]: np<span style="color:#000;font-weight:bold">.</span>issubdtype(ints<span style="color:#000;font-weight:bold">.</span>dtype, np<span style="color:#000;font-weight:bold">.</span>number)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">17</span>]: <span style="color:#000;font-weight:bold">True</span>
</span></span></code></pre></div><p>大部分NumPy用户完全不需要了解这些知识，但是这些知识偶尔还是能派上用场的。图A-2说明了dtype体系以及父子类关系。</p>
<p><img src="https://gitee.com/wugenqiang/images/raw/master/01/1240-20201013191615384.png" alt="图A-2 NumPy的dtype体系"></p>
<h2 id="a2-高级数组操作">A.2 高级数组操作</h2>
<p>除花式索引、切片、布尔条件取子集等操作之外，数组的操作方式还有很多。虽然pandas中的高级函数可以处理数据分析工作中的许多重型任务，但有时你还是需要编写一些在现有库中找不到的数据算法。</p>
<h3 id="数组重塑">数组重塑</h3>
<p>多数情况下，你可以无需复制任何数据，就将数组从一个形状转换为另一个形状。只需向数组的实例方法reshape传入一个表示新形状的元组即可实现该目的。例如，假设有一个一维数组，我们希望将其重新排列为一个矩阵（结果见图A-3）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">18</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">8</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">19</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">19</span>]: array([<span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>, <span style="color:#099">6</span>, <span style="color:#099">7</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">20</span>]: arr<span style="color:#000;font-weight:bold">.</span>reshape((<span style="color:#099">4</span>, <span style="color:#099">2</span>))
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">20</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#099">0</span>, <span style="color:#099">1</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">2</span>, <span style="color:#099">3</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">4</span>, <span style="color:#099">5</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">6</span>, <span style="color:#099">7</span>]])
</span></span></code></pre></div><p><img src="https://gitee.com/wugenqiang/images/raw/master/01/1240-20201014192853651.png" alt="图A-3 按C顺序（按行）和按Fortran顺序（按列）进行重塑"></p>
<p>多维数组也能被重塑：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">21</span>]: arr<span style="color:#000;font-weight:bold">.</span>reshape((<span style="color:#099">4</span>, <span style="color:#099">2</span>))<span style="color:#000;font-weight:bold">.</span>reshape((<span style="color:#099">2</span>, <span style="color:#099">4</span>))
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">21</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">4</span>, <span style="color:#099">5</span>, <span style="color:#099">6</span>, <span style="color:#099">7</span>]])
</span></span></code></pre></div><p>作为参数的形状的其中一维可以是－1，它表示该维度的大小由数据本身推断而来：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">22</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">15</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">23</span>]: arr<span style="color:#000;font-weight:bold">.</span>reshape((<span style="color:#099">5</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>))
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">23</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0</span>,  <span style="color:#099">1</span>,  <span style="color:#099">2</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">3</span>,  <span style="color:#099">4</span>,  <span style="color:#099">5</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">6</span>,  <span style="color:#099">7</span>,  <span style="color:#099">8</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">9</span>, <span style="color:#099">10</span>, <span style="color:#099">11</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">12</span>, <span style="color:#099">13</span>, <span style="color:#099">14</span>]])
</span></span></code></pre></div><p>与reshape将一维数组转换为多维数组的运算过程相反的运算通常称为扁平化（flattening）或散开（raveling）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">27</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">15</span>)<span style="color:#000;font-weight:bold">.</span>reshape((<span style="color:#099">5</span>, <span style="color:#099">3</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">28</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">28</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0</span>,  <span style="color:#099">1</span>,  <span style="color:#099">2</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">3</span>,  <span style="color:#099">4</span>,  <span style="color:#099">5</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">6</span>,  <span style="color:#099">7</span>,  <span style="color:#099">8</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">9</span>, <span style="color:#099">10</span>, <span style="color:#099">11</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">12</span>, <span style="color:#099">13</span>, <span style="color:#099">14</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">29</span>]: arr<span style="color:#000;font-weight:bold">.</span>ravel()
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">29</span>]: array([ <span style="color:#099">0</span>,  <span style="color:#099">1</span>,  <span style="color:#099">2</span>,  <span style="color:#099">3</span>,  <span style="color:#099">4</span>,  <span style="color:#099">5</span>,  <span style="color:#099">6</span>,  <span style="color:#099">7</span>,  <span style="color:#099">8</span>,  <span style="color:#099">9</span>, <span style="color:#099">10</span>, <span style="color:#099">11</span>, <span style="color:#099">12</span>, <span style="color:#099">13</span>, <span style="color:#099">14</span>])
</span></span></code></pre></div><p>如果结果中的值与原始数组相同，ravel不会产生源数据的副本。flatten方法的行为类似于ravel，只不过它总是返回数据的副本：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">30</span>]: arr<span style="color:#000;font-weight:bold">.</span>flatten()
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">30</span>]: array([ <span style="color:#099">0</span>,  <span style="color:#099">1</span>,  <span style="color:#099">2</span>,  <span style="color:#099">3</span>,  <span style="color:#099">4</span>,  <span style="color:#099">5</span>,  <span style="color:#099">6</span>,  <span style="color:#099">7</span>,  <span style="color:#099">8</span>,  <span style="color:#099">9</span>, <span style="color:#099">10</span>, <span style="color:#099">11</span>, <span style="color:#099">12</span>, <span style="color:#099">13</span>, <span style="color:#099">14</span>])
</span></span></code></pre></div><p>数组可以被重塑或散开为别的顺序。这对NumPy新手来说是一个比较微妙的问题，所以在下一小节中我们将专门讲解这个问题。</p>
<h3 id="c和fortran顺序">C和Fortran顺序</h3>
<p>NumPy允许你更为灵活地控制数据在内存中的布局。默认情况下，NumPy数组是按行优先顺序创建的。在空间方面，这就意味着，对于一个二维数组，每行中的数据项是被存放在相邻内存位置上的。另一种顺序是列优先顺序，它意味着每列中的数据项是被存放在相邻内存位置上的。</p>
<p>由于一些历史原因，行和列优先顺序又分别称为C和Fortran顺序。在FORTRAN 77中，矩阵全都是列优先的。</p>
<p>像reshape和reval这样的函数，都可以接受一个表示数组数据存放顺序的order参数。一般可以是&rsquo;C&rsquo;或&rsquo;F&rsquo;（还有&rsquo;A&rsquo;和&rsquo;K&rsquo;等不常用的选项，具体请参考NumPy的文档）。图A-3对此进行了说明：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">31</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">12</span>)<span style="color:#000;font-weight:bold">.</span>reshape((<span style="color:#099">3</span>, <span style="color:#099">4</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">32</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">32</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0</span>,  <span style="color:#099">1</span>,  <span style="color:#099">2</span>,  <span style="color:#099">3</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">4</span>,  <span style="color:#099">5</span>,  <span style="color:#099">6</span>,  <span style="color:#099">7</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">8</span>,  <span style="color:#099">9</span>, <span style="color:#099">10</span>, <span style="color:#099">11</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">33</span>]: arr<span style="color:#000;font-weight:bold">.</span>ravel()
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">33</span>]: array([ <span style="color:#099">0</span>,  <span style="color:#099">1</span>,  <span style="color:#099">2</span>,  <span style="color:#099">3</span>,  <span style="color:#099">4</span>,  <span style="color:#099">5</span>,  <span style="color:#099">6</span>,  <span style="color:#099">7</span>,  <span style="color:#099">8</span>,  <span style="color:#099">9</span>, <span style="color:#099">10</span>, <span style="color:#099">11</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">34</span>]: arr<span style="color:#000;font-weight:bold">.</span>ravel(<span style="color:#d14">&#39;F&#39;</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">34</span>]: array([ <span style="color:#099">0</span>,  <span style="color:#099">4</span>,  <span style="color:#099">8</span>,  <span style="color:#099">1</span>,  <span style="color:#099">5</span>,  <span style="color:#099">9</span>,  <span style="color:#099">2</span>,  <span style="color:#099">6</span>, <span style="color:#099">10</span>,  <span style="color:#099">3</span>,  <span style="color:#099">7</span>, <span style="color:#099">11</span>])
</span></span></code></pre></div><p><img src="https://gitee.com/wugenqiang/images/raw/master/01/1240-20201014194504260.png" alt="图A-3 按C（行优先）或Fortran（列优先）顺序进行重塑"></p>
<p>二维或更高维数组的重塑过程比较令人费解（见图A-3）。C和Fortran顺序的关键区别就是维度的行进顺序：</p>
<ul>
<li>C/行优先顺序：先经过更高的维度（例如，轴1会先于轴0被处理）。</li>
<li>Fortran/列优先顺序：后经过更高的维度（例如，轴0会先于轴1被处理）。</li>
</ul>
<h3 id="数组的合并和拆分">数组的合并和拆分</h3>
<p><code>numpy.concatenate</code>可以按指定轴将一个由数组组成的序列（如元组、列表等）连接到一起：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">35</span>]: arr1 <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>array([[<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>], [<span style="color:#099">4</span>, <span style="color:#099">5</span>, <span style="color:#099">6</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">36</span>]: arr2 <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>array([[<span style="color:#099">7</span>, <span style="color:#099">8</span>, <span style="color:#099">9</span>], [<span style="color:#099">10</span>, <span style="color:#099">11</span>, <span style="color:#099">12</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">37</span>]: np<span style="color:#000;font-weight:bold">.</span>concatenate([arr1, arr2], axis<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">37</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">1</span>,  <span style="color:#099">2</span>,  <span style="color:#099">3</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">4</span>,  <span style="color:#099">5</span>,  <span style="color:#099">6</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">7</span>,  <span style="color:#099">8</span>,  <span style="color:#099">9</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">10</span>, <span style="color:#099">11</span>, <span style="color:#099">12</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">38</span>]: np<span style="color:#000;font-weight:bold">.</span>concatenate([arr1, arr2], axis<span style="color:#000;font-weight:bold">=</span><span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">38</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">1</span>,  <span style="color:#099">2</span>,  <span style="color:#099">3</span>,  <span style="color:#099">7</span>,  <span style="color:#099">8</span>,  <span style="color:#099">9</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">4</span>,  <span style="color:#099">5</span>,  <span style="color:#099">6</span>, <span style="color:#099">10</span>, <span style="color:#099">11</span>, <span style="color:#099">12</span>]])
</span></span></code></pre></div><p>对于常见的连接操作，NumPy提供了一些比较方便的方法（如<code>vstack</code>和<code>hstack</code>）。因此，上面的运算还可以表达为：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">39</span>]: np<span style="color:#000;font-weight:bold">.</span>vstack((arr1, arr2))
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">39</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">1</span>,  <span style="color:#099">2</span>,  <span style="color:#099">3</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">4</span>,  <span style="color:#099">5</span>,  <span style="color:#099">6</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">7</span>,  <span style="color:#099">8</span>,  <span style="color:#099">9</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">10</span>, <span style="color:#099">11</span>, <span style="color:#099">12</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">40</span>]: np<span style="color:#000;font-weight:bold">.</span>hstack((arr1, arr2))
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">40</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">1</span>,  <span style="color:#099">2</span>,  <span style="color:#099">3</span>,  <span style="color:#099">7</span>,  <span style="color:#099">8</span>,  <span style="color:#099">9</span>],
</span></span><span style="display:flex;"><span>[ <span style="color:#099">4</span>,  <span style="color:#099">5</span>,  <span style="color:#099">6</span>, <span style="color:#099">10</span>, <span style="color:#099">11</span>, <span style="color:#099">12</span>]])
</span></span></code></pre></div><p>与此相反，<code>split</code>用于将一个数组沿指定轴拆分为多个数组：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">41</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">5</span>, <span style="color:#099">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">42</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">42</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2047</span>,  <span style="color:#099">0.4789</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5194</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5557</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.9658</span>,  <span style="color:#099">1.3934</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.0929</span>,  <span style="color:#099">0.2817</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.769</span> ,  <span style="color:#099">1.2464</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">43</span>]: first, second, third <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>split(arr, [<span style="color:#099">1</span>, <span style="color:#099">3</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">44</span>]: first
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">44</span>]: array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2047</span>,  <span style="color:#099">0.4789</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">45</span>]: second
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">45</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5194</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5557</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.9658</span>,  <span style="color:#099">1.3934</span>]])
</span></span><span style="display:flex;"><span>In [<span style="color:#099">46</span>]: third
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">46</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0.0929</span>,  <span style="color:#099">0.2817</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.769</span> ,  <span style="color:#099">1.2464</span>]])
</span></span></code></pre></div><p>传入到np.split的值[1,3]指示在哪个索引处分割数组。</p>
<p>表A-1中列出了所有关于数组连接和拆分的函数，其中有些是专门为了方便常见的连接运算而提供的。</p>
<p><img src="https://gitee.com/wugenqiang/images/raw/master/01/1240-20201014200352394.png" alt="表A-1 数组连接函数"></p>
<h3 id="堆叠辅助类r_和c_">堆叠辅助类：r_和c_</h3>
<p>NumPy命名空间中有两个特殊的对象——r_和c_，它们可以使数组的堆叠操作更为简洁：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">47</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">6</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">48</span>]: arr1 <span style="color:#000;font-weight:bold">=</span> arr<span style="color:#000;font-weight:bold">.</span>reshape((<span style="color:#099">3</span>, <span style="color:#099">2</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">49</span>]: arr2 <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">3</span>, <span style="color:#099">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">50</span>]: np<span style="color:#000;font-weight:bold">.</span>r_[arr1, arr2]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">50</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0.</span>    ,  <span style="color:#099">1.</span>    ],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">2.</span>    ,  <span style="color:#099">3.</span>    ],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">4.</span>    ,  <span style="color:#099">5.</span>    ],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.0072</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.2962</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.275</span> ,  <span style="color:#099">0.2289</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.3529</span>,  <span style="color:#099">0.8864</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">51</span>]: np<span style="color:#000;font-weight:bold">.</span>c_[np<span style="color:#000;font-weight:bold">.</span>r_[arr1, arr2], arr]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">51</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0.</span>    ,  <span style="color:#099">1.</span>    ,  <span style="color:#099">0.</span>    ],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">2.</span>    ,  <span style="color:#099">3.</span>    ,  <span style="color:#099">1.</span>    ],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">4.</span>    ,  <span style="color:#099">5.</span>    ,  <span style="color:#099">2.</span>    ],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.0072</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.2962</span>,  <span style="color:#099">3.</span>    ],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.275</span> ,  <span style="color:#099">0.2289</span>,  <span style="color:#099">4.</span>    ],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.3529</span>,  <span style="color:#099">0.8864</span>,  <span style="color:#099">5.</span>    ]])
</span></span></code></pre></div><p>它还可以将切片转换成数组：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">52</span>]: np<span style="color:#000;font-weight:bold">.</span>c_[<span style="color:#099">1</span>:<span style="color:#099">6</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">10</span>:<span style="color:#000;font-weight:bold">-</span><span style="color:#099">5</span>]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">52</span>]: 
</span></span><span style="display:flex;"><span>array([[  <span style="color:#099">1</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">10</span>],
</span></span><span style="display:flex;"><span>       [  <span style="color:#099">2</span>,  <span style="color:#000;font-weight:bold">-</span><span style="color:#099">9</span>],
</span></span><span style="display:flex;"><span>       [  <span style="color:#099">3</span>,  <span style="color:#000;font-weight:bold">-</span><span style="color:#099">8</span>],
</span></span><span style="display:flex;"><span>       [  <span style="color:#099">4</span>,  <span style="color:#000;font-weight:bold">-</span><span style="color:#099">7</span>],
</span></span><span style="display:flex;"><span>       [  <span style="color:#099">5</span>,  <span style="color:#000;font-weight:bold">-</span><span style="color:#099">6</span>]])
</span></span></code></pre></div><p>r_和c_的具体功能请参考其文档。</p>
<h3 id="元素的重复操作tile和repeat">元素的重复操作：tile和repeat</h3>
<p>对数组进行重复以产生更大数组的工具主要是repeat和tile这两个函数。repeat会将数组中的各个元素重复一定次数，从而产生一个更大的数组：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">53</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">3</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">54</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">54</span>]: array([<span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">55</span>]: arr<span style="color:#000;font-weight:bold">.</span>repeat(<span style="color:#099">3</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">55</span>]: array([<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">1</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">2</span>, <span style="color:#099">2</span>])
</span></span></code></pre></div><blockquote>
<p>🦊 笔记：跟其他流行的数组编程语言（如MATLAB）不同，NumPy中很少需要对数组进行重复（replicate）。这主要是因为广播（broadcasting，我们将在下一节中讲解该技术）能更好地满足该需求。</p>
</blockquote>
<p>默认情况下，如果传入的是一个整数，则各元素就都会重复那么多次。如果传入的是一组整数，则各元素就可以重复不同的次数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">56</span>]: arr<span style="color:#000;font-weight:bold">.</span>repeat([<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>])
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">56</span>]: array([<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">1</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">2</span>, <span style="color:#099">2</span>, <span style="color:#099">2</span>])
</span></span></code></pre></div><p>对于多维数组，还可以让它们的元素沿指定轴重复：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">57</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">2</span>, <span style="color:#099">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">58</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">58</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">59</span>]: arr<span style="color:#000;font-weight:bold">.</span>repeat(<span style="color:#099">2</span>, axis<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">59</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>]])
</span></span></code></pre></div><p>注意，如果没有设置轴向，则数组会被扁平化，这可能不会是你想要的结果。同样，在对多维进行重复时，也可以传入一组整数，这样就会使各切片重复不同的次数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">60</span>]: arr<span style="color:#000;font-weight:bold">.</span>repeat([<span style="color:#099">2</span>, <span style="color:#099">3</span>], axis<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">60</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">61</span>]: arr<span style="color:#000;font-weight:bold">.</span>repeat([<span style="color:#099">2</span>, <span style="color:#099">3</span>], axis<span style="color:#000;font-weight:bold">=</span><span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">61</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> ,  <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>]])
</span></span></code></pre></div><p>tile的功能是沿指定轴向堆叠数组的副本。你可以形象地将其想象成“铺瓷砖”：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">62</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">62</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">63</span>]: np<span style="color:#000;font-weight:bold">.</span>tile(arr, <span style="color:#099">2</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">63</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>,  <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>]])
</span></span></code></pre></div><p>第二个参数是瓷砖的数量。对于标量，瓷砖是水平铺设的，而不是垂直铺设。它可以是一个表示“铺设”布局的元组：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">64</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">64</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">65</span>]: np<span style="color:#000;font-weight:bold">.</span>tile(arr, (<span style="color:#099">2</span>, <span style="color:#099">1</span>))
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">65</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">66</span>]: np<span style="color:#000;font-weight:bold">.</span>tile(arr, (<span style="color:#099">3</span>, <span style="color:#099">2</span>))
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">66</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>,  <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>,  <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>,  <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>]])
</span></span></code></pre></div><h3 id="花式索引的等价函数take和put">花式索引的等价函数：take和put</h3>
<p>在第4章中我们讲过，获取和设置数组子集的一个办法是通过整数数组使用花式索引：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">67</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">10</span>) <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">100</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">68</span>]: inds <span style="color:#000;font-weight:bold">=</span> [<span style="color:#099">7</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">6</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">69</span>]: arr[inds]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">69</span>]: array([<span style="color:#099">700</span>, <span style="color:#099">100</span>, <span style="color:#099">200</span>, <span style="color:#099">600</span>])
</span></span></code></pre></div><p>ndarray还有其它方法用于获取单个轴向上的选区：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">70</span>]: arr<span style="color:#000;font-weight:bold">.</span>take(inds)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">70</span>]: array([<span style="color:#099">700</span>, <span style="color:#099">100</span>, <span style="color:#099">200</span>, <span style="color:#099">600</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">71</span>]: arr<span style="color:#000;font-weight:bold">.</span>put(inds, <span style="color:#099">42</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">72</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">72</span>]: array([  <span style="color:#099">0</span>,  <span style="color:#099">42</span>,  <span style="color:#099">42</span>, <span style="color:#099">300</span>, <span style="color:#099">400</span>, <span style="color:#099">500</span>,  <span style="color:#099">42</span>,  <span style="color:#099">42</span>,<span style="color:#099">800</span>, <span style="color:#099">900</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">73</span>]: arr<span style="color:#000;font-weight:bold">.</span>put(inds, [<span style="color:#099">40</span>, <span style="color:#099">41</span>, <span style="color:#099">42</span>, <span style="color:#099">43</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">74</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">74</span>]: array([  <span style="color:#099">0</span>,  <span style="color:#099">41</span>,  <span style="color:#099">42</span>, <span style="color:#099">300</span>, <span style="color:#099">400</span>, <span style="color:#099">500</span>,  <span style="color:#099">43</span>,  <span style="color:#099">40</span>, <span style="color:#099">800</span>, <span style="color:#099">900</span>])
</span></span></code></pre></div><p>要在其它轴上使用take，只需传入axis关键字即可：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">75</span>]: inds <span style="color:#000;font-weight:bold">=</span> [<span style="color:#099">2</span>, <span style="color:#099">0</span>, <span style="color:#099">2</span>, <span style="color:#099">1</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">76</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">2</span>, <span style="color:#099">4</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">77</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">77</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5397</span>,  <span style="color:#099">0.477</span> ,  <span style="color:#099">3.2489</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.0212</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5771</span>,  <span style="color:#099">0.1241</span>,  <span style="color:#099">0.3026</span>,  <span style="color:#099">0.5238</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">78</span>]: arr<span style="color:#000;font-weight:bold">.</span>take(inds, axis<span style="color:#000;font-weight:bold">=</span><span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">78</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">3.2489</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5397</span>,  <span style="color:#099">3.2489</span>,  <span style="color:#099">0.477</span> ],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.3026</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5771</span>,  <span style="color:#099">0.3026</span>,  <span style="color:#099">0.1241</span>]])
</span></span></code></pre></div><p>put不接受axis参数，它只会在数组的扁平化版本（一维，C顺序）上进行索引。因此，在需要用其他轴向的索引设置元素时，最好还是使用花式索引。</p>
<h2 id="a3-广播">A.3 广播</h2>
<p>广播（broadcasting）指的是不同形状的数组之间的算术运算的执行方式。它是一种非常强大的功能，但也容易令人误解，即使是经验丰富的老手也是如此。将标量值跟数组合并时就会发生最简单的广播：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">79</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">80</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">80</span>]: array([<span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">81</span>]: arr <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">4</span>
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">81</span>]: array([ <span style="color:#099">0</span>,  <span style="color:#099">4</span>,  <span style="color:#099">8</span>, <span style="color:#099">12</span>, <span style="color:#099">16</span>])
</span></span></code></pre></div><p>这里我们说：在这个乘法运算中，标量值4被广播到了其他所有的元素上。</p>
<p>看一个例子，我们可以通过减去列平均值的方式对数组的每一列进行距平化处理。这个问题解决起来非常简单：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">82</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">4</span>, <span style="color:#099">3</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">83</span>]: arr<span style="color:#000;font-weight:bold">.</span>mean(<span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">83</span>]: array([<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3928</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3824</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.8768</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">84</span>]: demeaned <span style="color:#000;font-weight:bold">=</span> arr <span style="color:#000;font-weight:bold">-</span> arr<span style="color:#000;font-weight:bold">.</span>mean(<span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">85</span>]: demeaned
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">85</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0.3937</span>,  <span style="color:#099">1.7263</span>,  <span style="color:#099">0.1633</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4384</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.9878</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.9839</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.468</span> ,  <span style="color:#099">0.9426</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3891</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.5126</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.6811</span>,  <span style="color:#099">1.2097</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">86</span>]: demeaned<span style="color:#000;font-weight:bold">.</span>mean(<span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">86</span>]: array([<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.</span>,  <span style="color:#099">0.</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.</span>])
</span></span></code></pre></div><p>图A-4形象地展示了该过程。用广播的方式对行进行距平化处理会稍微麻烦一些。幸运的是，只要遵循一定的规则，低维度的值是可以被广播到数组的任意维度的（比如对二维数组各列减去行平均值）。</p>
<p><img src="https://gitee.com/wugenqiang/images/raw/master/01/1240-20201014201122073.png" alt="图A-4 一维数组在轴0上的广播"></p>
<p>于是就得到了：</p>
<p><img src="https://gitee.com/wugenqiang/images/raw/master/01/1240-20201014201130724.png" alt=""></p>
<p>虽然我是一名经验丰富的NumPy老手，但经常还是得停下来画张图并想想广播的原则。再来看一下最后那个例子，假设你希望对各行减去那个平均值。由于arr.mean(0)的长度为3，所以它可以在0轴向上进行广播：因为arr的后缘维度是3，所以它们是兼容的。根据该原则，要在1轴向上做减法（即各行减去行平均值），较小的那个数组的形状必须是(4,1)：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">87</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">87</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0.0009</span>,  <span style="color:#099">1.3438</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.7135</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.8312</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.3702</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.8608</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.8608</span>,  <span style="color:#099">0.5601</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.2659</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.1198</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.0635</span>,  <span style="color:#099">0.3329</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">88</span>]: row_means <span style="color:#000;font-weight:bold">=</span> arr<span style="color:#000;font-weight:bold">.</span>mean(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">89</span>]: row_means<span style="color:#000;font-weight:bold">.</span>shape
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">89</span>]: (<span style="color:#099">4</span>,)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">90</span>]: row_means<span style="color:#000;font-weight:bold">.</span>reshape((<span style="color:#099">4</span>, <span style="color:#099">1</span>))
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">90</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0.2104</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.6874</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5222</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2036</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">91</span>]: demeaned <span style="color:#000;font-weight:bold">=</span> arr <span style="color:#000;font-weight:bold">-</span> row_means<span style="color:#000;font-weight:bold">.</span>reshape((<span style="color:#099">4</span>, <span style="color:#099">1</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">92</span>]: demeaned<span style="color:#000;font-weight:bold">.</span>mean(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">92</span>]: array([ <span style="color:#099">0.</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>])
</span></span></code></pre></div><p>图A-5说明了该运算的过程。</p>
<p><img src="https://gitee.com/wugenqiang/images/raw/master/01/1240-20201014201328232.png" alt="图A-5 二维数组在轴1上的广播"></p>
<p>图A-6展示了另外一种情况，这次是在一个三维数组上沿0轴向加上一个二维数组。</p>
<p><img src="https://gitee.com/wugenqiang/images/raw/master/01/1240-20201014201355589.png" alt="图A-6 三维数组在轴0上的广播"></p>
<h3 id="沿其它轴向广播">沿其它轴向广播</h3>
<p>高维度数组的广播似乎更难以理解，而实际上它也是遵循广播原则的。如果不然，你就会得到下面这样一个错误：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">93</span>]: arr <span style="color:#000;font-weight:bold">-</span> arr<span style="color:#000;font-weight:bold">.</span>mean(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">---------------------------------------------------------------------------</span>
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">ValueError</span>                                Traceback (most recent call last)
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">&lt;</span>ipython<span style="color:#000;font-weight:bold">-</span><span style="color:#0086b3">input</span><span style="color:#000;font-weight:bold">-</span><span style="color:#099">93</span><span style="color:#000;font-weight:bold">-</span><span style="color:#099">7</span>b87b85a20b2<span style="color:#000;font-weight:bold">&gt;</span> <span style="color:#000;font-weight:bold">in</span> <span style="color:#000;font-weight:bold">&lt;</span>module<span style="color:#000;font-weight:bold">&gt;</span>()
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">----&gt;</span> <span style="color:#099">1</span> arr <span style="color:#000;font-weight:bold">-</span> arr<span style="color:#000;font-weight:bold">.</span>mean(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#900;font-weight:bold">ValueError</span>: operands could <span style="color:#000;font-weight:bold">not</span> be broadcast together <span style="color:#000;font-weight:bold">with</span> shapes (<span style="color:#099">4</span>,<span style="color:#099">3</span>) (<span style="color:#099">4</span>,)
</span></span></code></pre></div><p>人们经常需要通过算术运算过程将较低维度的数组在除0轴以外的其他轴向上广播。根据广播的原则，较小数组的“广播维”必须为1。在上面那个行距平化的例子中，这就意味着要将行平均值的形状变成(4,1)而不是(4,)：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">94</span>]: arr <span style="color:#000;font-weight:bold">-</span> arr<span style="color:#000;font-weight:bold">.</span>mean(<span style="color:#099">1</span>)<span style="color:#000;font-weight:bold">.</span>reshape((<span style="color:#099">4</span>, <span style="color:#099">1</span>))
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">94</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2095</span>,  <span style="color:#099">1.1334</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.9239</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.8562</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.6828</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1734</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3386</span>,  <span style="color:#099">1.0823</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.7438</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.3234</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.8599</span>,  <span style="color:#099">0.5365</span>]])
</span></span></code></pre></div><p>对于三维的情况，在三维中的任何一维上广播其实也就是将数据重塑为兼容的形状而已。图A-7说明了要在三维数组各维度上广播的形状需求。</p>
<p><img src="https://gitee.com/wugenqiang/images/raw/master/01/1240-20201014202009833.png" alt="图A-7：能在该三维数组上广播的二维数组的形状"></p>
<p>于是就有了一个非常普遍的问题（尤其是在通用算法中），即专门为了广播而添加一个长度为1的新轴。虽然reshape是一个办法，但插入轴需要构造一个表示新形状的元组。这是一个很郁闷的过程。因此，NumPy数组提供了一种通过索引机制插入轴的特殊语法。下面这段代码通过特殊的np.newaxis属性以及“全”切片来插入新轴：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">95</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>zeros((<span style="color:#099">4</span>, <span style="color:#099">4</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">96</span>]: arr_3d <span style="color:#000;font-weight:bold">=</span> arr[:, np<span style="color:#000;font-weight:bold">.</span>newaxis, :]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">97</span>]: arr_3d<span style="color:#000;font-weight:bold">.</span>shape
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">97</span>]: (<span style="color:#099">4</span>, <span style="color:#099">1</span>, <span style="color:#099">4</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">98</span>]: arr_1d <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>normal(size<span style="color:#000;font-weight:bold">=</span><span style="color:#099">3</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">99</span>]: arr_1d[:, np<span style="color:#000;font-weight:bold">.</span>newaxis]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">99</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.3594</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1995</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.542</span> ]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">100</span>]: arr_1d[np<span style="color:#000;font-weight:bold">.</span>newaxis, :]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">100</span>]: array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.3594</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1995</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.542</span> ]])
</span></span></code></pre></div><p>因此，如果我们有一个三维数组，并希望对轴2进行距平化，那么只需要编写下面这样的代码就可以了：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">101</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">102</span>]: depth_means <span style="color:#000;font-weight:bold">=</span> arr<span style="color:#000;font-weight:bold">.</span>mean(<span style="color:#099">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">103</span>]: depth_means
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">103</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4735</span>,  <span style="color:#099">0.3971</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.0228</span>,  <span style="color:#099">0.2001</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3521</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.281</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.071</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1586</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.6245</span>,  <span style="color:#099">0.6047</span>,  <span style="color:#099">0.4396</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2846</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">104</span>]: depth_means<span style="color:#000;font-weight:bold">.</span>shape
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">104</span>]: (<span style="color:#099">3</span>, <span style="color:#099">4</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">105</span>]: demeaned <span style="color:#000;font-weight:bold">=</span> arr <span style="color:#000;font-weight:bold">-</span> depth_means[:, :, np<span style="color:#000;font-weight:bold">.</span>newaxis]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">106</span>]: demeaned<span style="color:#000;font-weight:bold">.</span>mean(<span style="color:#099">2</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">106</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.</span>,  <span style="color:#099">0.</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.</span>]])
</span></span></code></pre></div><p>有些读者可能会想，在对指定轴进行距平化时，有没有一种既通用又不牺牲性能的方法呢？实际上是有的，但需要一些索引方面的技巧：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">demean_axis</span>(arr, axis<span style="color:#000;font-weight:bold">=</span><span style="color:#099">0</span>):
</span></span><span style="display:flex;"><span>    means <span style="color:#000;font-weight:bold">=</span> arr<span style="color:#000;font-weight:bold">.</span>mean(axis)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">## This generalizes things like [:, :, np.newaxis] to N dimensions</span>
</span></span><span style="display:flex;"><span>    indexer <span style="color:#000;font-weight:bold">=</span> [<span style="color:#0086b3">slice</span>(<span style="color:#000;font-weight:bold">None</span>)] <span style="color:#000;font-weight:bold">*</span> arr<span style="color:#000;font-weight:bold">.</span>ndim
</span></span><span style="display:flex;"><span>    indexer[axis] <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>newaxis
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> arr <span style="color:#000;font-weight:bold">-</span> means[indexer]
</span></span></code></pre></div><h3 id="通过广播设置数组的值">通过广播设置数组的值</h3>
<p>算术运算所遵循的广播原则同样也适用于通过索引机制设置数组值的操作。对于最简单的情况，我们可以这样做：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">107</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>zeros((<span style="color:#099">4</span>, <span style="color:#099">3</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">108</span>]: arr[:] <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">109</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">109</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">5.</span>,  <span style="color:#099">5.</span>,  <span style="color:#099">5.</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">5.</span>,  <span style="color:#099">5.</span>,  <span style="color:#099">5.</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">5.</span>,  <span style="color:#099">5.</span>,  <span style="color:#099">5.</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">5.</span>,  <span style="color:#099">5.</span>,  <span style="color:#099">5.</span>]])
</span></span></code></pre></div><p>但是，假设我们想要用一个一维数组来设置目标数组的各列，只要保证形状兼容就可以了：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">110</span>]: col <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>array([<span style="color:#099">1.28</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.42</span>, <span style="color:#099">0.44</span>, <span style="color:#099">1.6</span>])
</span></span><span style="display:flex;"><span>In [<span style="color:#099">111</span>]: arr[:] <span style="color:#000;font-weight:bold">=</span> col[:, np<span style="color:#000;font-weight:bold">.</span>newaxis]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">112</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">112</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">1.28</span>,  <span style="color:#099">1.28</span>,  <span style="color:#099">1.28</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.42</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.42</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.42</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.44</span>,  <span style="color:#099">0.44</span>,  <span style="color:#099">0.44</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.6</span> ,  <span style="color:#099">1.6</span> ,  <span style="color:#099">1.6</span> ]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">113</span>]: arr[:<span style="color:#099">2</span>] <span style="color:#000;font-weight:bold">=</span> [[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.37</span>], [<span style="color:#099">0.509</span>]]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">114</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">114</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.37</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.37</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.37</span> ],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.509</span>,  <span style="color:#099">0.509</span>,  <span style="color:#099">0.509</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.44</span> ,  <span style="color:#099">0.44</span> ,  <span style="color:#099">0.44</span> ],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.6</span>  ,  <span style="color:#099">1.6</span>  ,  <span style="color:#099">1.6</span>  ]])
</span></span></code></pre></div><h2 id="a4-ufunc高级应用">A.4 ufunc高级应用</h2>
<p>虽然许多NumPy用户只会用到通用函数所提供的快速的元素级运算，但通用函数实际上还有一些高级用法能使我们丢开循环而编写出更为简洁的代码。</p>
<h3 id="ufunc实例方法">ufunc实例方法</h3>
<p>NumPy的各个二元ufunc都有一些用于执行特定矢量化运算的特殊方法。表A-2汇总了这些方法，下面我将通过几个具体的例子对它们进行说明。</p>
<p>reduce接受一个数组参数，并通过一系列的二元运算对其值进行聚合（可指明轴向）。例如，我们可以用np.add.reduce对数组中各个元素进行求和：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">115</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">116</span>]: np<span style="color:#000;font-weight:bold">.</span>add<span style="color:#000;font-weight:bold">.</span>reduce(arr)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">116</span>]: <span style="color:#099">45</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">117</span>]: arr<span style="color:#000;font-weight:bold">.</span>sum()
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">117</span>]: <span style="color:#099">45</span>
</span></span></code></pre></div><p>起始值取决于ufunc（对于add的情况，就是0）。如果设置了轴号，约简运算就会沿该轴向执行。这就使你能用一种比较简洁的方式得到某些问题的答案。在下面这个例子中，我们用np.logical_and检查数组各行中的值是否是有序的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">118</span>]: np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>seed(<span style="color:#099">12346</span>)  <span style="color:#998;font-style:italic">## for reproducibility</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">119</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">5</span>, <span style="color:#099">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">120</span>]: arr[::<span style="color:#099">2</span>]<span style="color:#000;font-weight:bold">.</span>sort(<span style="color:#099">1</span>) <span style="color:#998;font-style:italic">## sort a few rows</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">121</span>]: arr[:, :<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>] <span style="color:#000;font-weight:bold">&lt;</span> arr[:, <span style="color:#099">1</span>:]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">121</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#000;font-weight:bold">True</span>,  <span style="color:#000;font-weight:bold">True</span>,  <span style="color:#000;font-weight:bold">True</span>,  <span style="color:#000;font-weight:bold">True</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">False</span>,  <span style="color:#000;font-weight:bold">True</span>, <span style="color:#000;font-weight:bold">False</span>, <span style="color:#000;font-weight:bold">False</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#000;font-weight:bold">True</span>,  <span style="color:#000;font-weight:bold">True</span>,  <span style="color:#000;font-weight:bold">True</span>,  <span style="color:#000;font-weight:bold">True</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#000;font-weight:bold">True</span>, <span style="color:#000;font-weight:bold">False</span>,  <span style="color:#000;font-weight:bold">True</span>,  <span style="color:#000;font-weight:bold">True</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#000;font-weight:bold">True</span>,  <span style="color:#000;font-weight:bold">True</span>,  <span style="color:#000;font-weight:bold">True</span>,  <span style="color:#000;font-weight:bold">True</span>]], dtype<span style="color:#000;font-weight:bold">=</span><span style="color:#0086b3">bool</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">122</span>]: np<span style="color:#000;font-weight:bold">.</span>logical_and<span style="color:#000;font-weight:bold">.</span>reduce(arr[:, :<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>] <span style="color:#000;font-weight:bold">&lt;</span> arr[:, <span style="color:#099">1</span>:], axis<span style="color:#000;font-weight:bold">=</span><span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">122</span>]: array([ <span style="color:#000;font-weight:bold">True</span>, <span style="color:#000;font-weight:bold">False</span>,  <span style="color:#000;font-weight:bold">True</span>, <span style="color:#000;font-weight:bold">False</span>,  <span style="color:#000;font-weight:bold">True</span>], dtype<span style="color:#000;font-weight:bold">=</span><span style="color:#0086b3">bool</span>)
</span></span></code></pre></div><p>注意，logical_and.reduce跟all方法是等价的。</p>
<p>ccumulate跟reduce的关系就像cumsum跟sum的关系那样。它产生一个跟原数组大小相同的中间“累计”值数组：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">123</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">15</span>)<span style="color:#000;font-weight:bold">.</span>reshape((<span style="color:#099">3</span>, <span style="color:#099">5</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">124</span>]: np<span style="color:#000;font-weight:bold">.</span>add<span style="color:#000;font-weight:bold">.</span>accumulate(arr, axis<span style="color:#000;font-weight:bold">=</span><span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">124</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0</span>,  <span style="color:#099">1</span>,  <span style="color:#099">3</span>,  <span style="color:#099">6</span>, <span style="color:#099">10</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">5</span>, <span style="color:#099">11</span>, <span style="color:#099">18</span>, <span style="color:#099">26</span>, <span style="color:#099">35</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">10</span>, <span style="color:#099">21</span>, <span style="color:#099">33</span>, <span style="color:#099">46</span>, <span style="color:#099">60</span>]])
</span></span></code></pre></div><p>outer用于计算两个数组的叉积：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">125</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">3</span>)<span style="color:#000;font-weight:bold">.</span>repeat([<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">2</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">126</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">126</span>]: array([<span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">2</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">127</span>]: np<span style="color:#000;font-weight:bold">.</span>multiply<span style="color:#000;font-weight:bold">.</span>outer(arr, np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">5</span>))
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">127</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">0</span>, <span style="color:#099">2</span>, <span style="color:#099">4</span>, <span style="color:#099">6</span>, <span style="color:#099">8</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">0</span>, <span style="color:#099">2</span>, <span style="color:#099">4</span>, <span style="color:#099">6</span>, <span style="color:#099">8</span>]])
</span></span></code></pre></div><p>outer输出结果的维度是两个输入数据的维度之和：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">128</span>]: x, y <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">3</span>, <span style="color:#099">4</span>), np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">129</span>]: result <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>subtract<span style="color:#000;font-weight:bold">.</span>outer(x, y)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">130</span>]: result<span style="color:#000;font-weight:bold">.</span>shape
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">130</span>]: (<span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">5</span>)
</span></span></code></pre></div><p>最后一个方法reduceat用于计算“局部约简”，其实就是一个对数据各切片进行聚合的groupby运算。它接受一组用于指示如何对值进行拆分和聚合的“面元边界”：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">131</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">132</span>]: np<span style="color:#000;font-weight:bold">.</span>add<span style="color:#000;font-weight:bold">.</span>reduceat(arr, [<span style="color:#099">0</span>, <span style="color:#099">5</span>, <span style="color:#099">8</span>])
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">132</span>]: array([<span style="color:#099">10</span>, <span style="color:#099">18</span>, <span style="color:#099">17</span>])
</span></span></code></pre></div><p>最终结果是在arr[0:5]、arr[5:8]以及arr[8:]上执行的约简。跟其他方法一样，这里也可以传入一个axis参数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">133</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>multiply<span style="color:#000;font-weight:bold">.</span>outer(np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">4</span>), np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">5</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">134</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">134</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0</span>,  <span style="color:#099">0</span>,  <span style="color:#099">0</span>,  <span style="color:#099">0</span>,  <span style="color:#099">0</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0</span>,  <span style="color:#099">1</span>,  <span style="color:#099">2</span>,  <span style="color:#099">3</span>,  <span style="color:#099">4</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0</span>,  <span style="color:#099">2</span>,  <span style="color:#099">4</span>,  <span style="color:#099">6</span>,  <span style="color:#099">8</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0</span>,  <span style="color:#099">3</span>,  <span style="color:#099">6</span>,  <span style="color:#099">9</span>, <span style="color:#099">12</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">135</span>]: np<span style="color:#000;font-weight:bold">.</span>add<span style="color:#000;font-weight:bold">.</span>reduceat(arr, [<span style="color:#099">0</span>, <span style="color:#099">2</span>, <span style="color:#099">4</span>], axis<span style="color:#000;font-weight:bold">=</span><span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">135</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0</span>,  <span style="color:#099">0</span>,  <span style="color:#099">0</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1</span>,  <span style="color:#099">5</span>,  <span style="color:#099">4</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">2</span>, <span style="color:#099">10</span>,  <span style="color:#099">8</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">3</span>, <span style="color:#099">15</span>, <span style="color:#099">12</span>]])
</span></span></code></pre></div><p>表A-2总结了部分的ufunc方法。</p>
<p><img src="https://gitee.com/wugenqiang/images/raw/master/01/1240-20201014203408335.png" alt="表A ufunc方法"></p>
<h3 id="编写新的ufunc">编写新的ufunc</h3>
<p>有多种方法可以让你编写自己的NumPy ufuncs。最常见的是使用NumPy C API，但它超越了本书的范围。在本节，我们讲纯粹的Python ufunc。</p>
<p>numpy.frompyfunc接受一个Python函数以及两个分别表示输入输出参数数量的参数。例如，下面是一个能够实现元素级加法的简单函数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">136</span>]: <span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">add_elements</span>(x, y):
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">.....</span>:     <span style="color:#000;font-weight:bold">return</span> x <span style="color:#000;font-weight:bold">+</span> y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">137</span>]: add_them <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>frompyfunc(add_elements, <span style="color:#099">2</span>, <span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">138</span>]: add_them(np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">8</span>), np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">8</span>))
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">138</span>]: array([<span style="color:#099">0</span>, <span style="color:#099">2</span>, <span style="color:#099">4</span>, <span style="color:#099">6</span>, <span style="color:#099">8</span>, <span style="color:#099">10</span>, <span style="color:#099">12</span>, <span style="color:#099">14</span>], dtype<span style="color:#000;font-weight:bold">=</span><span style="color:#0086b3">object</span>)
</span></span></code></pre></div><p>用frompyfunc创建的函数总是返回Python对象数组，这一点很不方便。幸运的是，还有另一个办法，即numpy.vectorize。虽然没有frompyfunc那么强大，但可以让你指定输出类型：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">139</span>]: add_them <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>vectorize(add_elements, otypes<span style="color:#000;font-weight:bold">=</span>[np<span style="color:#000;font-weight:bold">.</span>float64])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">140</span>]: add_them(np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">8</span>), np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">8</span>))
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">140</span>]: array([  <span style="color:#099">0.</span>,   <span style="color:#099">2.</span>,   <span style="color:#099">4.</span>,   <span style="color:#099">6.</span>,   <span style="color:#099">8.</span>,  <span style="color:#099">10.</span>,  <span style="color:#099">12.</span>,  <span style="color:#099">14.</span>])
</span></span></code></pre></div><p>虽然这两个函数提供了一种创建ufunc型函数的手段，但它们非常慢，因为它们在计算每个元素时都要执行一次Python函数调用，这就会比NumPy自带的基于C的ufunc慢很多：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">141</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">10000</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">142</span>]: <span style="color:#000;font-weight:bold">%</span>timeit add_them(arr, arr)
</span></span><span style="display:flex;"><span><span style="color:#099">4.12</span> ms <span style="color:#000;font-weight:bold">+-</span> <span style="color:#099">182</span> us per loop (mean <span style="color:#000;font-weight:bold">+-</span> std<span style="color:#000;font-weight:bold">.</span> dev<span style="color:#000;font-weight:bold">.</span> of <span style="color:#099">7</span> runs, <span style="color:#099">100</span> loops each)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">143</span>]: <span style="color:#000;font-weight:bold">%</span>timeit np<span style="color:#000;font-weight:bold">.</span>add(arr, arr)
</span></span><span style="display:flex;"><span><span style="color:#099">6.89</span> us <span style="color:#000;font-weight:bold">+-</span> <span style="color:#099">504</span> ns per loop (mean <span style="color:#000;font-weight:bold">+-</span> std<span style="color:#000;font-weight:bold">.</span> dev<span style="color:#000;font-weight:bold">.</span> of <span style="color:#099">7</span> runs, <span style="color:#099">100000</span> loops each)
</span></span></code></pre></div><p>本章的后面，我会介绍使用Numba（http://numba.pydata.org/），创建快速Python ufuncs。</p>
<h2 id="a5-结构化和记录式数组">A.5 结构化和记录式数组</h2>
<p>你可能已经注意到了，到目前为止我们所讨论的ndarray都是一种同质数据容器，也就是说，在它所表示的内存块中，各元素占用的字节数相同（具体根据dtype而定）。从表面上看，它似乎不能用于表示异质或表格型的数据。结构化数组是一种特殊的ndarray，其中的各个元素可以被看做C语言中的结构体（struct，这就是“结构化”的由来）或SQL表中带有多个命名字段的行：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">144</span>]: dtype <span style="color:#000;font-weight:bold">=</span> [(<span style="color:#d14">&#39;x&#39;</span>, np<span style="color:#000;font-weight:bold">.</span>float64), (<span style="color:#d14">&#39;y&#39;</span>, np<span style="color:#000;font-weight:bold">.</span>int32)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">145</span>]: sarr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>array([(<span style="color:#099">1.5</span>, <span style="color:#099">6</span>), (np<span style="color:#000;font-weight:bold">.</span>pi, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">2</span>)], dtype<span style="color:#000;font-weight:bold">=</span>dtype)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">146</span>]: sarr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">146</span>]: 
</span></span><span style="display:flex;"><span>array([( <span style="color:#099">1.5</span>   ,  <span style="color:#099">6</span>), ( <span style="color:#099">3.1416</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">2</span>)],
</span></span><span style="display:flex;"><span>      dtype<span style="color:#000;font-weight:bold">=</span>[(<span style="color:#d14">&#39;x&#39;</span>, <span style="color:#d14">&#39;&lt;f8&#39;</span>), (<span style="color:#d14">&#39;y&#39;</span>, <span style="color:#d14">&#39;&lt;i4&#39;</span>)])
</span></span></code></pre></div><p>定义结构化dtype（请参考NumPy的在线文档）的方式有很多。最典型的办法是元组列表，各元组的格式为(field_name,field_data_type)。这样，数组的元素就成了元组式的对象，该对象中各个元素可以像字典那样进行访问：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">147</span>]: sarr[<span style="color:#099">0</span>]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">147</span>]: ( <span style="color:#099">1.5</span>, <span style="color:#099">6</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">148</span>]: sarr[<span style="color:#099">0</span>][<span style="color:#d14">&#39;y&#39;</span>]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">148</span>]: <span style="color:#099">6</span>
</span></span></code></pre></div><p>字段名保存在dtype.names属性中。在访问结构化数组的某个字段时，返回的是该数据的视图，所以不会发生数据复制：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">149</span>]: sarr[<span style="color:#d14">&#39;x&#39;</span>]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">149</span>]: array([ <span style="color:#099">1.5</span>   ,  <span style="color:#099">3.1416</span>])
</span></span></code></pre></div><h3 id="嵌套dtype和多维字段">嵌套dtype和多维字段</h3>
<p>在定义结构化dtype时，你可以再设置一个形状（可以是一个整数，也可以是一个元组）：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">150</span>]: dtype <span style="color:#000;font-weight:bold">=</span> [(<span style="color:#d14">&#39;x&#39;</span>, np<span style="color:#000;font-weight:bold">.</span>int64, <span style="color:#099">3</span>), (<span style="color:#d14">&#39;y&#39;</span>, np<span style="color:#000;font-weight:bold">.</span>int32)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">151</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>zeros(<span style="color:#099">4</span>, dtype<span style="color:#000;font-weight:bold">=</span>dtype)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">152</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">152</span>]: 
</span></span><span style="display:flex;"><span>array([([<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>], <span style="color:#099">0</span>), ([<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>], <span style="color:#099">0</span>), ([<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>], <span style="color:#099">0</span>), ([<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>], <span style="color:#099">0</span>)],
</span></span><span style="display:flex;"><span>      dtype<span style="color:#000;font-weight:bold">=</span>[(<span style="color:#d14">&#39;x&#39;</span>, <span style="color:#d14">&#39;&lt;i8&#39;</span>, (<span style="color:#099">3</span>,)), (<span style="color:#d14">&#39;y&#39;</span>, <span style="color:#d14">&#39;&lt;i4&#39;</span>)])
</span></span></code></pre></div><p>在这种情况下，各个记录的x字段所表示的是一个长度为3的数组：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">153</span>]: arr[<span style="color:#099">0</span>][<span style="color:#d14">&#39;x&#39;</span>]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">153</span>]: array([<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>])
</span></span></code></pre></div><p>这样，访问arr[&lsquo;x&rsquo;]即可得到一个二维数组，而不是前面那个例子中的一维数组：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">154</span>]: arr[<span style="color:#d14">&#39;x&#39;</span>]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">154</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>]])
</span></span></code></pre></div><p>这就使你能用单个数组的内存块存放复杂的嵌套结构。你还可以嵌套dtype，作出更复杂的结构。下面是一个简单的例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">155</span>]: dtype <span style="color:#000;font-weight:bold">=</span> [(<span style="color:#d14">&#39;x&#39;</span>, [(<span style="color:#d14">&#39;a&#39;</span>, <span style="color:#d14">&#39;f8&#39;</span>), (<span style="color:#d14">&#39;b&#39;</span>, <span style="color:#d14">&#39;f4&#39;</span>)]), (<span style="color:#d14">&#39;y&#39;</span>, np<span style="color:#000;font-weight:bold">.</span>int32)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">156</span>]: data <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>array([((<span style="color:#099">1</span>, <span style="color:#099">2</span>), <span style="color:#099">5</span>), ((<span style="color:#099">3</span>, <span style="color:#099">4</span>), <span style="color:#099">6</span>)], dtype<span style="color:#000;font-weight:bold">=</span>dtype)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">157</span>]: data[<span style="color:#d14">&#39;x&#39;</span>]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">157</span>]: 
</span></span><span style="display:flex;"><span>array([( <span style="color:#099">1.</span>,  <span style="color:#099">2.</span>), ( <span style="color:#099">3.</span>,  <span style="color:#099">4.</span>)],
</span></span><span style="display:flex;"><span>      dtype<span style="color:#000;font-weight:bold">=</span>[(<span style="color:#d14">&#39;a&#39;</span>, <span style="color:#d14">&#39;&lt;f8&#39;</span>), (<span style="color:#d14">&#39;b&#39;</span>, <span style="color:#d14">&#39;&lt;f4&#39;</span>)])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">158</span>]: data[<span style="color:#d14">&#39;y&#39;</span>]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">158</span>]: array([<span style="color:#099">5</span>, <span style="color:#099">6</span>], dtype<span style="color:#000;font-weight:bold">=</span>int32)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">159</span>]: data[<span style="color:#d14">&#39;x&#39;</span>][<span style="color:#d14">&#39;a&#39;</span>]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">159</span>]: array([ <span style="color:#099">1.</span>,  <span style="color:#099">3.</span>])
</span></span></code></pre></div><p>pandas的DataFrame并不直接支持该功能，但它的分层索引机制跟这个差不多。</p>
<h3 id="为什么要用结构化数组">为什么要用结构化数组</h3>
<p>跟pandas的DataFrame相比，NumPy的结构化数组是一种相对较低级的工具。它可以将单个内存块解释为带有任意复杂嵌套列的表格型结构。由于数组中的每个元素在内存中都被表示为固定的字节数，所以结构化数组能够提供非常快速高效的磁盘数据读写（包括内存映像）、网络传输等功能。</p>
<p>结构化数组的另一个常见用法是，将数据文件写成定长记录字节流，这是C和C++代码中常见的数据序列化手段（业界许多历史系统中都能找得到）。只要知道文件的格式（记录的大小、元素的顺序、字节数以及数据类型等），就可以用np.fromfile将数据读入内存。这种用法超出了本书的范围，知道这点就可以了。</p>
<h2 id="a6-更多有关排序的话题">A.6 更多有关排序的话题</h2>
<p>跟Python内置的列表一样，ndarray的sort实例方法也是就地排序。也就是说，数组内容的重新排列是不会产生新数组的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">160</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">6</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">161</span>]: arr<span style="color:#000;font-weight:bold">.</span>sort()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">162</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">162</span>]: array([<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.082</span> ,  <span style="color:#099">0.3759</span>,  <span style="color:#099">0.8014</span>,  <span style="color:#099">1.1397</span>,  <span style="color:#099">1.2888</span>,  <span style="color:#099">1.8413</span>])
</span></span></code></pre></div><p>在对数组进行就地排序时要注意一点，如果目标数组只是一个视图，则原始数组将会被修改：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">163</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">3</span>, <span style="color:#099">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">164</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">164</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3318</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.4711</span>,  <span style="color:#099">0.8705</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.0847</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.1329</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.0111</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3436</span>,  <span style="color:#099">2.1714</span>,  <span style="color:#099">0.1234</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.0189</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.1773</span>,  <span style="color:#099">0.7424</span>,  <span style="color:#099">0.8548</span>,  <span style="color:#099">1.038</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.329</span> ]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">165</span>]: arr[:, <span style="color:#099">0</span>]<span style="color:#000;font-weight:bold">.</span>sort()  <span style="color:#998;font-style:italic">## Sort first column values in-place</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">166</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">166</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.0111</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.4711</span>,  <span style="color:#099">0.8705</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.0847</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.1329</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3318</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3436</span>,  <span style="color:#099">2.1714</span>,  <span style="color:#099">0.1234</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.0189</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.1773</span>,  <span style="color:#099">0.7424</span>,  <span style="color:#099">0.8548</span>,  <span style="color:#099">1.038</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.329</span> ]])
</span></span></code></pre></div><p>相反，numpy.sort会为原数组创建一个已排序副本。另外，它所接受的参数（比如kind）跟ndarray.sort一样：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">167</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">168</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">168</span>]: array([<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.1181</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2415</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0051</span>,  <span style="color:#099">0.7379</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.0614</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">169</span>]: np<span style="color:#000;font-weight:bold">.</span>sort(arr)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">169</span>]: array([<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0051</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.1181</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.0614</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2415</span>,  <span style="color:#099">0.7379</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">170</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">170</span>]: array([<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.1181</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2415</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0051</span>,  <span style="color:#099">0.7379</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.0614</span>])
</span></span></code></pre></div><p>这两个排序方法都可以接受一个axis参数，以便沿指定轴向对各块数据进行单独排序：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">171</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">3</span>, <span style="color:#099">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">172</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">172</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0.5955</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2682</span>,  <span style="color:#099">1.3389</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1872</span>,  <span style="color:#099">0.9111</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3215</span>,  <span style="color:#099">1.0054</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5168</span>,  <span style="color:#099">1.1925</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1989</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.3969</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.7638</span>,  <span style="color:#099">0.6071</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2222</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2171</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">173</span>]: arr<span style="color:#000;font-weight:bold">.</span>sort(axis<span style="color:#000;font-weight:bold">=</span><span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">174</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">174</span>]: 
</span></span><span style="display:flex;"><span>array([[<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2682</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1872</span>,  <span style="color:#099">0.5955</span>,  <span style="color:#099">0.9111</span>,  <span style="color:#099">1.3389</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5168</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3215</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1989</span>,  <span style="color:#099">1.0054</span>,  <span style="color:#099">1.1925</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.7638</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2222</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2171</span>,  <span style="color:#099">0.3969</span>,  <span style="color:#099">0.6071</span>]])
</span></span></code></pre></div><p>你可能注意到了，这两个排序方法都不可以被设置为降序。其实这也无所谓，因为数组切片会产生视图（也就是说，不会产生副本，也不需要任何其他的计算工作）。许多Python用户都很熟悉一个有关列表的小技巧：values[::-1]可以返回一个反序的列表。对ndarray也是如此：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">175</span>]: arr[:, ::<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1</span>]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">175</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">1.3389</span>,  <span style="color:#099">0.9111</span>,  <span style="color:#099">0.5955</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1872</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2682</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">1.1925</span>,  <span style="color:#099">1.0054</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1989</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3215</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5168</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.6071</span>,  <span style="color:#099">0.3969</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2171</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2222</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.7638</span>]])
</span></span></code></pre></div><h3 id="间接排序argsort和lexsort">间接排序：argsort和lexsort</h3>
<p>在数据分析工作中，常常需要根据一个或多个键对数据集进行排序。例如，一个有关学生信息的数据表可能需要以姓和名进行排序（先姓后名）。这就是间接排序的一个例子，如果你阅读过有关pandas的章节，那就已经见过不少高级例子了。给定一个或多个键，你就可以得到一个由整数组成的索引数组（我亲切地称之为索引器），其中的索引值说明了数据在新顺序下的位置。argsort和numpy.lexsort就是实现该功能的两个主要方法。下面是一个简单的例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">176</span>]: values <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>array([<span style="color:#099">5</span>, <span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">3</span>, <span style="color:#099">2</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">177</span>]: indexer <span style="color:#000;font-weight:bold">=</span> values<span style="color:#000;font-weight:bold">.</span>argsort()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">178</span>]: indexer
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">178</span>]: array([<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">4</span>, <span style="color:#099">3</span>, <span style="color:#099">0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">179</span>]: values[indexer]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">179</span>]: array([<span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>])
</span></span></code></pre></div><p>一个更复杂的例子，下面这段代码根据数组的第一行对其进行排序：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">180</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">3</span>, <span style="color:#099">5</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">181</span>]: arr[<span style="color:#099">0</span>] <span style="color:#000;font-weight:bold">=</span> values
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">182</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">182</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">5.</span>    ,  <span style="color:#099">0.</span>    ,  <span style="color:#099">1.</span>    ,  <span style="color:#099">3.</span>    ,  <span style="color:#099">2.</span>    ],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3636</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1378</span>,  <span style="color:#099">2.1777</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4728</span>,  <span style="color:#099">0.8356</span>],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2089</span>,  <span style="color:#099">0.2316</span>,  <span style="color:#099">0.728</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.3918</span>,  <span style="color:#099">1.9956</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">183</span>]: arr[:, arr[<span style="color:#099">0</span>]<span style="color:#000;font-weight:bold">.</span>argsort()]
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">183</span>]: 
</span></span><span style="display:flex;"><span>array([[ <span style="color:#099">0.</span>    ,  <span style="color:#099">1.</span>    ,  <span style="color:#099">2.</span>    ,  <span style="color:#099">3.</span>    ,  <span style="color:#099">5.</span>    ],
</span></span><span style="display:flex;"><span>       [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1378</span>,  <span style="color:#099">2.1777</span>,  <span style="color:#099">0.8356</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4728</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3636</span>],
</span></span><span style="display:flex;"><span>       [ <span style="color:#099">0.2316</span>,  <span style="color:#099">0.728</span> ,  <span style="color:#099">1.9956</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.3918</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2089</span>]])
</span></span></code></pre></div><p>lexsort跟argsort差不多，只不过它可以一次性对多个键数组执行间接排序（字典序）。假设我们想对一些以姓和名标识的数据进行排序：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">184</span>]: first_name <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>array([<span style="color:#d14">&#39;Bob&#39;</span>, <span style="color:#d14">&#39;Jane&#39;</span>, <span style="color:#d14">&#39;Steve&#39;</span>, <span style="color:#d14">&#39;Bill&#39;</span>, <span style="color:#d14">&#39;Barbara&#39;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">185</span>]: last_name <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>array([<span style="color:#d14">&#39;Jones&#39;</span>, <span style="color:#d14">&#39;Arnold&#39;</span>, <span style="color:#d14">&#39;Arnold&#39;</span>, <span style="color:#d14">&#39;Jones&#39;</span>, <span style="color:#d14">&#39;Walters&#39;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">186</span>]: sorter <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>lexsort((first_name, last_name))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">187</span>]: sorter
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">187</span>]: array([<span style="color:#099">1</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">0</span>, <span style="color:#099">4</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">188</span>]: <span style="color:#0086b3">zip</span>(last_name[sorter], first_name[sorter])
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">188</span>]: <span style="color:#000;font-weight:bold">&lt;</span><span style="color:#0086b3">zip</span> at <span style="color:#099">0x7fa203eda1c8</span><span style="color:#000;font-weight:bold">&gt;</span>
</span></span></code></pre></div><p>刚开始使用lexsort的时候可能会比较容易头晕，这是因为键的应用顺序是从最后一个传入的算起的。不难看出，last_name是先于first_name被应用的。</p>
<blockquote>
<p>笔记：Series和DataFrame的sort_index以及Series的order方法就是通过这些函数的变体（它们还必须考虑缺失值）实现的。</p>
</blockquote>
<h3 id="其他排序算法">其他排序算法</h3>
<p>稳定的（stable）排序算法会保持等价元素的相对位置。对于相对位置具有实际意义的那些间接排序而言，这一点非常重要：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">189</span>]: values <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>array([<span style="color:#d14">&#39;2:first&#39;</span>, <span style="color:#d14">&#39;2:second&#39;</span>, <span style="color:#d14">&#39;1:first&#39;</span>, <span style="color:#d14">&#39;1:second&#39;</span>,
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">.....</span>:                    <span style="color:#d14">&#39;1:third&#39;</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">190</span>]: key <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>array([<span style="color:#099">2</span>, <span style="color:#099">2</span>, <span style="color:#099">1</span>, <span style="color:#099">1</span>, <span style="color:#099">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">191</span>]: indexer <span style="color:#000;font-weight:bold">=</span> key<span style="color:#000;font-weight:bold">.</span>argsort(kind<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#39;mergesort&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">192</span>]: indexer
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">192</span>]: array([<span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">0</span>, <span style="color:#099">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">193</span>]: values<span style="color:#000;font-weight:bold">.</span>take(indexer)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">193</span>]: 
</span></span><span style="display:flex;"><span>array([<span style="color:#d14">&#39;1:first&#39;</span>, <span style="color:#d14">&#39;1:second&#39;</span>, <span style="color:#d14">&#39;1:third&#39;</span>, <span style="color:#d14">&#39;2:first&#39;</span>, <span style="color:#d14">&#39;2:second&#39;</span>],
</span></span><span style="display:flex;"><span>      dtype<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#39;&lt;U8&#39;</span>)
</span></span></code></pre></div><p>mergesort（合并排序）是唯一的稳定排序，它保证有O(n log n)的性能（空间复杂度），但是其平均性能比默认的quicksort（快速排序）要差。表A-3列出了可用的排序算法及其相关的性能指标。大部分用户完全不需要知道这些东西，但了解一下总是好的。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/7178691-970f54f58b6b3356.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="表A-3 数组排序算法"></p>
<h3 id="部分排序数组">部分排序数组</h3>
<p>排序的目的之一可能是确定数组中最大或最小的元素。NumPy有两个优化方法，numpy.partition和np.argpartition，可以在第k个最小元素划分的数组：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">194</span>]: np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>seed(<span style="color:#099">12345</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">195</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">20</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">196</span>]: arr
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">196</span>]: 
</span></span><span style="display:flex;"><span>array([<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2047</span>,  <span style="color:#099">0.4789</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5194</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5557</span>,  <span style="color:#099">1.9658</span>,  <span style="color:#099">1.3934</span>,  <span style="color:#099">0.0929</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#099">0.2817</span>,  <span style="color:#099">0.769</span> ,  <span style="color:#099">1.2464</span>,  <span style="color:#099">1.0072</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.2962</span>,  <span style="color:#099">0.275</span> ,  <span style="color:#099">0.2289</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#099">1.3529</span>,  <span style="color:#099">0.8864</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>,  <span style="color:#099">1.669</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">197</span>]: np<span style="color:#000;font-weight:bold">.</span>partition(arr, <span style="color:#099">3</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">197</span>]: 
</span></span><span style="display:flex;"><span>array([<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.2962</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5557</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5194</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2047</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#099">0.2817</span>,  <span style="color:#099">0.769</span> ,  <span style="color:#099">0.4789</span>,  <span style="color:#099">1.0072</span>,  <span style="color:#099">0.0929</span>,  <span style="color:#099">0.275</span> ,  <span style="color:#099">0.2289</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#099">1.3529</span>,  <span style="color:#099">0.8864</span>,  <span style="color:#099">1.3934</span>,  <span style="color:#099">1.9658</span>,  <span style="color:#099">1.669</span> ,  <span style="color:#099">1.2464</span>])
</span></span></code></pre></div><p>当你调用partition(arr, 3)，结果中的头三个元素是最小的三个，没有特定的顺序。numpy.argpartition与numpy.argsort相似，会返回索引，重排数据为等价的顺序：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">198</span>]: indices <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>argpartition(arr, <span style="color:#099">3</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">199</span>]: indices
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">199</span>]: 
</span></span><span style="display:flex;"><span>array([<span style="color:#099">16</span>, <span style="color:#099">11</span>,  <span style="color:#099">3</span>,  <span style="color:#099">2</span>, <span style="color:#099">17</span>, <span style="color:#099">19</span>,  <span style="color:#099">0</span>,  <span style="color:#099">7</span>,  <span style="color:#099">8</span>,  <span style="color:#099">1</span>, <span style="color:#099">10</span>,  <span style="color:#099">6</span>, <span style="color:#099">12</span>, <span style="color:#099">13</span>, <span style="color:#099">14</span>, <span style="color:#099">15</span>,  <span style="color:#099">5</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#099">4</span>, <span style="color:#099">18</span>,  <span style="color:#099">9</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">200</span>]: arr<span style="color:#000;font-weight:bold">.</span>take(indices)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">200</span>]: 
</span></span><span style="display:flex;"><span>array([<span style="color:#000;font-weight:bold">-</span><span style="color:#099">2.0016</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.2962</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5557</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.5194</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3718</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.4386</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.2047</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#099">0.2817</span>,  <span style="color:#099">0.769</span> ,  <span style="color:#099">0.4789</span>,  <span style="color:#099">1.0072</span>,  <span style="color:#099">0.0929</span>,  <span style="color:#099">0.275</span> ,  <span style="color:#099">0.2289</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#099">1.3529</span>,  <span style="color:#099">0.8864</span>,  <span style="color:#099">1.3934</span>,  <span style="color:#099">1.9658</span>,  <span style="color:#099">1.669</span> ,  <span style="color:#099">1.2464</span>])
</span></span></code></pre></div><h3 id="numpysearchsorted在有序数组中查找元素">numpy.searchsorted：在有序数组中查找元素</h3>
<p>searchsorted是一个在有序数组上执行二分查找的数组方法，只要将值插入到它返回的那个位置就能维持数组的有序性：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">201</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>array([<span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">7</span>, <span style="color:#099">12</span>, <span style="color:#099">15</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">202</span>]: arr<span style="color:#000;font-weight:bold">.</span>searchsorted(<span style="color:#099">9</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">202</span>]: <span style="color:#099">3</span>
</span></span></code></pre></div><p>你可以传入一组值就能得到一组索引：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">203</span>]: arr<span style="color:#000;font-weight:bold">.</span>searchsorted([<span style="color:#099">0</span>, <span style="color:#099">8</span>, <span style="color:#099">11</span>, <span style="color:#099">16</span>])
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">203</span>]: array([<span style="color:#099">0</span>, <span style="color:#099">3</span>, <span style="color:#099">3</span>, <span style="color:#099">5</span>])
</span></span></code></pre></div><p>从上面的结果中可以看出，对于元素0，searchsorted会返回0。这是因为其默认行为是返回相等值组的左侧索引：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">204</span>]: arr <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>array([<span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">0</span>, <span style="color:#099">1</span>, <span style="color:#099">1</span>, <span style="color:#099">1</span>, <span style="color:#099">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">205</span>]: arr<span style="color:#000;font-weight:bold">.</span>searchsorted([<span style="color:#099">0</span>, <span style="color:#099">1</span>])
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">205</span>]: array([<span style="color:#099">0</span>, <span style="color:#099">3</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">206</span>]: arr<span style="color:#000;font-weight:bold">.</span>searchsorted([<span style="color:#099">0</span>, <span style="color:#099">1</span>], side<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#39;right&#39;</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">206</span>]: array([<span style="color:#099">3</span>, <span style="color:#099">7</span>])
</span></span></code></pre></div><p>再来看searchsorted的另一个用法，假设我们有一个数据数组（其中的值在0到10000之间），还有一个表示“面元边界”的数组，我们希望用它将数据数组拆分开：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">207</span>]: data <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>floor(np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>uniform(<span style="color:#099">0</span>, <span style="color:#099">10000</span>, size<span style="color:#000;font-weight:bold">=</span><span style="color:#099">50</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">208</span>]: bins <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>array([<span style="color:#099">0</span>, <span style="color:#099">100</span>, <span style="color:#099">1000</span>, <span style="color:#099">5000</span>, <span style="color:#099">10000</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">209</span>]: data
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">209</span>]: 
</span></span><span style="display:flex;"><span>array([ <span style="color:#099">9940.</span>,  <span style="color:#099">6768.</span>,  <span style="color:#099">7908.</span>,  <span style="color:#099">1709.</span>,   <span style="color:#099">268.</span>,  <span style="color:#099">8003.</span>, <span style="color:#099">9037.</span>,   <span style="color:#099">246.</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#099">4917.</span>,  <span style="color:#099">5262.</span>,  <span style="color:#099">5963.</span>,   <span style="color:#099">519.</span>,  <span style="color:#099">8950.</span>,  <span style="color:#099">7282.</span>,  <span style="color:#099">8183.</span>,  <span style="color:#099">5002.</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#099">8101.</span>,   <span style="color:#099">959.</span>,  <span style="color:#099">2189.</span>,  <span style="color:#099">2587.</span>,  <span style="color:#099">4681.</span>,  <span style="color:#099">4593.</span>,  <span style="color:#099">7095.</span>,  <span style="color:#099">1780.</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#099">5314.</span>,  <span style="color:#099">1677.</span>,  <span style="color:#099">7688.</span>,  <span style="color:#099">9281.</span>,  <span style="color:#099">6094.</span>,  <span style="color:#099">1501.</span>,  <span style="color:#099">4896.</span>,  <span style="color:#099">3773.</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#099">8486.</span>,  <span style="color:#099">9110.</span>,  <span style="color:#099">3838.</span>,  <span style="color:#099">3154.</span>,  <span style="color:#099">5683.</span>,  <span style="color:#099">1878.</span>,  <span style="color:#099">1258.</span>,  <span style="color:#099">6875.</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#099">7996.</span>,  <span style="color:#099">5735.</span>,  <span style="color:#099">9732.</span>,  <span style="color:#099">6340.</span>,  <span style="color:#099">8884.</span>,  <span style="color:#099">4954.</span>,  <span style="color:#099">3516.</span>,  <span style="color:#099">7142.</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#099">5039.</span>,  <span style="color:#099">2256.</span>])
</span></span></code></pre></div><p>然后，为了得到各数据点所属区间的编号（其中1表示面元[0,100)），我们可以直接使用searchsorted：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">210</span>]: labels <span style="color:#000;font-weight:bold">=</span> bins<span style="color:#000;font-weight:bold">.</span>searchsorted(data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">211</span>]: labels
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">211</span>]: 
</span></span><span style="display:flex;"><span>array([<span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">3</span>, <span style="color:#099">2</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">2</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">2</span>, <span style="color:#099">3</span>, <span style="color:#099">3</span>, <span style="color:#099">3</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>,
</span></span><span style="display:flex;"><span>       <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">3</span>, <span style="color:#099">3</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">3</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">3</span>, <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">3</span>,
</span></span><span style="display:flex;"><span>       <span style="color:#099">3</span>, <span style="color:#099">4</span>, <span style="color:#099">4</span>, <span style="color:#099">3</span>])
</span></span></code></pre></div><p>通过pandas的groupby使用该结果即可非常轻松地对原数据集进行拆分：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">212</span>]: pd<span style="color:#000;font-weight:bold">.</span>Series(data)<span style="color:#000;font-weight:bold">.</span>groupby(labels)<span style="color:#000;font-weight:bold">.</span>mean()
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">212</span>]: 
</span></span><span style="display:flex;"><span><span style="color:#099">2</span>     <span style="color:#099">498.000000</span>
</span></span><span style="display:flex;"><span><span style="color:#099">3</span>    <span style="color:#099">3064.277778</span>
</span></span><span style="display:flex;"><span><span style="color:#099">4</span>    <span style="color:#099">7389.035714</span>
</span></span><span style="display:flex;"><span>dtype: float64
</span></span></code></pre></div><p>##A.7 用Numba编写快速NumPy函数</p>
<p>Numba是一个开源项目，它可以利用CPUs、GPUs或其它硬件为类似NumPy的数据创建快速函数。它使用了LLVM项目（http://llvm.org/），将Python代码转换为机器代码。</p>
<p>为了介绍Numba，来考虑一个纯粹的Python函数，它使用for循环计算表达式(x - y).mean()：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">import</span> <span style="color:#555">numpy</span> <span style="color:#000;font-weight:bold">as</span> <span style="color:#555">np</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">mean_distance</span>(x, y):
</span></span><span style="display:flex;"><span>    nx <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">len</span>(x)
</span></span><span style="display:flex;"><span>    result <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0.0</span>
</span></span><span style="display:flex;"><span>    count <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(nx):
</span></span><span style="display:flex;"><span>        result <span style="color:#000;font-weight:bold">+=</span> x[i] <span style="color:#000;font-weight:bold">-</span> y[i]
</span></span><span style="display:flex;"><span>        count <span style="color:#000;font-weight:bold">+=</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> result <span style="color:#000;font-weight:bold">/</span> count
</span></span></code></pre></div><p>这个函数很慢：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">209</span>]: x <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">10000000</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">210</span>]: y <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">10000000</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">211</span>]: <span style="color:#000;font-weight:bold">%</span>timeit mean_distance(x, y)
</span></span><span style="display:flex;"><span><span style="color:#099">1</span> loop, best of <span style="color:#099">3</span>: <span style="color:#099">2</span> s per loop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">212</span>]: <span style="color:#000;font-weight:bold">%</span>timeit (x <span style="color:#000;font-weight:bold">-</span> y)<span style="color:#000;font-weight:bold">.</span>mean()
</span></span><span style="display:flex;"><span><span style="color:#099">100</span> loops, best of <span style="color:#099">3</span>: <span style="color:#099">14.7</span> ms per loop
</span></span></code></pre></div><p>NumPy的版本要比它快过100倍。我们可以转换这个函数为编译的Numba函数，使用numba.jit函数：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">213</span>]: <span style="color:#000;font-weight:bold">import</span> <span style="color:#555">numba</span> <span style="color:#000;font-weight:bold">as</span> <span style="color:#555">nb</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">214</span>]: numba_mean_distance <span style="color:#000;font-weight:bold">=</span> nb<span style="color:#000;font-weight:bold">.</span>jit(mean_distance)
</span></span></code></pre></div><p>也可以写成装饰器：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#3c5d5d;font-weight:bold">@nb.jit</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">mean_distance</span>(x, y):
</span></span><span style="display:flex;"><span>    nx <span style="color:#000;font-weight:bold">=</span> <span style="color:#0086b3">len</span>(x)
</span></span><span style="display:flex;"><span>    result <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0.0</span>
</span></span><span style="display:flex;"><span>    count <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">for</span> i <span style="color:#000;font-weight:bold">in</span> <span style="color:#0086b3">range</span>(nx):
</span></span><span style="display:flex;"><span>        result <span style="color:#000;font-weight:bold">+=</span> x[i] <span style="color:#000;font-weight:bold">-</span> y[i]
</span></span><span style="display:flex;"><span>        count <span style="color:#000;font-weight:bold">+=</span> <span style="color:#099">1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> result <span style="color:#000;font-weight:bold">/</span> count
</span></span></code></pre></div><p>它要比矢量化的NumPy快：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">215</span>]: <span style="color:#000;font-weight:bold">%</span>timeit numba_mean_distance(x, y)
</span></span><span style="display:flex;"><span><span style="color:#099">100</span> loops, best of <span style="color:#099">3</span>: <span style="color:#099">10.3</span> ms per loop
</span></span></code></pre></div><p>Numba不能编译Python代码，但它支持纯Python写的一个部分，可以编写数值算法。</p>
<p>Numba是一个深厚的库，支持多种硬件、编译模式和用户插件。它还可以编译NumPy Python API的一部分，而不用for循环。Numba也可以识别可以便以为机器编码的结构体，但是若调用CPython API，它就不知道如何编译。Numba的jit函数有一个选项，nopython=True，它限制了可以被转换为Python代码的代码，这些代码可以编译为LLVM，但没有任何Python C API调用。jit(nopython=True)有一个简短的别名numba.njit。</p>
<p>前面的例子，我们还可以这样写：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">from</span> <span style="color:#555">numba</span> <span style="color:#000;font-weight:bold">import</span> float64, njit
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#3c5d5d;font-weight:bold">@njit</span>(float64(float64[:], float64[:]))
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">mean_distance</span>(x, y):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> (x <span style="color:#000;font-weight:bold">-</span> y)<span style="color:#000;font-weight:bold">.</span>mean()
</span></span></code></pre></div><p>我建议你学习Numba的线上文档（http://numba.pydata.org/）。下一节介绍一个创建自定义Numpy ufunc对象的例子。</p>
<h3 id="用numba创建自定义numpyufunc对象">用Numba创建自定义numpy.ufunc对象</h3>
<p>numba.vectorize创建了一个编译的NumPy ufunc，它与内置的ufunc很像。考虑一个numpy.add的Python例子：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">from</span> <span style="color:#555">numba</span> <span style="color:#000;font-weight:bold">import</span> vectorize
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#3c5d5d;font-weight:bold">@vectorize</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">def</span> <span style="color:#900;font-weight:bold">nb_add</span>(x, y):
</span></span><span style="display:flex;"><span>    <span style="color:#000;font-weight:bold">return</span> x <span style="color:#000;font-weight:bold">+</span> y
</span></span></code></pre></div><p>现在有：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">13</span>]: x <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>arange(<span style="color:#099">10</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">14</span>]: nb_add(x, x)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">14</span>]: array([  <span style="color:#099">0.</span>,   <span style="color:#099">2.</span>,   <span style="color:#099">4.</span>,   <span style="color:#099">6.</span>,   <span style="color:#099">8.</span>,  <span style="color:#099">10.</span>,  <span style="color:#099">12.</span>,  <span style="color:#099">14.</span>,  <span style="color:#099">16.</span>,  <span style="color:#099">18.</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">15</span>]: nb_add<span style="color:#000;font-weight:bold">.</span>accumulate(x, <span style="color:#099">0</span>)
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">15</span>]: array([  <span style="color:#099">0.</span>,   <span style="color:#099">1.</span>,   <span style="color:#099">3.</span>,   <span style="color:#099">6.</span>,  <span style="color:#099">10.</span>,  <span style="color:#099">15.</span>,  <span style="color:#099">21.</span>,  <span style="color:#099">28.</span>,  <span style="color:#099">36.</span>,  <span style="color:#099">45.</span>])
</span></span></code></pre></div><h2 id="a8-高级数组输入输出">A.8 高级数组输入输出</h2>
<p>我在第4章中讲过，np.save和np.load可用于读写磁盘上以二进制格式存储的数组。其实还有一些工具可用于更为复杂的场景。尤其是内存映像（memory map），它使你能处理在内存中放不下的数据集。</p>
<h3 id="内存映像文件">内存映像文件</h3>
<p>内存映像文件是一种将磁盘上的非常大的二进制数据文件当做内存中的数组进行处理的方式。NumPy实现了一个类似于ndarray的memmap对象，它允许将大文件分成小段进行读写，而不是一次性将整个数组读入内存。另外，memmap也拥有跟普通数组一样的方法，因此，基本上只要是能用于ndarray的算法就也能用于memmap。</p>
<p>要创建一个内存映像，可以使用函数np.memmap并传入一个文件路径、数据类型、形状以及文件模式：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">214</span>]: mmap <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>memmap(<span style="color:#d14">&#39;mymmap&#39;</span>, dtype<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#39;float64&#39;</span>, mode<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#39;w+&#39;</span>,
</span></span><span style="display:flex;"><span>   <span style="color:#000;font-weight:bold">.....</span>:                  shape<span style="color:#000;font-weight:bold">=</span>(<span style="color:#099">10000</span>, <span style="color:#099">10000</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">215</span>]: mmap
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">215</span>]: 
</span></span><span style="display:flex;"><span>memmap([[ <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>, <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>],
</span></span><span style="display:flex;"><span>        [ <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>, <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>],
</span></span><span style="display:flex;"><span>        [ <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>, <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>],
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">...</span>, 
</span></span><span style="display:flex;"><span>        [ <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>, <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>],
</span></span><span style="display:flex;"><span>        [ <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>, <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>],
</span></span><span style="display:flex;"><span>        [ <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>, <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>,  <span style="color:#099">0.</span>]])
</span></span></code></pre></div><p>对memmap切片将会返回磁盘上的数据的视图：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">216</span>]: section <span style="color:#000;font-weight:bold">=</span> mmap[:<span style="color:#099">5</span>]
</span></span></code></pre></div><p>如果将数据赋值给这些视图：数据会先被缓存在内存中（就像是Python的文件对象），调用flush即可将其写入磁盘：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">217</span>]: section[:] <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>random<span style="color:#000;font-weight:bold">.</span>randn(<span style="color:#099">5</span>, <span style="color:#099">10000</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">218</span>]: mmap<span style="color:#000;font-weight:bold">.</span>flush()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">219</span>]: mmap
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">219</span>]: 
</span></span><span style="display:flex;"><span>memmap([[ <span style="color:#099">0.7584</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.6605</span>,  <span style="color:#099">0.8626</span>, <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.6046</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.6212</span>,  <span style="color:#099">2.0542</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.2113</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.0375</span>,  <span style="color:#099">0.7093</span>, <span style="color:#000;font-weight:bold">...</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.4117</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1719</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.8957</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1419</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3375</span>,  <span style="color:#099">0.4329</span>, <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">1.2914</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.752</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.44</span>  ],
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">...</span>, 
</span></span><span style="display:flex;"><span>        [ <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    , <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ],
</span></span><span style="display:flex;"><span>        [ <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    , <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ],
</span></span><span style="display:flex;"><span>        [ <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    , <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">220</span>]: <span style="color:#000;font-weight:bold">del</span> mmap
</span></span></code></pre></div><p>只要某个内存映像超出了作用域，它就会被垃圾回收器回收，之前对其所做的任何修改都会被写入磁盘。当打开一个已经存在的内存映像时，仍然需要指明数据类型和形状，因为磁盘上的那个文件只是一块二进制数据而已，没有任何元数据：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">221</span>]: mmap <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>memmap(<span style="color:#d14">&#39;mymmap&#39;</span>, dtype<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#39;float64&#39;</span>, shape<span style="color:#000;font-weight:bold">=</span>(<span style="color:#099">10000</span>, <span style="color:#099">10000</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">222</span>]: mmap
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">222</span>]: 
</span></span><span style="display:flex;"><span>memmap([[ <span style="color:#099">0.7584</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.6605</span>,  <span style="color:#099">0.8626</span>, <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.6046</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.6212</span>,  <span style="color:#099">2.0542</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.2113</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.0375</span>,  <span style="color:#099">0.7093</span>, <span style="color:#000;font-weight:bold">...</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">1.4117</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1719</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.8957</span>],
</span></span><span style="display:flex;"><span>        [<span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.1419</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.3375</span>,  <span style="color:#099">0.4329</span>, <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">1.2914</span>, <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.752</span> , <span style="color:#000;font-weight:bold">-</span><span style="color:#099">0.44</span>  ],
</span></span><span style="display:flex;"><span>        <span style="color:#000;font-weight:bold">...</span>, 
</span></span><span style="display:flex;"><span>        [ <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    , <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ],
</span></span><span style="display:flex;"><span>        [ <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    , <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ],
</span></span><span style="display:flex;"><span>        [ <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    , <span style="color:#000;font-weight:bold">...</span>,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ,  <span style="color:#099">0.</span>    ]])
</span></span></code></pre></div><p>内存映像可以使用前面介绍的结构化或嵌套dtype。</p>
<h3 id="hdf5及其他数组存储方式">HDF5及其他数组存储方式</h3>
<p>PyTables和h5py这两个Python项目可以将NumPy的数组数据存储为高效且可压缩的HDF5格式（HDF意思是“层次化数据格式”）。你可以安全地将好几百GB甚至TB的数据存储为HDF5格式。要学习Python使用HDF5，请参考pandas线上文档。</p>
<h2 id="a9-性能建议">A.9 性能建议</h2>
<p>使用NumPy的代码的性能一般都很不错，因为数组运算一般都比纯Python循环快得多。下面大致列出了一些需要注意的事项：</p>
<ul>
<li>将Python循环和条件逻辑转换为数组运算和布尔数组运算。</li>
<li>尽量使用广播。</li>
<li>避免复制数据，尽量使用数组视图（即切片）。</li>
<li>利用ufunc及其各种方法。</li>
</ul>
<p>如果单用NumPy无论如何都达不到所需的性能指标，就可以考虑一下用C、Fortran或Cython（等下会稍微介绍一下）来编写代码。我自己在工作中经常会用到Cython（http://cython.org），因为它不用花费我太多精力就能得到C语言那样的性能。</p>
<h3 id="连续内存的重要性">连续内存的重要性</h3>
<p>虽然这个话题有点超出本书的范围，但还是要提一下，因为在某些应用场景中，数组的内存布局可以对计算速度造成极大的影响。这是因为性能差别在一定程度上跟CPU的高速缓存（cache）体系有关。运算过程中访问连续内存块（例如，对以C顺序存储的数组的行求和）一般是最快的，因为内存子系统会将适当的内存块缓存到超高速的L1或L2CPU Cache中。此外，NumPy的C语言基础代码（某些）对连续存储的情况进行了优化处理，这样就能避免一些跨越式的内存访问。</p>
<p>一个数组的内存布局是连续的，就是说元素是以它们在数组中出现的顺序（即Fortran型（列优先）或C型（行优先））存储在内存中的。默认情况下，NumPy数组是以C型连续的方式创建的。列优先的数组（比如C型连续数组的转置）也被称为Fortran型连续。通过ndarray的flags属性即可查看这些信息：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">225</span>]: arr_c <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>ones((<span style="color:#099">1000</span>, <span style="color:#099">1000</span>), order<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#39;C&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">226</span>]: arr_f <span style="color:#000;font-weight:bold">=</span> np<span style="color:#000;font-weight:bold">.</span>ones((<span style="color:#099">1000</span>, <span style="color:#099">1000</span>), order<span style="color:#000;font-weight:bold">=</span><span style="color:#d14">&#39;F&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">227</span>]: arr_c<span style="color:#000;font-weight:bold">.</span>flags
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">227</span>]: 
</span></span><span style="display:flex;"><span>  C_CONTIGUOUS : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  F_CONTIGUOUS : <span style="color:#000;font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>  OWNDATA : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  WRITEABLE : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  ALIGNED : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  UPDATEIFCOPY : <span style="color:#000;font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">228</span>]: arr_f<span style="color:#000;font-weight:bold">.</span>flags
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">228</span>]: 
</span></span><span style="display:flex;"><span>  C_CONTIGUOUS : <span style="color:#000;font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>  F_CONTIGUOUS : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  OWNDATA : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  WRITEABLE : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  ALIGNED : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  UPDATEIFCOPY : <span style="color:#000;font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">229</span>]: arr_f<span style="color:#000;font-weight:bold">.</span>flags<span style="color:#000;font-weight:bold">.</span>f_contiguous
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">229</span>]: <span style="color:#000;font-weight:bold">True</span>
</span></span></code></pre></div><p>在这个例子中，对两个数组的行进行求和计算，理论上说，arr_c会比arr_f快，因为arr_c的行在内存中是连续的。我们可以在IPython中用%timeit来确认一下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">230</span>]: <span style="color:#000;font-weight:bold">%</span>timeit arr_c<span style="color:#000;font-weight:bold">.</span>sum(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#099">784</span> us <span style="color:#000;font-weight:bold">+-</span> <span style="color:#099">10.4</span> us per loop (mean <span style="color:#000;font-weight:bold">+-</span> std<span style="color:#000;font-weight:bold">.</span> dev<span style="color:#000;font-weight:bold">.</span> of <span style="color:#099">7</span> runs, <span style="color:#099">1000</span> loops each)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">231</span>]: <span style="color:#000;font-weight:bold">%</span>timeit arr_f<span style="color:#000;font-weight:bold">.</span>sum(<span style="color:#099">1</span>)
</span></span><span style="display:flex;"><span><span style="color:#099">934</span> us <span style="color:#000;font-weight:bold">+-</span> <span style="color:#099">29</span> us per loop (mean <span style="color:#000;font-weight:bold">+-</span> std<span style="color:#000;font-weight:bold">.</span> dev<span style="color:#000;font-weight:bold">.</span> of <span style="color:#099">7</span> runs, <span style="color:#099">1000</span> loops each)
</span></span></code></pre></div><p>如果想从NumPy中提升性能，这里就应该是下手的地方。如果数组的内存顺序不符合你的要求，使用copy并传入&rsquo;C&rsquo;或&rsquo;F&rsquo;即可解决该问题：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">232</span>]: arr_f<span style="color:#000;font-weight:bold">.</span>copy(<span style="color:#d14">&#39;C&#39;</span>)<span style="color:#000;font-weight:bold">.</span>flags
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">232</span>]: 
</span></span><span style="display:flex;"><span>  C_CONTIGUOUS : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  F_CONTIGUOUS : <span style="color:#000;font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>  OWNDATA : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  WRITEABLE : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  ALIGNED : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  UPDATEIFCOPY : <span style="color:#000;font-weight:bold">False</span>
</span></span></code></pre></div><p>注意，在构造数组的视图时，其结果不一定是连续的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>In [<span style="color:#099">233</span>]: arr_c[:<span style="color:#099">50</span>]<span style="color:#000;font-weight:bold">.</span>flags<span style="color:#000;font-weight:bold">.</span>contiguous
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">233</span>]: <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>In [<span style="color:#099">234</span>]: arr_c[:, :<span style="color:#099">50</span>]<span style="color:#000;font-weight:bold">.</span>flags
</span></span><span style="display:flex;"><span>Out[<span style="color:#099">234</span>]: 
</span></span><span style="display:flex;"><span>  C_CONTIGUOUS : <span style="color:#000;font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>  F_CONTIGUOUS : <span style="color:#000;font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>  OWNDATA : <span style="color:#000;font-weight:bold">False</span>
</span></span><span style="display:flex;"><span>  WRITEABLE : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  ALIGNED : <span style="color:#000;font-weight:bold">True</span>
</span></span><span style="display:flex;"><span>  UPDATEIFCOPY : <span style="color:#000;font-weight:bold">False</span>
</span></span></code></pre></div>
    </div>

    

    

    <div class="container-prevnext">
    <div><a href="https://richfan.site/posts/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch04-numpy%E5%9F%BA%E7%A1%80%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A2%E9%87%8F%E8%AE%A1%E7%AE%97/">← 第四章 Numpy 基础</a></div>
    <div><a href="https://richfan.site/posts/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E9%99%84%E5%BD%95b-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8Eipython%E7%9A%84%E5%86%85%E5%AE%B9/">附录B-更多关于IPython的内容  →</a></div>
</div>
    
    

    
</div>

        </div>
        <div id="footer"><div class="container-footer">
    
    <a href="//beian.miit.gov.cn" target="_blank">
        
        京ICP备2022007001号
        
    </a>
    <a id="s" href="/secrets">&nbsp;</a>
    
</div></div>
    </body>
</html>

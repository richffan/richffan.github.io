<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SQL on 樊刹</title>
    <link>https://richfan.site/tags/sql/</link>
    <description>Recent content in SQL on 樊刹</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 19 Sep 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://richfan.site/tags/sql/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MySQL常用函数</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 19 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid>
      <description>1、数学函数# ABS(x) --返回x的绝对值 BIN(x) --返回x的二进制（OCT返回八进制，HEX返回十六进制） CEILING(x) --返回大于x的最小整数值 EXP(x) --返回值e（自然对数的底）的x次方 FLOOR(x) --返回小于x的最大整数值 GREATEST(x1,x2,...,xn) --返回集合中最大的值 LEAST(x1,x2,...,xn) --返回集合中最小的值 LN(x) --返回x的自然对数 LOG(x,y) --返回x的以y为底的对数 MOD(x,y) --返回x/y的模（余数） PI() --返回pi的值（圆周率） RAND() --返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。 ROUND(x,y) --返回参数x的四舍五入的有y位小数的值 SIGN(x) --返回代表数字x的符号的值 SQRT(x) --返回一个数的平方根 TRUNCATE(x,y) --返回数字x截短为y位小数的结果 2、聚合函数# AVG(X) --返回指定列的平均值 COUNT(X) --返回指定列中非NULL值的个数 MIN(X) --返回指定列的最小值 MAX(X) --返回指定列的最大值 SUM(X) --返回指定列的所有值之和 GROUP_CONCAT(X) --返回由属于一组的列值连接组合而成的结果，非常有用 3、字符串函数（20个）&#xA;ASCII(char) --返回字符的ASCII码值 BIT_LENGTH(str) --返回字符串的比特长度 CONCAT(s1,s2...,sn) --将s1,s2...,sn连接成字符串 CONCAT_WS(sep,s1,s2...,sn) --将s1,s2...,sn连接成字符串，并用sep字符间隔 INSERT(str,x,y,instr) --将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果 FIND_IN_SET(str,list) --分析逗号分隔的list列表，如果发现str，返回str在list中的位置 LCASE(str)或LOWER(str) --返回将字符串str中所有字符改变为小写后的结果 LEFT(str,x) --返回字符串str中最左边的x个字符 LENGTH(s) --返回字符串str中的字符数 LTRIM(str) --从字符串str中切掉开头的空格 POSITION(substr,str) --返回子串substr在字符串str中第一次出现的位置 QUOTE(str) --用反斜杠转义str中的单引号 REPEAT(str,srchstr,rplcstr) --返回字符串str重复x次的结果 REVERSE(str) --返回颠倒字符串str的结果 RIGHT(str,x) --返回字符串str中最右边的x个字符 RTRIM(str) --返回字符串str尾部的空格 STRCMP(s1,s2) --比较字符串s1和s2 TRIM(str) --去除字符串首部和尾部的所有空格 UCASE(str)或UPPER(str) --返回将字符串str中所有字符转变为大写后的结果 4、日期和时间函数# CURDATE()或CURRENT_DATE() --返回当前的日期 CURTIME()或CURRENT_TIME() --返回当前的时间 DATE_ADD(date,INTERVAL int keyword) --返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化) 例如 SELECT DATE_ADD(CURRENT_DATE,INTERVAL 6 MONTH); DATE_FORMAT(date,fmt) --依照指定的fmt格式格式化日期date值 DATE_SUB(date,INTERVAL int keyword) --返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化) 例如 SELECT DATE_SUB(CURRENT_DATE,INTERVAL 6 MONTH); DAYOFWEEK(date) --返回date所代表的一星期中的第几天(1~7) DAYOFMONTH(date) --返回date是一个月的第几天(1~31) DAYOFYEAR(date) --返回date是一年的第几天(1~366) DAYNAME(date) --返回date的星期名，如：SELECT DAYNAME(CURRENT_DATE); FROM_UNIXTIME(ts,fmt) --根据指定的fmt格式，格式化UNIX时间戳ts HOUR(time) --返回time的小时值(0~23) MINUTE(time) --返回time的分钟值(0~59) MONTH(date) --返回date的月份值(1~12) MONTHNAME(date) --返回date的月份名，如：SELECT MONTHNAME(CURRENT_DATE); NOW() --返回当前的日期和时间 QUARTER(date) --返回date在一年中的季度(1~4) 例如 SELECT QUARTER(CURRENT_DATE); WEEK(date) --返回日期date为一年中第几周(0~53) YEAR(date) --返回日期date的年份(1000~9999) 例如，获取当前系统时间 SELECT FROM_UNIXTIME(UNIX_TIMESTAMP()); SELECT EXTRACT(YEAR_MONTH FROM CURRENT_DATE); SELECT EXTRACT(DAY_SECOND FROM CURRENT_DATE); SELECT EXTRACT(HOUR_MINUTE FROM CURRENT_DATE); 返回两个日期值之间的差值(月数) SELECT PERIOD_DIFF(200302,199802); 在Mysql中计算年龄： SELECT DATE_FORMAT(FROM_DAYS(TO_DAYS(NOW())-TO_DAYS(birthday)),&amp;#39;%Y&amp;#39;)+0 AS age FROM employee; 这样，如果Brithday是未来的年月日的话，计算结果为0。 下面的SQL语句计算员工的绝对年龄，即当Birthday是未来的日期时，将得到负值。 SELECT DATE_FORMAT(NOW(), &amp;#39;%Y&amp;#39;) - DATE_FORMAT(birthday, &amp;#39;%Y&amp;#39;) -(DATE_FORMAT(NOW(), &amp;#39;00-%m-%d&amp;#39;) &amp;lt; DATE_FORMAT(birthday, &amp;#39;00-%m-%d&amp;#39;)) AS age from employee 5、加密函数# AES_ENCRYPT(str,key) --返回用密钥key对字符串str利用高级加密标准算法加密后的结果，调用AES_ENCRYPT的结果是一个二进制字符串，以BLOB类型存储 AES_DECRYPT(str,key) --返回用密钥key对字符串str利用高级加密标准算法解密后的结果 DECODE(str,key) --使用key作为密钥解密加密字符串str ENCRYPT(str,salt) --使用UNIXcrypt()函数，用关键词salt(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串str ENCODE(str,key) --使用key作为密钥加密字符串str，调用ENCODE()的结果是一个二进制字符串，它以BLOB类型存储 MD5() --计算字符串str的MD5校验和 PASSWORD(str) --返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。 SHA() --计算字符串str的安全散列算法(SHA)校验和 例如 SELECT ENCRYPT(&amp;#39;root&amp;#39;,&amp;#39;salt&amp;#39;) ; SELECT ENCODE(&amp;#39;xufeng&amp;#39;,&amp;#39;key&amp;#39;) ; SELECT DECODE(ENCODE(&amp;#39;xufeng&amp;#39;,&amp;#39;key&amp;#39;),&amp;#39;key&amp;#39;) ;--加解密放在一起 SELECT AES_ENCRYPT(&amp;#39;root&amp;#39;,&amp;#39;key&amp;#39;) ; SELECT AES_DECRYPT(AES_ENCRYPT(&amp;#39;root&amp;#39;,&amp;#39;key&amp;#39;),&amp;#39;key&amp;#39;) ; SELECT MD5(&amp;#39;123456&amp;#39;) ; SELECT SHA(&amp;#39;123456&amp;#39;) ; 6、控制流函数# CASE WHEN [test1] THEN [result1].</description>
    </item>
    <item>
      <title>live_max_online</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/live_max_online/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/live_max_online/</guid>
      <description>-- step0 建表 -- drop table cm.tb_live_logs; create table cm.tb_live_logs ( live_id int, user_id int, ts datetime, type varchar(10) ); -- step1 插入数据 insert into cm.tb_live_logs (live_id, user_id, ts, type) values (901,1001,&amp;#39;2022-10-01 12:00:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1002,&amp;#39;2022-10-01 12:01:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1003,&amp;#39;2022-10-01 12:01:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1004,&amp;#39;2022-10-01 12:02:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1005,&amp;#39;2022-10-01 12:02:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1006,&amp;#39;2022-10-01 12:03:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1007,&amp;#39;2022-10-01 12:03:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1008,&amp;#39;2022-10-01 12:05:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1009,&amp;#39;2022-10-01 12:05:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1010,&amp;#39;2022-10-01 12:06:03&amp;#39;,&amp;#39;IN&amp;#39;), (902,1101,&amp;#39;2022-10-01 12:00:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1102,&amp;#39;2022-10-01 12:01:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1103,&amp;#39;2022-10-01 12:01:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1104,&amp;#39;2022-10-01 12:02:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1105,&amp;#39;2022-10-01 12:29:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1106,&amp;#39;2022-10-01 12:30:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1107,&amp;#39;2022-10-01 12:31:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1108,&amp;#39;2022-10-01 12:32:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1109,&amp;#39;2022-10-01 12:39:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1110,&amp;#39;2022-10-01 12:06:03&amp;#39;,&amp;#39;IN&amp;#39;), (901,1001,&amp;#39;2022-10-01 12:03:03&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1002,&amp;#39;2022-10-01 12:01:00&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1003,&amp;#39;2022-10-01 12:03:03&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1004,&amp;#39;2022-10-01 12:05:03&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1005,&amp;#39;2022-10-01 12:10:03&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1006,&amp;#39;2022-10-01 12:03:01&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1007,&amp;#39;2022-10-01 12:03:03&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1008,&amp;#39;2022-10-01 12:06:12&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1009,&amp;#39;2022-10-01 12:06:03&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1010,&amp;#39;2022-10-01 12:10:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1101,&amp;#39;2022-10-01 12:03:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1102,&amp;#39;2022-10-01 12:03:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1103,&amp;#39;2022-10-01 12:03:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1104,&amp;#39;2022-10-01 12:05:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1105,&amp;#39;2022-10-01 12:30:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1106,&amp;#39;2022-10-01 12:30:01&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1107,&amp;#39;2022-10-01 12:40:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1108,&amp;#39;2022-10-01 12:44:12&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1109,&amp;#39;2022-10-01 12:42:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1110,&amp;#39;2022-10-01 12:10:03&amp;#39;,&amp;#39;OUT&amp;#39;); -- step2 IN/OUT转数字 select live_id, user_id, ts , IF(type = &amp;#39;IN&amp;#39;, 1, -1) as contribution from cm.</description>
    </item>
    <item>
      <title>MySQL常用30种SQL查询语句优化方法</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/mysql-commonly-uses-30-sql-query-statement-optimization-methods/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/mysql-commonly-uses-30-sql-query-statement-optimization-methods/</guid>
      <description>引言# 在开发和维护MySQL数据库时，优化SQL查询语句是提高数据库性能和响应速度的关键。通过合理优化SQL查询，可以减少数据库的负载，提高查询效率，为用户提供更好的用户体验。本文将介绍常用的30种MySQL SQL查询优化方法，并通过实际案例演示它们的应用。&#xA;第一部分：基础优化方法# 1.使用索引# 索引是提高数据库查询性能的基础，通过为查询字段添加合适的索引，可以加快查询速度。在创建索引时，需要考虑查询的频率和数据的更新频率，避免过度索引或不必要的索引。&#xA;-- 创建索引 CREATE INDEX idx_column ON table_name(column_name); 2.避免使用SELECT *# 在查询数据时，尽量避免使用SELECT *，而是明确指定需要查询的字段。这样可以减少返回的数据量，提高查询效率。&#xA;-- 不推荐 SELECT * FROM table_name; -- 推荐 SELECT column1, column2 FROM table_name; 3.使用EXPLAIN分析查询计划# 使用EXPLAIN命令可以分析查询的执行计划，帮助优化查询语句，查找潜在的性能问题。&#xA;EXPLAIN SELECT * FROM table_name WHERE column_name = &amp;#39;value&amp;#39;; 第二部分：优化查询条件# 4.使用WHERE子句过滤数据# 在查询数据时，尽量使用WHERE子句对数据进行过滤，减少返回的数据量。&#xA;-- 不推荐 SELECT * FROM table_name; -- 推荐 SELECT * FROM table_name WHERE column_name = &amp;#39;value&amp;#39;; 5.使用索引覆盖查询# 索引覆盖查询是指查询的字段都包含在索引中，不需要回表查询数据。这样可以减少IO操作，提高查询效率。&#xA;-- 创建索引 CREATE INDEX idx_column ON table_name(column_name); -- 索引覆盖查询 SELECT column1, column2 FROM table_name WHERE column_name = &amp;#39;value&amp;#39;; 6.</description>
    </item>
    <item>
      <title>SQL每日一题(20230814)</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-20230814/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-20230814/</guid>
      <description>SQL每日一题(20230814)# 题目# 有如下两张表G0227A（客户表）&#xA;Id Name 1 曹操 2 关于 3 刘备 4 张飞 G0227B（订单表）&#xA;Id CustomerId 1 3 2 1 查询G0227B表（订单表）中找出从来没有买过商品的用户。&#xA;预计结果如下：&#xA;Id Name 2 关于 要求：用至少四种方法求解。# create table G0814A ( Id int, Name varchar(20) ) insert into G0814A values (1,&amp;#39;曹操&amp;#39;); insert into G0814A values (2,&amp;#39;关羽&amp;#39;); insert into G0814A values (3,&amp;#39;刘备&amp;#39;); insert into G0814A values (4,&amp;#39;张飞&amp;#39;); create table G0814B( Id int, CustomerId int ) insert into G0814B values (1,3); insert into G0814B values (2,1); 参考答案# -- 方法一: 关联查询 SELECT a.</description>
    </item>
    <item>
      <title>SQL每日一题F0215，多种方法及思路讲解</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f0215-a-variety-of-methods-and-ideas-explained/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f0215-a-variety-of-methods-and-ideas-explained/</guid>
      <description>SQL每日一题F0215，多种方法及思路讲解# CREATE TABLE F0215 ( StuID INT, CID VARCHAR(10), Course INT ) INSERT INTO F0215 VALUES (1,&amp;#39;001&amp;#39;,67), (1,&amp;#39;002&amp;#39;,89), (1,&amp;#39;003&amp;#39;,94), (2,&amp;#39;001&amp;#39;,95), (2,&amp;#39;002&amp;#39;,88), (2,&amp;#39;004&amp;#39;,78), (3,&amp;#39;001&amp;#39;,94), (3,&amp;#39;002&amp;#39;,77), (3,&amp;#39;003&amp;#39;,90) select * from f0215 /* 查询出既学过&amp;#39;001&amp;#39;课程，也学过&amp;#39;003&amp;#39;号课程的学生ID */ --错误写法 SELECT * FROM F0215 WHERE CID=&amp;#39;001&amp;#39; AND CID=&amp;#39;003&amp;#39; SELECT * FROM F0215 WHERE CID=&amp;#39;001&amp;#39; OR CID=&amp;#39;003&amp;#39; --思路一，取自连接符合条件的学生 SELECT T1.STUID FROM ( SELECT STUID FROM F0215 WHERE CID=&amp;#39;001&amp;#39; ) T1 INNER JOIN (SELECT STUID FROM F0215 WHERE CID=&amp;#39;003&amp;#39; ) T2 ON T2.</description>
    </item>
    <item>
      <title>SQL每日一题F1021，while循环操作</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f1021-while-loop-operation/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f1021-while-loop-operation/</guid>
      <description>SQL每日一题F1021，while循环操作# /* 写一个查询语句要求 求出整数1到100之间排除55后的和 预计结果是4995 该如何写这个查询？&#xA;要求：使用while循环 */&#xA;DECLARE @i INT DECLARE @sum INT SET @i=0 SET @sum=0 WHILE @i&amp;lt;100 BEGIN SET @i=@i+1 IF @i=55 CONTINUE ELSE SET @sum=@sum+@i END PRINT @sum</description>
    </item>
    <item>
      <title>SQL每日一题F1025，复杂逻辑处理</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f1025-complex-logic-processing/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f1025-complex-logic-processing/</guid>
      <description>SQL每日一题F1025，复杂逻辑处理# create table F1025 ( id int, num int ) insert into F1025 values(1,5); insert into F1025 values(2,11); insert into F1025 values(3,0); insert into F1025 values(4,-2); insert into F1025 values(5,2); insert into F1025 values(6,9); insert into F1025 values(7,1); insert into F1025 values(8,-4); insert into F1025 values(9,-7); &amp;ndash; Q：要求当Num中的数据同时大于上下两行数据，返回值为“是”， &amp;ndash; 当Num中的数据小于上下两行数据中的任何一行，返回值为“否” &amp;ndash; 例如：11大于5,11大于0，所以11那行返回值为“是”；5小于11，所以5那行返回值为“否”&#xA;SELECT a.id ,a.Num ,CASE WHEN a.Num&amp;gt;ISNULL(( SELECT Num FROM F1025 b WHERE b.id=a.id-1 ),a.Num-1) AND a.Num&amp;gt;ISNULL(( SELECT Num FROM F1025 c WHERE c.</description>
    </item>
    <item>
      <title>SQL每日一题F1028，关联子查询</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f1028-correlation-subquery/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f1028-correlation-subquery/</guid>
      <description>SQL每日一题F1028，关联子查询# create table F1028A (aid varchar(20), bid varchar(20) ) insert into F1028A values (&amp;lsquo;跑步&amp;rsquo;,&amp;lsquo;张三&amp;rsquo;); insert into F1028A values (&amp;lsquo;游泳&amp;rsquo;,&amp;lsquo;张三&amp;rsquo;); insert into F1028A values (&amp;lsquo;跳远&amp;rsquo;,&amp;lsquo;李四&amp;rsquo;); insert into F1028A values (&amp;lsquo;跳高&amp;rsquo;,&amp;lsquo;王五&amp;rsquo;);&#xA;create table F1028B (aid varchar(20), bid varchar(20), cid varchar(20) ) insert into F1028B values (&amp;lsquo;跑步&amp;rsquo;,&amp;lsquo;张三&amp;rsquo;,&amp;lsquo;胜利&amp;rsquo;); insert into F1028B values (&amp;lsquo;游泳&amp;rsquo;,&amp;lsquo;张三&amp;rsquo;,&amp;lsquo;胜利&amp;rsquo;); insert into F1028B values (&amp;lsquo;跳高&amp;rsquo;,&amp;lsquo;王五&amp;rsquo;,&amp;lsquo;胜利&amp;rsquo;);&#xA;&amp;ndash; Q：anum表示每个人参加的项目数，bnum表示每个人在各自项目中胜利的次数，该如何写这个查询？&#xA;&amp;ndash;解法一： SELECT ISNULL(t1.bid, t2.bid) AS bid, ISNULL(t1.anum, 0) anum, ISNULL(t2.bnum, 0) bnum FROM ( SELECT bid, COUNT(1) AS anum FROM F1028A GROUP BY bid ) t1 FULL JOIN ( SELECT bid, SUM(CASE WHEN cid = &amp;lsquo;胜利&amp;rsquo; THEN 1 ELSE 0 END ) bnum FROM F1028B GROUP BY bid ) t2 ON t2.</description>
    </item>
    <item>
      <title>top10_sql_skills</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/top10_sql_skills/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/top10_sql_skills/</guid>
      <description>-- 01 -- bad create table cm.tb_user( id int, name varchar(255), age int, gender varchar(16) ); -- good create table cm.tb_user( id int primary key, name varchar(255), age int, gender varchar(16), store_time datetime default now() ); -- 02 -- bad create table cm.tb_user( id int primary key , name varchar(255) not null default &amp;#39;NULL&amp;#39;, age int, gender varchar(16), create_time datetime default now(), update_time datetime default now() ); -- good create table cm.</description>
    </item>
    <item>
      <title>查询连续登陆3天的用户id和登陆天数</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/online_users_with_3_consecutive_days/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/online_users_with_3_consecutive_days/</guid>
      <description>-- 查询连续登陆3天的用户id和登陆天数 -- step1:用户登录日期去重 select distinct user_id, date(visit_time) as dt from cm.tb_user_logs; -- step2:用row_number()计数 select *, row_number() over (PARTITION by user_id order by dt) as xrank from (select distinct user_id, date(visit_time) as dt from cm.tb_user_logs) a; -- step3: 日期减去计数值得到差值delta select *, date_sub(dt, INTERVAL xrank DAY) as delta from (select *, row_number() over (PARTITION by user_id order by dt) as xrank from (select distinct user_id, date(visit_time) as dt from cm.tb_user_logs) a ) b; -- step4:根据id和结果分组并计算总和,大于等于3的即为连续登录3天的用户 select user_id, min(dt) as start_date, count(*) as days from (select *, date_sub(dt, INTERVAL xrank DAY) as delta from (select *, row_number() over (PARTITION by user_id order by dt) as xrank from (select distinct user_id, date(visit_time) as dt from cm.</description>
    </item>
    <item>
      <title>给定用户登录表，求表中每一天的3天留存率</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/3days_alive_users/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/3days_alive_users/</guid>
      <description>-- 给定用户登录表，求表中每一天的&amp;#34;3天留存率&amp;#34; -- step 0 表准备，用户ID，登录时间 create table cm.tb_user_logs( user_id int, visit_time datetime ); insert into cm.tb_user_logs (user_id, visit_time) values (1001, &amp;#39;2022-10-01 08:01:23&amp;#39;), (1001, &amp;#39;2022-10-01 08:11:15&amp;#39;), (1002, &amp;#39;2022-10-01 08:22:19&amp;#39;), (1003, &amp;#39;2022-10-01 09:00:53&amp;#39;), (1002, &amp;#39;2022-10-02 18:00:13&amp;#39;), (1004, &amp;#39;2022-10-02 13:30:43&amp;#39;), (1004, &amp;#39;2022-10-02 15:06:22&amp;#39;), (1005, &amp;#39;2022-10-02 08:00:39&amp;#39;), (1002, &amp;#39;2022-10-03 08:00:13&amp;#39;), (1003, &amp;#39;2022-10-03 18:00:13&amp;#39;), (1004, &amp;#39;2022-10-03 21:00:13&amp;#39;), (1006, &amp;#39;2022-10-03 22:00:13&amp;#39;), (1001, &amp;#39;2022-10-04 11:10:13&amp;#39;), (1002, &amp;#39;2022-10-04 12:00:13&amp;#39;), (1002, &amp;#39;2022-10-04 09:00:13&amp;#39;), (1004, &amp;#39;2022-10-04 08:00:13&amp;#39;), (1006, &amp;#39;2022-10-04 08:00:13&amp;#39;), (1004, &amp;#39;2022-10-05 08:00:13&amp;#39;), (1005, &amp;#39;2022-10-05 08:00:13&amp;#39;), (1002, &amp;#39;2022-10-05 08:00:43&amp;#39;), (1003, &amp;#39;2022-10-05 12:00:13&amp;#39;), (1004, &amp;#39;2022-10-05 10:00:43&amp;#39;), (1006, &amp;#39;2022-10-05 08:00:11&amp;#39;), (1001, &amp;#39;2022-10-06 09:00:47&amp;#39;), (1001, &amp;#39;2022-10-06 07:00:15&amp;#39;), (1002, &amp;#39;2022-10-06 18:00:43&amp;#39;), (1003, &amp;#39;2022-10-07 20:00:19&amp;#39;), (1002, &amp;#39;2022-10-07 21:00:23&amp;#39;), (1004, &amp;#39;2022-10-07 22:00:43&amp;#39;); -- step 1 创建视图，进行用户ID和时间去重 create view A as select distinct user_id, date(visit_time) as dt from cm.</description>
    </item>
    <item>
      <title>求占据前90%销售额的商品类型</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/90_percent_contribution_goods/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/90_percent_contribution_goods/</guid>
      <description>-- 求占据前90%销售额的商品类型 -- step0. 准备数据 create table cm.tb_sale_amount( good_category int comment &amp;#39;商品类型ID&amp;#39;, sale_date date comment &amp;#39;销售日期&amp;#39;, amount int comment &amp;#39;销售额&amp;#39;, primary key(good_category, sale_date) ); truncate cm.tb_sale_amount; insert into cm.tb_sale_amount (good_category, sale_date, amount) values (1003, &amp;#39;2022-01-10&amp;#39;, 264), (1001, &amp;#39;2022-06-01&amp;#39;, 21), (1005, &amp;#39;2022-06-01&amp;#39;, 73), (1002, &amp;#39;2022-06-27&amp;#39;, 44), (1006, &amp;#39;2022-06-27&amp;#39;, 405), (1003, &amp;#39;2022-09-10&amp;#39;, 16), (1005, &amp;#39;2022-09-13&amp;#39;, 72), (1004, &amp;#39;2022-10-01&amp;#39;, 29), (1005, &amp;#39;2022-10-03&amp;#39;, 332), (1001, &amp;#39;2022-10-29&amp;#39;, 10), (1006, &amp;#39;2022-10-29&amp;#39;, 137), (1002, &amp;#39;2022-12-02&amp;#39;, 23), (1007, &amp;#39;2022-12-02&amp;#39;, 19), (1003, &amp;#39;2022-12-02&amp;#39;, 30), (1008, &amp;#39;2022-12-03&amp;#39;, 3), (1009, &amp;#39;2022-12-04&amp;#39;, 1), (1010, &amp;#39;2022-12-05&amp;#39;, 9), (1003, &amp;#39;2022-12-30&amp;#39;, 121); -- step1.</description>
    </item>
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Golang on 樊刹</title>
    <link>https://richfan.site/tags/golang/</link>
    <description>Recent content in Golang on 樊刹</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Sat, 01 Oct 2022 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://richfan.site/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Golang入门笔记-CH01-Go语言介绍与安装</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch01-go%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch01-go%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</guid>
      <description>1. Go 语言介绍# 1.1 Go 语言的发展# Go 语言又称 Golang，起源于 2007 年，来自于谷歌内部的一个项目，于 2009 年正式对外发布。创始团队有三人，都是计算机界的大佬：&#xA;Robert Griesemer：参与开发 Java HotSpot 虚拟机 Rob Pike：Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言 Ken Thompson：C 语言、Unix 和 Plan 9 的创始人之一 Go 语言是开源的，通过开源社区的力量得到了快速发展，越来越多的开发者开始使用 Go 语言。自 Go 语言发布以来，超过 200 名非谷歌员工贡献者对 Go 语言核心部分提交了超过 1000 个修改建议。在过去的 18 个月里，又有 150 开发者贡献了新的核心代码。&#xA;根据 TIOBE 2020 年 8 月份的编程语言排行榜，Go 语言位列第 11 位。&#xA;国内也有很多大厂在用 Go 语言，包括腾讯、阿里、百度、B 站、知乎等，我们可以看到 Go 语言的潜力还是非常大 的。&#xA;1.2 Go 语言的特点# Go 语言的主要特点有：</description>
    </item>
    <item>
      <title>Golang入门笔记-CH02-Go语言基本语法和结构</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch02-go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch02-go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E7%BB%93%E6%9E%84/</guid>
      <description>1. 命名规范# 1.1 文件# Go 语言中，源文件以 .go 格式保存，例如 main.go，且文件名只能由小写字母组成，若有多个单词，可以用下划线 _ 进行拼接，例如 my_file.go。&#xA;1.2 标识符# Go 语言中，标识符是区分大小写的，标识符必须以字符或 _ 开头，后面可以跟 0 个或多个字符（字母、数字以及其他符号），例如 _，_abc，a1，b_2。同时标识符不能是 Go 语言中的保留关键字，不能以数字开头，也不能有运算符。&#xA;以下这些标识符是错误的：&#xA;2c（不能以数字开头） switch（不能是保留关键字） m+n（不能出现运算符） _ 是一个特殊的标识符，叫做空白标识符。它既可以被赋值或定义（任意类型的数据），但它接收的值将被抛弃，无法在代码中继续使用。有时候函数会返回多个值，我们可能不需要使用某些值，便可以用 _ 来接收，提高代码的灵活性。&#xA;用 _ 接收的变量统称为匿名变量。&#xA;1.3 保留关键字# 以下是 Go 语言中的保留关键字:&#xA;保留关键字仅 25 个，还是比较少的，有利于加快编译速度。&#xA;break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 1.4 预定义标识符# 以下是 Go 语言中 36 个预定义标识符，在后面我们会用到：</description>
    </item>
    <item>
      <title>Golang入门笔记-CH03-Go语言基本数据类型</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch03-go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch03-go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>1. 常量# 1.1 常量的定义# 常量是一种特殊的变量，被初始化之后就无法再改变。&#xA;Go 语言中，常量的类型只能是布尔型，数字型（整型、浮点型和复数）和字符串型。&#xA;常量可以使用关键字 const 来定义，定义格式为 const variable [type] = value。&#xA;const m string = &amp;#34;abc&amp;#34; // 显示声明 const n = &amp;#34;xyz&amp;#34; // 隐式声明 常量的值必须在编译时能确定，给常量赋值时可以涉及表达式的计算，但计算值必须能在编译时确定。&#xA;const m = 2/3 // 正确 const n = getValue() // 错误，编译时自定义函数属于未知，无法用于常量赋值，但可以使用内置函数，如 len() 1.2 枚举# 常量也可以用于枚举：&#xA;Unknown 表示未知性别，Female 表示女性，Male 表示男性。&#xA;const ( Unknown = 0 Female = 1 Male = 2 ) itoa 是一个特殊的常量，itoa 在 const 关键字出现时被重置为 0；const 中每多声明一行常量，itos 会自动加 1（ itoa 可理解成常量的行索引）。如：</description>
    </item>
    <item>
      <title>Golang入门笔记-CH04-Go语言流程控制</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch04-go%E8%AF%AD%E8%A8%80%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch04-go%E8%AF%AD%E8%A8%80%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>前言# 流程控制是每门语言控制程序逻辑和执行顺序的重要组成部分，Go 语言中常见的流程控制有 if，for，switch；break、continue 和 goto 是为了简化流程控制，降低代码复杂度。&#xA;if-else# if 分支结构的基本写法为：&#xA;if 分支结构多用于条件判断。&#xA;if 表达式1 { 分支1 } else if 表达式2 { 分支2 } else { 分支3 } 上述代码中，若表达式1的值为 true，程序将会执行分支1；若表达式1的值为 false，继续判断表达式2，若表达式2为 true，将会执行分支2；若表达式1和表达式2都为false，将会执行分支3。&#xA;if-else 分支结构会逐层判断表达式是否为 true，若为 true，则执行该表达式中对应的分支，否则继续判断下一个表达式，依次类推。&#xA;我们来看一个例子：&#xA;package main import &amp;#34;fmt&amp;#34; func testIf(score int) { if score &amp;gt;= 90 { fmt.Println(&amp;#34;优秀&amp;#34;) } else if score &amp;gt;= 75 { fmt.Println(&amp;#34;良好&amp;#34;) } else if score &amp;gt; 60 { fmt.Println(&amp;#34;及格&amp;#34;) } else { fmt.Println(&amp;#34;不及格&amp;#34;) } } func main() { testIf(90) } 运行结果为:</description>
    </item>
    <item>
      <title>Golang入门笔记-CH05-数组和切片</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch05-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch05-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/</guid>
      <description>数组# 初始化# 数组可以保存指定长度的多个数据，且这些数据的类型都相同，数据类型可以是原始类型，如整型和字符串等，也可以是自定义类型。&#xA;数组通过索引来访问元素，索引从 0 开始，第一个元素的索引为 0，第二个为 1，依此类推。&#xA;在 Go 语言中声明数组的格式为：&#xA;var variable [len]type 例如，声明名称为arr1，长度和类型分别为5和 int 的数组：&#xA;var arr1 [5]int 我们可以让编译器根据元素个数自动推断数组长度，只需要在声明长度时用 ... 替代：&#xA;var numArray = [...]int{1, 2, 3} 我们还可以根据索引来声明数组：&#xA;a := [...]string{0: &amp;#34;北京&amp;#34;, 1: &amp;#34;上海&amp;#34;} // 索引 0 对应的元素为&amp;#34;北京&amp;#34;，1 对应的元素为&amp;#34;上海&amp;#34; 整型数组中所有元素都初始化为 0，数组 arr中第 i 个元素为arr[i - 1]，最后一个元素为 arr[len(arr) - 1]。&#xA;数组是可变的，可以通过索引对元素进行赋值：arr[1] = 1。&#xA;注意：在程序中若索引超出数组最大有效索引，会引发 index out of range 错误。&#xA;遍历数组# 普通 for 循环&#xA;package main import &amp;#34;fmt&amp;#34; func main() { a := [.</description>
    </item>
    <item>
      <title>Golang入门笔记-CH06-Map</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch06-map/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch06-map/</guid>
      <description>声明和初始化 Map# map 是一种特殊的数据结构，通过键 key 和值 value 来保存数据，可以快速地根据 key 找到其对应的 value，与 python 中的字典和 Java 中的 HashMap 类似。&#xA;map 是引用类型，声明方式如下：&#xA;var variable map[keyType]valueType 在声明的时候不需要知道 map 的长度，map 是可以动态增长的。&#xA;未初始化的 map 的值是 nil。&#xA;map 中的 key 只能是可以用 == 和 != 来比较的变量类型，例如 string，int 和 float 等，不能是数组，结构体和切片，但指针和接口可以作为 key。如果要使用结构体来作为 key，需要提供 Key() 和 Hash() 方法，value 可以为任意类型。&#xA;可以通过赋值符号来设置 key1 对应的 value：&#xA;map1[key1] = value 也可以根据赋值符号获取 key1 对应的 value，若 map1 中没有 key1 对应的值，val 将会被赋值 map1 的值类型的空值。&#xA;val := map1[key1] 示例：</description>
    </item>
    <item>
      <title>Golang入门笔记-CH07-结构体和方法</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch07-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch07-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%96%B9%E6%B3%95/</guid>
      <description>Go 语言通过 定义结构体来支持用户自定义类型。一个结构体代表现实世界中的一个实体，类似于 Java 中的实体类。当要定义一个类型时，这个类型包含很多属性，例如定义一个用户类型，用户类型中包含用户名、密码和生日等属性，就可以使用结构体。&#xA;组成结构体属性的数据成为字段，每个字段都有类型和名称；在结构体中，字段名称必须唯一。由于 Go 语言中不存在类的概念，所以结构体 struct 在 Go 语言中有着较高的地位。&#xA;结构体的定义# 格式# 结构体定义的格式如下：&#xA;type variable struct { field1 type1 field2 type2 } 若结构体中有多个同类型字段，可以简写，如：&#xA;type T struct { a, b int } 若结构体中的字段并不需要使用，可以用匿名变量 _ 来定义，如：&#xA;type M struct { _ int } 结构体中字段的类型可以是任意类型（包括结构体、函数和接口等）。&#xA;使用 new# 可以使用 new 函数给新结构体变量分配内存，它返回指向分配内存的指针，如：&#xA;var t *T = new(T) 当然，也可以将上述语句拆成两行：&#xA;var t *T t = new(T) 在函数内部，一般采用短变量形式，如：&#xA;t := new(T) 声明 var t T 也会给 t 分配内存，并零值化内存，但此时 t 是类型 T。在这两种方式中，t 通常被称作 T 的一个实例（instance）或者对象（Object）。</description>
    </item>
    <item>
      <title>Golang入门笔记-CH08-接口</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch08-%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch08-%E6%8E%A5%E5%8F%A3/</guid>
      <description>1. 使用接口的原因# 我们来看一段代码：&#xA;type Cat struct{} func (c Cat) Say() string { return &amp;#34;喵喵喵&amp;#34; } type Dog struct{} func (d Dog) Say() string { return &amp;#34;汪汪汪&amp;#34; } func main() { c := Cat{} fmt.Println(&amp;#34;猫:&amp;#34;, c.Say()) d := Dog{} fmt.Println(&amp;#34;狗:&amp;#34;, d.Say()) } 上述代码中定义了狗 Dog 和猫 Cat 以及它们对应的方法 Say()，若要继续添加鸭 Duck 方法和其对应的方法 Say()，重复代码会非常多。我们可不可以从这三种动物类型中抽象出方法 Say()，这就是接口的作用，接口可以定义抽象方法，来规范我们的代码。&#xA;2. 接口的定义和使用# Go 语言非传统面对对象语言，没有类和继承的概念。但在 Go 语言中可以通过接口来实现面对对象的一些特性，接口是用来描述对象行为的，可以在其中定义一些抽象方法，这些方法不能被实现，同时接口中不能包含变量。&#xA;Go 语言中接口 interface 是一种抽象类型。&#xA;接口的定义格式：&#xA;type Namer interface { Method1(params) returnType Method2(params) returnType } 一般接口以 [e]r 结尾，例如 Writer、Logger 等。若 er 结尾不合适时，可以采用 able 结尾，例如 Recoverable。</description>
    </item>
    <item>
      <title>Golang入门笔记-CH09-反射</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch09-%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch09-%E5%8F%8D%E5%B0%84/</guid>
      <description>反射是用程序检查其所拥有的结构，尤其是类型的一种能力。反射可以在运行时（不必在编译时）检查类型和变量，例如大小、变量、方法和动态调用这些方法。&#xA;方法和类型的反射# reflect 包提供了反射功能，它定义两个重要类型：Type 和 Value，分别表示动态类型和值。&#xA;有两个常用的方法：&#xA;reflect.TypeOf：返回对象的具体类型。 reflect.ValueOf：返回对象的值。 反射是先检查一个接口的值，再将变量转换成空接口类型，我们看下这两个函数的定义就能明白了：&#xA;func TypeOf(i interface{}) Type func ValueOf(i interface{}) Value reflect.TypeOf# 函数 reflect.Typeof() 可以接收任意 interface{} 类型数据，并返回其动态类型。&#xA;package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) func main() { t := reflect.TypeOf(3) // a reflect.Type fmt.Println(t.String()) // &amp;#34;int&amp;#34; fmt.Println(t) // &amp;#34;int&amp;#34; } 由于 reflect.TypeOf 返回的是一个动态类型的接口值，因此它返回的总是具体类型。下面的代码打印将是 *os.File，而不是 io.Writer：&#xA;package main import ( &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;os&amp;#34; &amp;#34;reflect&amp;#34; ) func main() { var w io.Writer = os.Stdout fmt.Println(reflect.TypeOf(w)) // &amp;#34;*os.</description>
    </item>
    <item>
      <title>Golang入门笔记-CH10-函数高级特性</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch10-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch10-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</guid>
      <description>传递变长参数# 如果函数最后一个参数采用 ...type 的形式，那么这个函数就可以处理一个变长参数（长度可以为 0），这样的函数被称为变参函数，如：&#xA;func myFunc(a int, args ...int) 如果参数存储在切片 arr 中，可以用 arr... 来传递参数，如：&#xA;package main import &amp;#34;fmt&amp;#34; func main() { x := Min(1, 3, 2, 0) fmt.Printf(&amp;#34;The minimum is: %d\n&amp;#34;, x) arr := []int{7, 9, 3, 5, 1} x = Min(arr...) fmt.Printf(&amp;#34;The minimum in the arr is: %d&amp;#34;, x) } func Min(a ...int) int { if len(a) == 0 { return 0 } min := a[0] for _, v := range a { if v &amp;lt; min { min = v } } return min } 上述代码运行结果为：</description>
    </item>
    <item>
      <title>Golang入门笔记-CH11-错误处理</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch11-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch11-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>Go 没有像 Java 那样的 try/catch 异常处理机制，而是用 defer/panic/recover 机制来处理异常。&#xA;Go 语言的设计者认为 try/catch 机制使用过于泛滥，而且从底层向高层抛出错误太耗费资源，因此他给 Go 语言设计了一种返回值处理错误方式：通过在函数和方法中返回错误对象，这个错误对象一般在多个返回值的最后；如果返回 nil，则表明没有错误，且主调函数应该检查并处理每一个错误。&#xA;我们通过调用 pack1 包中的 Func1 函数来了解 Go 语言中的错误处理方式：&#xA;Func1返回了两个值，一个 value和 err，err 是错误对象，若 err 不为 nil（nil 是空的意思，类似于 Java 中的 null），则进行错误处理，打印出具体错误信息。&#xA;if value, err := pack1.Func1(param1); err != nil { fmt.Printf(&amp;#34;Error %s in pack1.Func1 with parameter %v&amp;#34;, err.Error(), param1) return // or: return err } Go 有一个预先定义的 error 接口类型 ：&#xA;type error interface { Error() string } 错误处理# 定义错误# 可以通过 errors 包中 New() 函数传递错误信息，从而自定义错误，如下：</description>
    </item>
    <item>
      <title>Golang入门笔记-CH12-并发</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch12-%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch12-%E5%B9%B6%E5%8F%91/</guid>
      <description>基本概念# 线程和进程# 进程 ：是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个 独立单位 。 线程 ：是进程的一个执行实体，是 CPU 调度和分派的 基本单位 ，它是比进程更小的能独立运行的 基本单位 。 一个进程可以创建或撤销多个线程；同一个进程中的多个线程之间可以并发执行。&#xA;线程和协程# 协程 ：独立栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。 线程 ：一个线程上可以跑多个协程，协程是轻量级的线程。 并发和并行# 并发 和 并行 虽然相似，但是有所不同：&#xA;并发 ：逻辑上具备同时处理多个任务的能力。 并行 ：物理上在同一时刻执行多个并发任务。 我们一般会说程序是并发的，意思是说它允许多个任务同时进行，但不一定在同一时刻发生。对于单核处理器，它们能以间隔方式切换运行；而并行则依赖多核心处理器，是让多个任务真正能在同一时刻运行，是一种程序运行的状态。&#xA;多线程和多进程是并行的基本条件，但单线程也可用协程（coroutine）做到并发。虽然单线程只能通过主动切换来实现并发，但也有优点，可以避免由于切换线程导致的资源消耗。协程上运行多个任务本质上是串行的，且可控，无需做同步处理。&#xA;采用多进程也不一定能并行，Python 由于 GIL 的限制，默认只能并发而不能并行，转而使用“ 多进程 + 协程 ”来实现并行。&#xA;多进程、多线程和协程各有利弊，一般用多进程来实现分布式和负载均衡，减轻单进程垃圾回收压力；用多线程抢夺更多的处理器资源；用协程来提高处理器时间片利用率。&#xA;goroutine# 在 Java 中要实现并发编程，需要自己维护一个线程池，处理线程调度和上下文切换，非常麻烦。Go 语言的 goroutine 很好地解决了这一问题，goroutine 类似于线程，但 goroutine 由 Go 的运行时（runtime）来调度和管理，Go 程序会智能地将 goroutine 中的任务合理分配给每个 CPU。&#xA;在 Go 语言中使用 goroutine 很简单，只要在调用函数前加一个 go 关键字即可。&#xA;一个 goroutine 必须对应一个函数，可以创建多个 goroutine 去执行相同函数。&#xA;启动单个 goroutine# 启动单个 Goroutine 只需在调用函数时加一个 go 关键字即可，例如：</description>
    </item>
  </channel>
</rss>

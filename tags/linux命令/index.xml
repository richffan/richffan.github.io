<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>linux命令 on 中文文档</title>
    <link>https://richfan.site/tags/linux%E5%91%BD%E4%BB%A4/</link>
    <description>Recent content in linux命令 on 中文文档</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 25 Dec 2020 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://richfan.site/tags/linux%E5%91%BD%E4%BB%A4/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>每天一个linux命令（25）: gzip</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-25-gzip/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-25-gzip/</guid>
      <description>减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。&#xA;命令格式# $ gzip [参数] [文件或者目录] 命令功能# gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出&amp;quot;.gz&amp;quot;的扩展名。&#xA;命令参数# 参数 描述 -a或&amp;ndash;ascii 使用ASCII文字模式。 -c或&amp;ndash;stdout或&amp;ndash;to-stdout 把压缩后的文件输出到标准输出设备，不去更动原始文件。 -d或&amp;ndash;decompress或&amp;mdash;-uncompress 解开压缩文件。 -f或&amp;ndash;force 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 -h或&amp;ndash;help 在线帮助。 -l或&amp;ndash;list 列出压缩文件的相关信息。 -L或&amp;ndash;license 显示版本与版权信息。 -n或&amp;ndash;no-name 压缩文件时，不保存原来的文件名称及时间戳记。 -N或&amp;ndash;name 压缩文件时，保存原来的文件名称及时间戳记。 -q或&amp;ndash;quiet 不显示警告信息 -r或&amp;ndash;recursive 递归处理，将指定目录下的所有文件及子目录一并处理。 -S&amp;lt;压缩字尾字符串&amp;gt;或&amp;mdash;-suffix&amp;lt;压缩字尾字符串&amp;gt; 更改压缩字尾字符串。 -t或&amp;ndash;test 测试压缩文件是否正确无误。 -v或&amp;ndash;verbose 显示指令执行过程。 -V或&amp;ndash;version 显示版本信息。 -num 用指定的数字num调整压缩的速度，-1或&amp;ndash;fast表示最快压缩方法（低压缩比），-9或&amp;ndash;best表示最慢压缩方法（高压缩比）。系统缺省值为6。 命令实例# 例一：把test目录下的每个文件压缩成.gz文件&#xA;## 忽略目录，只打包其中文件 $ gzip * 例二：把例1中每个压缩的文件解压，并列出详细的信息&#xA;$ gzip -dv * 例三：详细显示例1中每个压缩的文件的信息，并不解压&#xA;$ gzip -l * 例四：压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gz&#xA;$ gzip -r log.tar 例五：递归的压缩目录&#xA;$ gzip -rv test6 例六：递归地解压目录</description>
    </item>
    <item>
      <title>每天一个linux命令（58）: sort</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-58-sort/</link>
      <pubDate>Tue, 23 May 2017 11:44:12 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-58-sort/</guid>
      <description>&lt;p&gt;sort是在Linux里非常常用的一个命令，管排序的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>解决linux下zip文件解压乱码</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E8%A7%A3%E5%86%B3linux%E4%B8%8Bzip%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E4%B9%B1%E7%A0%81/</link>
      <pubDate>Tue, 25 Apr 2017 09:10:40 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E8%A7%A3%E5%86%B3linux%E4%B8%8Bzip%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E4%B9%B1%E7%A0%81/</guid>
      <description>&lt;h3 id=&#39;原因&#39;&gt;原因&lt;a href=&#39;#%e5%8e%9f%e5%9b%a0&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;由于zip格式并没有指定编码格式，Windows下生成的zip文件中的编码是GBK/GB2312等，因此，导致这些zip文件在Linux下解压时出现乱码问题，因为Linux下的默认编码是UTF8。&lt;/p&gt;</description>
    </item>
    <item>
      <title>每天一个linux命令（57）: sftp</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-57-sftp/</link>
      <pubDate>Sun, 05 Mar 2017 16:29:38 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-57-sftp/</guid>
      <description>&lt;p&gt;sFTP（安全文件传输程序）是一种安全的交互式文件传输程序，其工作方式与 FTP（文件传输协议）类似。 然而，sFTP 比 FTP 更安全；它通过加密 SSH 传输处理所有操作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>每天一个linux命令（56）: tailf</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-56-tailf/</link>
      <pubDate>Mon, 20 Feb 2017 15:11:06 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-56-tailf/</guid>
      <description>　tailf 一个实时监听文件或日志的强大的命令&#xA;命令格式# $ tailf [option] file 命令描述# tailf 将会打印出一个文件的最后10行,等待并持续输出此文件的增长，它和tail -f相似，不同之处是当文件没有增长时，是不访问此文件的；但这会有一个副作用：不会更新文件的访问时间。当没有发生日志活动时，文件系统的冲洗（flush）不会定期发生。 tailf 对于打印日志不频繁，而又在使用笔记本电脑时是非常有用的，这样用户就能降低磁盘转速从而增加笔记本续航。&#xA;命令参数# 参数 描述 -n,&amp;ndash;lines=N,-N 输出最后N行,而不是默认的最后10行 命令实例# 例一：展示一个文件的最后5行并监听文件的新行（新增加的内容）&#xA;$ tailf -n 5 myfile.txt $ tailf -5 myfile.txt $ tailf --lines=5 myfile.txt 注：这是一个实时监听文件或日志的强大的命令&#xA;例二：实时新增日志内容，并通过管道过滤出自己想要的内容&#xA;## 实时监听ip地址为24.10.160.10的访问日志 $ tailf access.log | grep 24.10.160.10 </description>
    </item>
    <item>
      <title>每天一个linux命令（55）: crontab</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-55-crontab/</link>
      <pubDate>Mon, 23 Jan 2017 10:44:50 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-55-crontab/</guid>
      <description>前一天学习了 at 命令是针对仅运行一次的任务，循环运行的例行性计划任务，linux系统则是由 cron (crond) 这个系统服务来控制的。Linux 系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。&#xA;crond简介# crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。&#xA;Linux下的任务调度分为两类，系统任务调度和用户任务调度。&#xA;系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。&#xA;/etc/crontab文件包括下面几行：&#xA;## /etc/crontab: system-wide crontab ## Unlike any other crontab you don&amp;#39;t have to run the `crontab&amp;#39; ## command to install the new version when you edit this file ## and files in /etc/cron.d. These files also have username fields, ## that none of the other crontabs do. SHELL=/bin/sh PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin ## m h dom mon dow user&#x9;command 17 *&#x9;* * *&#x9;root cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.</description>
    </item>
    <item>
      <title>每天一个linux命令（54）: at</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-54-at/</link>
      <pubDate>Sun, 22 Jan 2017 10:23:44 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-54-at/</guid>
      <description>在windows系统中，windows提供了计划任务这一功能，在控制面板 -&amp;gt; 性能与维护 -&amp;gt; 任务计划， 它的功能就是安排自动运行的任务。 通过&amp;rsquo;添加任务计划&amp;rsquo;的一步步引导，则可建立一个定时执行的任务。&#xA;在linux系统中你可能已经发现了为什么系统常常会自动的进行一些任务？这些任务到底是谁在支配他们工作的？在linux系统如果你想要让自己设计的备份程序可以自动在某个时间点开始在系统底下运行，而不需要手动来启动它，又该如何处置呢？ 这些例行的工作可能又分为一次性定时工作与循环定时工作，在系统内又是哪些服务在负责？ 还有，如果你想要每年在老婆的生日前一天就发出一封信件提醒自己不要忘记，linux系统下该怎么做呢？&#xA;今天我们主要学习一下一次性定时计划任务的at命令的用法！&#xA;命令格式# $ at [参数] [时间] 命令功能# 在一个指定的时间执行一个指定任务，只能执行一次，且需要开启atd进程（ps -ef | grep atd查看， 开启用/etc/init.d/atd start or restart； 开机即启动则需要运行 chkconfig &amp;ndash;level 2345 atd on）。&#xA;命令参数# 参数 描述 -m 当指定的任务被完成之后，将给用户发送邮件，即使没有标准输出 -I atq的别名 -d atrm的别名 -v 显示任务将被执行的时间 -c 打印任务的内容到标准输出 -V 显示版本信息 -q&amp;lt;列队&amp;gt; 使用指定的列队 -f&amp;lt;文件&amp;gt; 从指定文件读入任务而不是从标准输入读入 -t&amp;lt;时间参数&amp;gt; 以时间参数的形式提交要运行的任务at允许使用一套相当复杂的指定时间的方法。他能够接受在当天的hh:mm（小时:分钟）式的时间指定。假如该时间已过去，那么就放在第二天执行。当然也能够使用midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午4点）等比较模糊的 词语来指定时间。用户还能够采用12小时计时制，即在时间后面加上AM（上午）或PM（下午）来说明是上午还是下午。 也能够指定命令执行的具体日期，指定格式为month day（月 日）或mm/dd/yy（月/日/年）或dd.mm.yy（日.月.年）。指定的日期必须跟在指定时间的后面。 上面介绍的都是绝对计时法，其实还能够使用相对计时法，这对于安排不久就要执行的命令是很有好处的。指定格式为：now + count time-units ，now就是当前时间，time-units是时间单位，这里能够是minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count是时间的数量，究竟是几天，还是几小时，等等。 更有一种计时方法就是直接使用today（今天）、tomorrow（明天）来指定完成命令的时间。 TIME 时间格式，这里可以定义出什么时候要进行 at 这项任务的时间 TIME的格式： HH:MM ex&amp;gt; 04:00 在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此任务。 HH:MM YYYY-MM-DD ex&amp;gt; 04:00 2009-03-17 强制规定在某年某月的某一天的特殊时刻进行该项任务</description>
    </item>
    <item>
      <title>每天一个linux命令（53）: watch</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-53-watch/</link>
      <pubDate>Sat, 21 Jan 2017 10:12:30 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-53-watch/</guid>
      <description>watch是一个非常实用的命令，基本所有的Linux发行版都带有这个小工具，如同名字一样，watch可以帮你监测一个命令的运行结果，省得你一遍遍的手动运行。在Linux下，watch是周期性的执行下个程序，并全屏显示执行结果。你可以拿他来监测你想要的一切命令的结果变化，比如 tail 一个 log 文件，ls 监测某个文件的大小变化，看你的想象力了！&#xA;命令格式# $ watch[参数][命令] 命令功能# 可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令&#xA;命令参数# 参数 描述 -n或&amp;ndash;interval watch缺省每2秒运行一下程序，可以用-n或-interval来指定间隔的时间 -d或&amp;ndash;differences watch 会高亮显示变化的区域 -d=cumulative 会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来 -t 或-no-title 会关闭watch命令在顶部的时间间隔,命令，当前时间的输出 -h, &amp;ndash;help 查看帮助文档 使用实例# 例一：每隔一秒高亮显示网络链接数的变化情况&#xA;$ watch -n 1 -d netstat -ant 说明： 其它操作： 切换终端： Ctrl+x 退出watch：Ctrl+g (deepin系统没效果，只能使用Ctrl+c退出了)&#xA;例二：每隔一秒高亮显示http链接数的变化情况&#xA;## 每隔一秒高亮显示http链接数的变化情况。 后面接的命令若带有管道符，需要加&amp;#39;&amp;#39;将命令区域归整。 $ watch -n 1 -d &amp;#39;pstree|grep http&amp;#39; 例三：实时查看模拟攻击客户机建立起来的连接数&#xA;$ watch &amp;#39;netstat -an | grep:21 | \ grep&amp;lt;模拟攻击客户机的IP&amp;gt;| wc -l&amp;#39; 例四：监测当前目录中 scf&amp;rsquo; 的文件的变化&#xA;$ watch -d &amp;#39;ls -l|grep scf&amp;#39; 例五：10秒一次输出系统的平均负载</description>
    </item>
    <item>
      <title>每天一个linux命令（52）: ps</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-52-ps/</link>
      <pubDate>Fri, 20 Jan 2017 09:46:16 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-52-ps/</guid>
      <description>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。&#xA;要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。&#xA;ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。&#xA;kill 命令用于杀死进程。 linux上进程有5种状态:&#xA;运行(正在运行或在运行队列中等待) 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) ps工具标识进程的5种状态码: D 不可中断 uninterruptible sleep (usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (”zombie”) process&#xA;命令格式# $ ps [参数] 命令功能# 用来现实当前进程的状态&#xA;命令参数# 参数 描述 a 显示所有进程 -a 显示同一终端下的所有程序 -A 显示所有进程 c 显示进程的真实名称 -N 反向选择 -e 等于“-A” e 显示环境变量 f 显示程序间的关系 -H 显示树状结构 r 显示当前终端的进程 T 显示当前终端的所有程序 u 指定用户的所有进程 -au 显示较详细的资讯 -aux 显示所有包含其他使用者的行程 -C&amp;lt;命令&amp;gt; 列出指定命令的状况 &amp;ndash;lines&amp;lt;行数&amp;gt; 每页显示的行数 &amp;ndash;width&amp;lt;字符数&amp;gt; 每页显示的字符数 &amp;ndash;help 显示帮助信息 &amp;ndash;version 显示版本显示 使用实例# 例一：显示所有进程信息</description>
    </item>
    <item>
      <title>每天一个linux命令（51）: wc</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-51-wc/</link>
      <pubDate>Thu, 19 Jan 2017 09:33:59 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-51-wc/</guid>
      <description>　Linux系统中的wc(Word Count)命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。&#xA;命令格式# $ wc [选项]文件... 命令功能# 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。该命令统计指定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数。&#xA;命令参数# 参数 描述 -c 统计字节数 -l 统计行数 -m 统计字符数。这个标志不能与 -c 标志一起使用 -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串 -L 打印最长行的长度 -help 显示帮助信息 &amp;ndash;version 显示版本信息 使用实例# 例一：查看文件的字节数、字数、行数&#xA;$ wc 1.txt 5 19 105 1.txt 行数 单词数 字节数 文件名 例二：用wc命令怎么做到只打印统计数字不打印文件名&#xA;$ wc -l 1.txt 5 1.txt ## 5行 $ cat 1.txt | wc -l 5 ## 值输出数字 例三：用来统计当前目录下的文件和文件夹总数&#xA;## 数量中包含当前目录 $ ls -l | wc -l 10 ## 7个文件 + 2个文件夹 + 1个当前目录 </description>
    </item>
    <item>
      <title>每天一个linux命令（50）: grep</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-50-grep/</link>
      <pubDate>Wed, 18 Jan 2017 10:12:46 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-50-grep/</guid>
      <description>Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。&#xA;grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。&#xA;grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。&#xA;命令格式# $ grep [option] pattern file 命令功能# 用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。&#xA;命令参数# 参数 描述 -a &amp;ndash;text 不要忽略二进制的数据 -A&amp;lt;显示行数&amp;gt; &amp;ndash;after-context=&amp;lt;显示行数&amp;gt; 除了显示符合范本样式的那一列之外，并显示该行之后的内容 -b &amp;ndash;byte-offset 在显示符合样式的那一行之前，标示出该行第一个字符的编号 -B&amp;lt;显示行数&amp;gt; &amp;ndash;before-context=&amp;lt;显示行数&amp;gt; 除了显示符合样式的那一行之外，并显示该行之前的内容 -c &amp;ndash;count 计算符合样式的列数 -C&amp;lt;显示行数&amp;gt; &amp;ndash;context=&amp;lt;显示行数&amp;gt;或-&amp;lt;显示行数&amp;gt; 显示上下文n行 -d &amp;lt;动作&amp;gt; &amp;ndash;directories=&amp;lt;动作&amp;gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作 -e&amp;lt;范本样式&amp;gt; &amp;ndash;regexp=&amp;lt;范本样式&amp;gt; 指定字符串做为查找文件内容的样式 -E &amp;ndash;extended-regexp 将样式为延伸的普通表示法来使用 -f&amp;lt;规则文件&amp;gt; &amp;ndash;file=&amp;lt;规则文件&amp;gt; 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式 -F &amp;ndash;fixed-regexp 将样式视为固定字符串的列表 -G &amp;ndash;basic-regexp 样式视为普通的表示法来使用 -h &amp;ndash;no-filename 在显示符合样式的那一行之前，不标示该行所属的文件名称 -H &amp;ndash;with-filename 在显示符合样式的那一行之前，表示该行所属的文件名称 -i &amp;ndash;ignore-case 忽略字符的大小写 -l &amp;ndash;file-with-matches 只列出匹配的文件名 -L &amp;ndash;files-without-match 列出不匹配的文件名 -n &amp;ndash;line-number 显示行号 -q &amp;ndash;quiet或&amp;ndash;silent 不显示任何信息 -r &amp;ndash;recursive 递归查询， 此参数的效果和指定“-d recurse”参数相同 -s &amp;ndash;no-messages 不显示错误信息 -v &amp;ndash;revert-match 显示不包含匹配文本的所有行 -V &amp;ndash;version 显示版本信息 -w &amp;ndash;word-regexp 只显示全字符合的列 -x &amp;ndash;line-regexp 只显示全列符合的列 -y 此参数的效果和指定“-i”参数相同 规则表达式# grep的规则表达式 ^ #锚定行的开始 如：&#39;^grep&#39;匹配所有以grep开头的行。 $ #锚定行的结束 如：&#39;grep$&#39;匹配所有以grep结尾的行。 .</description>
    </item>
    <item>
      <title>每天一个linux命令（49）: cal</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-49-cal/</link>
      <pubDate>Tue, 17 Jan 2017 09:38:32 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-49-cal/</guid>
      <description>　cal命令可以用来显示公历（阳历）日历。公历是现在国际通用的历法，又称格列历，通称阳历。“阳历”又名“太阳历”，系以地球绕行太阳一周为一年，为西方各国所通用，故又名“西历”。&#xA;命令格式# $ cal [参数][月份][年份] 命令功能# 用于查看日历等时间信息，如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份&#xA;命令参数# 参数 描述 -1 显示一个月的月历 -3 显示系统前一个月，当前月，下一个月的月历 -s 显示星期天为一个星期的第一天，默认的格式 -m 显示星期一为一个星期的第一天 -j 显示在当年中的第几天（一年日期按天算，从1月1号算起，默认显示当前月在一年中的天数） -y 显示当前年份的日历 使用实例# 例一：显示当前月份日历&#xA;$ cal 例二：显示指定月份的日历&#xA;$ cal 6 2016 例三：显示2016年的日历&#xA;$ cal -y 2016 $ cal 2016 例四：显示自1月1日的天数&#xA;$ cal -j 例五：星期一显示在第一列&#xA;$ cal -m </description>
    </item>
    <item>
      <title>每天一个linux命令（48）: date</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-48-date/</link>
      <pubDate>Mon, 16 Jan 2017 14:39:27 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-48-date/</guid>
      <description>在linux环境中，不管是编程还是其他维护，时间是必不可少的，也经常会用到时间的运算，熟练运用date命令来表示自己想要表示的时间，肯定可以给自己的工作带来诸多方便。&#xA;命令格式# $ date [参数]... [+格式] 命令功能# date 可以用来显示或设定系统的日期与时间。&#xA;命令参数# 命令参数&#xA;参数 描述 %H 小时(以00-23来表示) %I 小时(以01-12来表示) %K 小时(以0-23来表示) %l 小时(以0-12来表示) %M 分钟(以00-59来表示) %P AM或PM %r 时间(含时分秒，小时以12小时AM/PM来表示) %s 总秒数。起算时间为1970-01-01 00:00:00 UTC %S 秒(以本地的惯用法来表示) %T 时间(含时分秒，小时以24小时制来表示) %X 时间(以本地的惯用法来表示) %Z 市区 %a 星期的缩写 %A 星期的完整名称 %b 月份英文名的缩写 %B 月份的完整英文名称 %c 日期与时间。只输入date指令也会显示同样的结果 %d 日期(以01-31来表示) %D 日期(含年月日) %j 该年中的第几天 %m 月份(以01-12来表示) %U 该年中的周数 %w 该周的天数，0代表周日，1代表周一，异词类推 %x 日期(以本地的惯用法来表示) %y 年份(以00-99来表示) %Y 年份(以四位数来表示) %n 在显示时，插入新的一行 %t 在显示时，插入tab MM 月份(必要) DD 日期(必要) hh 小时(必要) mm 分钟(必要) ss 秒(选择性) 选择参数</description>
    </item>
    <item>
      <title>每天一个linux命令（47）: diff</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-47-diff/</link>
      <pubDate>Sun, 15 Jan 2017 14:08:08 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-47-diff/</guid>
      <description>diff 命令是 linux上非常重要的工具，用于比较文件的内容，特别是比较两个版本不同的文件以找到改动的地方。diff在命令行中打印每一个行的改动。最新版本的diff还支持二进制文件。diff程序的输出被称为补丁 (patch)，因为Linux系统中还有一个patch程序，可以根据diff的输出将a.c的文件内容更新为b.c。diff是svn、cvs、git等版本控制工具不可或缺的一部分。&#xA;命令格式# $ diff [参数] [文件1或目录1] [文件2或目录2] 命令功能# diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。&#xA;命令参数# 参数 描述 - 指定要显示多少行的文本。此参数必须与-c或-u参数一并使用 -a或&amp;ndash;text diff预设只会逐行比较文本文件 -b或&amp;ndash;ignore-space-change 不检查空格字符的不同 -B或&amp;ndash;ignore-blank-lines 不检查空白行 -c 显示全部内文，并标出不同之处 -C或&amp;ndash;context 与执行&amp;quot;-c&amp;quot;指令相同 -d或&amp;ndash;minimal 使用不同的演算法，以较小的单位来做比较 -D或ifdef 此参数的输出格式可用于前置处理器巨集 -e或&amp;ndash;ed 此参数的输出格式可用于ed的script文件 -f或-forward-ed 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处 -H或&amp;ndash;speed-large-files 比较大文件时，可加快速度 -l或&amp;ndash;ignore-matching-lines 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异 -i或&amp;ndash;ignore-case 不检查大小写的不同 -l或&amp;ndash;paginate 将结果交由pr程序来分页 -n或&amp;ndash;rcs 将比较结果以RCS的格式来显示 -N或&amp;ndash;new-file 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较 -p 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称 -P或&amp;ndash;unidirectional-new-file 与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较 -q或&amp;ndash;brief 仅显示有无差异，不显示详细的信息 -r或&amp;ndash;recursive 比较子目录中的文件 -s或&amp;ndash;report-identical-files 若没有发现任何差异，仍然显示信息 -S或&amp;ndash;starting-file 在比较目录时，从指定的文件开始比较 -t或&amp;ndash;expand-tabs 在输出时，将tab字符展开 -T或&amp;ndash;initial-tab 在每行前面加上tab字符以便对齐 -u,-U或&amp;ndash;unified= 以合并的方式来显示文件内容的不同 -v或&amp;ndash;version 显示版本信息 -w或&amp;ndash;ignore-all-space 忽略全部的空格字符 -W或&amp;ndash;width 在使用-y参数时，指定栏宽 -x或&amp;ndash;exclude 不比较选项中所指定的文件或目录 -X或&amp;ndash;exclude-from 您可以将文件或目录类型存成文本文件，然后在=中指定此文本文件 -y或&amp;ndash;side-by-side 以并列的方式显示文件的异同之处 &amp;ndash;left-column 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容 &amp;ndash;suppress-common-lines 在使用-y参数时，仅显示不同之处 &amp;ndash;help 显示帮助 使用实例# 例一：比较两个文件</description>
    </item>
    <item>
      <title>每天一个linux命令（46）: ln</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-46-ln/</link>
      <pubDate>Sat, 14 Jan 2017 11:00:33 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-46-ln/</guid>
      <description>ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。&#xA;命令格式# $ ln [参数][源文件或目录][目标文件或目录] 命令功能# Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。 软连接 1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 2.软链接可以 跨文件系统 ，硬链接不可以 3.软链接可以对一个不存在的文件名进行链接 4.软链接可以对目录进行链接 硬链接 1.硬链接，以文件副本的形式存在。但不占用实际空间。 2.不允许给目录创建硬链接 3.硬链接只有在同一个文件系统中才能创建 两点注意 第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化； 第二，ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。&#xA;命令参数# 必要参数&#xA;参数 描述 -b 删除，覆盖以前建立的链接 -d 允许超级用户制作目录的硬链接 -f 强制执行 -i 交互模式，文件存在则提示用户是否覆盖 -n 把符号链接视为一般目录 -s 软链接(符号链接) -v 显示详细的处理过程 选择参数&#xA;参数 描述 -S “-S&amp;lt;字尾备份字符串&amp;gt; ”或 “&amp;ndash;suffix=&amp;lt;字尾备份字符串&amp;gt;” -V “-V&amp;lt;备份方式&amp;gt;”或“&amp;ndash;version-control=&amp;lt;备份方式&amp;gt;” &amp;ndash;help 显示帮助信息 &amp;ndash;version 显示版本信息 使用实例# 例一：给文件创建软链接&#xA;## 为2.txt文件创建软链接2，如果2.txt丢失，2将失效 $ ln -s 2.</description>
    </item>
    <item>
      <title>每天一个linux命令（45）: scp</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-45-scp/</link>
      <pubDate>Fri, 13 Jan 2017 10:53:48 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-45-scp/</guid>
      <description>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。&#xA;命令格式# $ scp [参数] [原路径] [目标路径] 命令功能# scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。&#xA;命令参数# 参数 描述 -1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 保留原文件的修改时间，访问时间和访问权限 -q 不显示传输进度条 -r 递归复制整个目录 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh -l limit 限定用户所能使用的带宽，以Kbit/s为单位 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式 -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项 使用实例# 从本地服务器复制到远程服务器：&#xA;## 指定了用户名，命令执行后需输入密码 $ scp -r img/* root@server:/var/project/img/ ## 没有指定用户名，命令执行后需要输入用户名密码 $ scp -r img/* server:/var/project/img/ 从远程服务器复制到本地当前目录：</description>
    </item>
    <item>
      <title>每天一个linux命令（44）: rcp</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-44-rcp/</link>
      <pubDate>Thu, 12 Jan 2017 10:36:06 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-44-rcp/</guid>
      <description>rcp代表“remote file copy”（远程文件拷贝）。该命令用于在计算机之间拷贝文件。rcp命令有两种格式。第一种格式用于文件到文件的拷贝；第二种格式用于把文件或目录拷贝到另一个目录中。&#xA;命令格式# $ rcp [参数] [源文件] [目标文件] 命令功能# rcp命令用在远端复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中。&#xA;命令参数# 命令 描述 -r 递归地把源目录中的所有内容拷贝到目的目录中。要使用这个选项，目的必须是一个目录 -p 试图保留源文件的修改时间和模式，忽略umask -k 请求rcp获得在指定区域内的远程主机的Kerberos 许可，而不是获得由krb_relmofhost⑶确定的远程主机区域内的远程主机的Kerberos许可。 -x 为传送的所有数据打开DES加密。这会影响响应时间和CPU利用率，但是可以提高安全性。如果在文件名中指定的路径不是完整的路径名，那么这个路径被解释为相对远程机上同名用户的主目录。如果没有给出远程用户名，就使用当前用户名。如果远程机上的路径包含特殊shell字符，需要用反斜线（\）、双引号（”）或单引号（’）括起来，使所有的shell元字符都能被远程地解释。需要说明的是，rcp不提示输入口令，它通过rsh命令来执行拷贝。 directory 每个文件或目录参数既可以是远程文件名也可以是本地文件名。远程文件名具有如下形式：rname@rhost：path，其中rname是远程用户名，rhost是远程计算机名，path是这个文件的路径。 使用实例# 使用rcp，需要具备的条件 如果系统中有 /etc/hosts 文件，系统管理员应确保该文件包含要与之进行通信的远程主机的项。 /etc/hosts 文件中有一行文字，其中包含每个远程系统的以下信息： internet_address official_name alias 例如： 9.186.10.*** webserver1.com.58.webserver .rhosts 文件 .rhosts 文件位于远程系统的主目录下，其中包含本地系统的名称和本地登录名。 例如，远程系统的 .rhosts 文件中的项可能是： webserver1 root 其中，webserver1 是本地系统的名称，root 是本地登录名。这样，webserver1 上的 root 即可在包含.rhosts 文件的远程系统中来回复制文件。 配置过程: 只对root用户生效&#xA;在双方root用户根目录下建立.rhosts文件,并将双方的hostname加进去.在此之前应在双方的 /etc/hosts文件中加入对方的IP和hostname&#xA;把rsh服务启动起来,redhat默认是不启动的。 方法：用执行ntsysv命令,在rsh选项前用空格键选中,确定退出。然后执行： service xinetd restart即可。&#xA;3.到/etc/pam.d/目录下,把rsh文件中的auth required /lib/security/pam_securetty.so 一行用“#”注释掉即可。（只有注释掉这一行，才能用root用户登录）&#xA;例一：将本地img文件夹内的所有内容 复制到服务器相应的img目录下</description>
    </item>
    <item>
      <title>每天一个linux命令（43）: telnet</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-43-telnet/</link>
      <pubDate>Thu, 12 Jan 2017 09:24:01 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-43-telnet/</guid>
      <description>telnet命令通常用来远程登录。telnet程序是基于TELNET协议的远程登录客户端程序。Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的 能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。&#xA;但是，telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。&#xA;telnet命令还可做别的用途，比如确定远程服务的状态，比如确定远程服务器的某个端口是否能访问。&#xA;命令格式# $ telnet [参数][主机] 命令功能# 执行telnet指令开启终端机阶段作业，并登入远端主机。&#xA;命令参数# 命令 描述 -8 允许使用8位字符资料，包括输入与输出 -a 尝试自动登入远端系统 -b&amp;lt;主机别名&amp;gt; 使用别名指定远端主机名称 -c 不读取用户专属目录里的.telnetrc文件 -d 启动排错模式 -e&amp;lt;脱离字符&amp;gt; 设置脱离字符 -E 滤除脱离字符 -f 此参数的效果和指定&amp;quot;-F&amp;quot;参数相同 -F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机 -k&amp;lt;域名&amp;gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名 -K 不自动登入远端主机 -l&amp;lt;用户名称&amp;gt; 指定要登入远端主机的用户名称 -L 允许输出8位字符资料 -n&amp;lt;记录文件&amp;gt; 指定文件记录相关信息 -r 使用类似rlogin指令的用户界面 -S&amp;lt;服务类型&amp;gt; 设置telnet连线所需的IP TOS信息 -x 假设主机有支持数据加密的功能，就使用它 -X&amp;lt;认证形态&amp;gt; 关闭指定的认证形态 使用实例# 例一：远程服务器无法访问&#xA;$ telnet 192.168.120.206 Trying 192.168.120.209... telnet: connect to address 192.168.120.209: No route to host telnet: Unable to connect to remote host: No route to host 说明： 处理这种情况方法： （1）确认ip地址是否正确？ （2）确认ip地址对应的主机是否已经开机？ （3）如果主机已经启动，确认路由设置是否设置正确？（使用route命令查看） （4）如果主机已经启动，确认主机上是否开启了telnet服务？（使用netstat命令查看，TCP的23端口是否有LISTEN状态的行） （5）如果主机已经启动telnet服务，确认防火墙是否放开了23端口的访问？（使用iptables-save查看）</description>
    </item>
    <item>
      <title>每天一个linux命令（42）: ss</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-42-ss/</link>
      <pubDate>Wed, 11 Jan 2017 10:34:47 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-42-ss/</guid>
      <description>ss是Socket Statistics的缩写。顾名思义，ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。&#xA;当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。可能你不会有切身的感受，但请相信我，当服务器维持的连接达到上万个的时候，使用netstat等于浪费 生命，而用ss才是节省时间。&#xA;天下武功唯快不破。ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢。（但仍然比 netstat要快。）&#xA;命令格式# $ ss [参数] $ ss[参数] [过滤] 命令功能# ss(Socket Statistics的缩写)命令可以用来获取 socket统计信息，此命令输出的结果类似于 netstat输出的内容，但它能显示更多更详细的 TCP连接状态的信息，且比 netstat 更快速高效。它使用了 TCP协议栈中 tcp_diag（是一个用于分析统计的模块），能直接从获得第一手内核信息，这就使得 ss命令快捷高效。在没有 tcp_diag，ss也可以正常运行。&#xA;命令参数# 命令 描述 -h, &amp;ndash;help 帮助信息 -V, &amp;ndash;version 程序版本信息 -n, &amp;ndash;numeric 不解析服务名称 -r, &amp;ndash;resolve 解析主机名 -a, &amp;ndash;all 显示所有套接字（sockets） -l, &amp;ndash;listening 显示监听状态的套接字（sockets） -o, &amp;ndash;options 显示计时器信息 -e, &amp;ndash;extended 显示详细的套接字（sockets）信息 -m, &amp;ndash;memory 显示套接字（socket）的内存使用情况 -p, &amp;ndash;processes 显示使用套接字（socket）的进程 -i, &amp;ndash;info 显示 TCP内部信息 -s, &amp;ndash;summary 显示套接字（socket）使用概况 -4, &amp;ndash;ipv4 仅显示IPv4的套接字（sockets） -6, &amp;ndash;ipv6 仅显示IPv6的套接字（sockets） -0, &amp;ndash;packet 显示 PACKET 套接字（socket） -t, &amp;ndash;tcp 仅显示 TCP套接字（sockets） -u, &amp;ndash;udp 仅显示 UCP套接字（sockets） -d, &amp;ndash;dccp 仅显示 DCCP套接字（sockets） -w, &amp;ndash;raw 仅显示 RAW套接字（sockets） -x, &amp;ndash;unix 仅显示 Unix套接字（sockets） -f, &amp;ndash;family=FAMILY 显示 FAMILY类型的套接字（sockets），FAMILY可选，支持 unix, inet, inet6, link, netlink -A, &amp;ndash;query=QUERY, &amp;ndash;socket=QUERYQUERY := {all inet -D, &amp;ndash;diag=FILE 将原始TCP套接字（sockets）信息转储到文件 -F, &amp;ndash;filter=FILE 从文件中都去过滤器信息 FILTER := [ state TCP-STATE ] [ EXPRESSION ] 使用实例# 例一：显示TCP连接</description>
    </item>
    <item>
      <title>每天一个linux命令（41）: netstat</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-41-netstat/</link>
      <pubDate>Tue, 10 Jan 2017 09:54:16 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-41-netstat/</guid>
      <description>netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。&#xA;如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用netstat查一查为什么会出现这些情况了。&#xA;命令格式# $ netstat [-acCeFghilMnNoprstuvVwx][-A&amp;lt;网络类型&amp;gt;][--ip] 命令功能# netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。&#xA;命令参数# 命令 描述 -a或–all 显示所有连线中的Socket -A&amp;lt;网络类型&amp;gt;或–&amp;lt;网络类型&amp;gt; 列出该网络类型连线中的相关地址 -c或–continuous 持续列出网络状态 -C或–cache 显示路由器配置的快取信息 -e或–extend 显示网络其他相关信息 -F或–fib 显示FIB -g或–groups 显示多重广播功能群组组员名单 -h或–help 在线帮助 -i或–interfaces 显示网络界面信息表单 -l或–listening 显示监控中的服务器的Socket -M或–masquerade 显示伪装的网络连线 -n或–numeric 直接使用IP地址，而不通过域名服务器 -N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称 -o或–timers 显示计时器 -p或–programs 显示正在使用Socket的程序识别码和程序名称 -r或–route 显示Routing Table -s或–statistice 显示网络工作信息统计表 -t或–tcp 显示TCP传输协议的连线状况 -u或–udp 显示UDP传输协议的连线状况 -v或–verbose 显示指令执行过程 -V或–version 显示版本信息 -w或–raw 显示RAW传输协议的连线状况 -x或–unix 此参数的效果和指定”-A unix”参数相同 –ip或–inet 此参数的效果和指定”-A inet”参数相同 使用实例# 例一：无参数使用&#xA;$ netstat Active Internet connections (w/o servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 268 192.</description>
    </item>
    <item>
      <title>每天一个linux命令（40）: traceroute</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-40-traceroute/</link>
      <pubDate>Mon, 09 Jan 2017 10:56:53 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-40-traceroute/</guid>
      <description>通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。&#xA;在大多数情况下，我们会在linux主机系统下，直接执行命令行： traceroute hostname 而在Windows系统下是执行tracert的命令： tracert hostname&#xA;命令格式# $ traceroute [参数] [主机] 命令功能# traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。 具体参数格式：traceroute [-dFlnrvx][-f&amp;lt;存活数值&amp;gt;][-g&amp;lt;网关&amp;gt;&amp;hellip;][-i&amp;lt;网络界面&amp;gt;][-m&amp;lt;存活数值&amp;gt;][-p&amp;lt;通信端口&amp;gt;][-s&amp;lt;来源地址&amp;gt;][-t&amp;lt;服务类型&amp;gt;][-w&amp;lt;超时秒数&amp;gt;][主机名称或IP地址][数据包大小]&#xA;命令参数# 命令 描述 -d 使用Socket层级的排错功能 -f 设置第一个检测数据包的存活数值TTL的大小 -F 设置勿离断位 -g 设置来源路由网关，最多可设置8个 -i 使用指定的网络界面送出数据包 -I 使用ICMP回应取代UDP资料信息 -m 设置检测数据包的最大存活数值TTL的大小 -n 直接使用IP地址而非主机名称 -p 设置UDP传输协议的通信端口 -r 忽略普通的Routing Table，直接将数据包送到远端主机上 -s 设置本地主机送出数据包的IP地址 -t 设置检测数据包的TOS数值 -v 详细显示指令的执行过程 -w 设置等待远端主机回报的时间 -x 开启或关闭数据包的正确性检验 使用实例# 例一：traceroute 用法简单、最常用的用法&#xA;$ traceroute yelog.github.com traceroute to yelog.github.com (151.101.192.133), 30 hops max, 60 byte packets 1 vrouter (192.</description>
    </item>
    <item>
      <title>每天一个linux命令（39）: ping</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-39-ping/</link>
      <pubDate>Sun, 08 Jan 2017 10:24:50 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-39-ping/</guid>
      <description>Linux系统的ping命令是常用的网络命令，它通常用来测试与目标主机的连通性，我们经常会说“ping一下某机器，看是不是开着”、不能打开网页时会说“你先ping网关地址192.168.1.1试试”。它通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。&#xA;linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数。&#xA;命令格式# $ ping [参数] [主机名或IP地址] 命令功能# ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。 ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。&#xA;命令参数# 命令 描述 -d 使用Socket的SO_DEBUG功能 -f 极限检测。大量且快速地送网络封包给一台机器，看它的回应 -n 只输出数值 -q 不显示任何传送封包的信息，只显示最后的结果 -r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题 -R 记录路由过程 -v 详细显示指令的执行过程 -c 数目 在发送指定数目的包后停止 -i 秒数 设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次 -I 网络界面 使用指定的网络界面送出数据包 -l 前置载入 设置在送出要求信息之前，先行发出的数据包 -p 范本样式 设置填满数据包的范本样式 -s 字节数 指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节 -t 存活数值 设置存活数值TTL的大小 使用实例# 例一：ping通的情况&#xA;$ ping 192.</description>
    </item>
    <item>
      <title>每天一个linux命令（38）: route</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-38-route/</link>
      <pubDate>Sat, 07 Jan 2017 10:16:34 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-38-route/</guid>
      <description>Linux系统的route命令用于显示和操作IP路由表（show / manipulate the IP routing table）。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。&#xA;命令格式# route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 命令功能# Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用&amp;quot;add&amp;quot;或者&amp;quot;del&amp;quot;参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。&#xA;命令参数# 命令 描述 -c 显示更多信息 -n 不解析名字 -v 显示详细的处理信息 -F 显示发送信息 -C 显示路由缓存 -f 清除所有网关入口的路由表 -p 与 add 命令 -p 与 add 命令一起使用时使路由具有永久性。 add 添加一条新路由 del 删除一条路由 -net 目标地址是一个网络 -host 目标地址是一个主机 netmask 当添加一个网络路由时，需要使用网络掩码 gw 路由数据包通过网关。注意，你指定的网关必须能够达到 metric 设置路由跳数 Command 指定您想运行的命令 (Add/Change/Delete/Print) Destination 指定该路由的网络目标 mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码） Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址 metric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表(与转发的数据包目标地址最匹配)的多个路由中进行选择时可以使用 if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引 使用实例# 例一：显示当前路由</description>
    </item>
    <item>
      <title>每天一个linux命令（37）: ifconfig</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-37-ifconfig/</link>
      <pubDate>Fri, 06 Jan 2017 09:57:01 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-37-ifconfig/</guid>
      <description>许多windows非常熟悉ipconfig命令行工具，它被用来获取网络接口配置信息并对此进行修改。Linux系统拥有一个类似的工具，也就是ifconfig(interfaces config)。通常需要以root身份登录或使用sudo以便在Linux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息，还可以修改这些配置。&#xA;命令格式# $ ifconfig [网络设备] [参数] 命令功能# ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。&#xA;注意： 用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。&#xA;命令参数# 命令 描述 up 启动指定网络设备/网卡 down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除 arp 设置指定网卡是否支持ARP协议 -promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包 -allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包 -a 显示全部接口信息 -s 显示摘要信息（类似于 netstat -i） add 给指定网卡配置IPv6地址 del 删除指定网卡的IPv6地址 &amp;lt;硬件地址&amp;gt; 配置网卡最大的传输单元 mtu&amp;lt;字节数&amp;gt; 设置网卡的最大传输单元 (bytes) netmask&amp;lt;子网掩码&amp;gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码 tunel 建立隧道 dstaddr 设定一个远端地址，建立点对点通信 -broadcast&amp;lt;地址&amp;gt; 为指定网卡设置广播协议 -pointtopoint&amp;lt;地址&amp;gt; 为网卡设置点对点通讯协议 multicast 为网卡设置组播标志 address 为网卡设置IPv4地址 txqueuelen&amp;lt;长度&amp;gt; 为网卡设置传输列队的长度 使用实例# 例一：显示网络设备信息（激活状态的）&#xA;$ ifconfig 说明： eth0 表示第一块网卡， 其中 HWaddr 表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是 00:50:56:BF:26:20 inet addr 用来表示网卡的IP地址，此网卡的 IP地址是 192.</description>
    </item>
    <item>
      <title>每天一个linux命令（36）: lsof</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-36-lsof/</link>
      <pubDate>Thu, 05 Jan 2017 10:28:13 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-36-lsof/</guid>
      <description>lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。&#xA;命令格式# $ lsof [参数][文件] 命令功能# 用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为 lsof 需要访问核心内存和各种文件，所以需要root用户执行。 lsof打开的文件可以是：&#xA;普通文件 目录 网络文件系统的文件 字符或设备文件 (函数)共享库 管道，命名管道 符号链接 网络文件（例如：NFS file、网络socket，unix域名socket） 还有其它类型的文件，等等 命令参数# 命令 描述 -a 列出打开文件存在的进程 -c&amp;lt;进程名&amp;gt; 列出指定进程所打开的文件 -g 列出GID号进程详情 -d&amp;lt;文件号&amp;gt; 列出占用该文件号的进程 +d&amp;lt;目录&amp;gt; 列出目录下被打开的文件 +D&amp;lt;目录&amp;gt; 递归列出目录下被打开的文件 -n&amp;lt;目录&amp;gt; 列出使用NFS的文件 -i&amp;lt;条件&amp;gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ） -p&amp;lt;进程号&amp;gt; 列出指定进程号所打开的文件 -u 列出UID号进程详情 -h 显示帮助信息 -v 显示版本信息 使用实例# 例一：无任何参数&#xA;$ lsof COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME init 1 root cwd DIR 8,2 4096 2 / init 1 root rtd DIR 8,2 4096 2 / init 1 root txt REG 8,2 43496 6121706 /sbin/init init 1 root mem REG 8,2 143600 7823908 /lib64/ld-2.</description>
    </item>
    <item>
      <title>每天一个linux命令（35）: iostat</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-35-iostat/</link>
      <pubDate>Wed, 04 Jan 2017 10:10:02 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-35-iostat/</guid>
      <description>Linux系统中的 iostat是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。iostat属于sysstat软件包。可以用yum install sysstat 直接安装。&#xA;命令格式# $ iostat [参数][时间][次数] 命令功能# 通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况,&#x9;负载信息。&#xA;命令参数# 命令 描述 -C 显示CPU使用情况 -d 显示磁盘使用情况 -k 以 KB 为单位显示 -m 以 M 为单位显示 -N 显示磁盘阵列(LVM) 信息 -n 显示 NFS 使用情况 -p[磁盘] 显示磁盘和分区的情况 -t 显示终端和CPU的信息 -x 显示详细信息 -V 显示版本信息 使用实例# 例一：显示所有设备负载情况&#xA;$ iostat Linux 3.10.0-327.el7.x86_64 (s88) 2017年01月22日 _x86_64_&#x9;(24 CPU) avg-cpu: %user %nice %system %iowait %steal %idle 0.62 0.00 0.20 1.46 0.00 97.72 Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtn sda 64.</description>
    </item>
    <item>
      <title>每天一个linux命令（34）: vmstat</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-34-vmstat/</link>
      <pubDate>Tue, 03 Jan 2017 09:46:57 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-34-vmstat/</guid>
      <description>vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写，可对操作系统的虚拟内存、进程、CPU活动进行监控。他是对系统的整体情况进行统计，不足之处是无法对某个进程进行深入分析。vmstat 工具提供了一种低开销的系统性能观察方式。因为 vmstat 本身就是低开销工具，在非常高负荷的服务器上，你需要查看并监控系统的健康情况,在控制窗口还是能够使用vmstat 输出结果。在学习vmstat命令前，我们先了解一下Linux系统中关于物理内存和虚拟内存相关信息。&#xA;物理内存和虚拟内存区别# 我们知道，直接从物理内存读写数据要比从硬盘读写数据要快的多，因此，我们希望所有数据的读取和写入都在内存完成，而内存是有限的，这样就引出了物理内存与虚拟内存的概念。&#xA;物理内存就是系统硬件提供的内存大小，是真正的内存，相对于物理内存，在linux下还有一个虚拟内存的概念，虚拟内存就是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间被称为交换空间（Swap Space）。&#xA;作为物理内存的扩展，linux会在物理内存不足时，使用交换分区的虚拟内存，更详细的说，就是内核会将暂时不用的内存块信息写到交换空间，这样以来，物理内存得到了释放，这块内存就可以用于其它目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。&#xA;linux的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。&#xA;要深入了解linux内存运行机制，需要知道下面提到的几个方面：&#xA;首先，Linux系统会不时的进行页面交换操作，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，Linux也会交换出暂时不用的内存页面。这可以避免等待交换所需的时间。&#xA;其次，linux进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，linux内核根据”最近最经常使用“算法，仅仅将一些不经常使用的页面文件交换到虚拟内存，有时我们会看到这么一个现象：linux物理内存还有很多，但是交换空间也使用了很多。其实，这并不奇怪，例如，一个占用很大内存的进程运行时，需要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存时，刚才被交换出去的页面文件并不会自动的交换进物理内存，除非有这个必要，那么此刻系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。关于这点，不用担心什么，只要知道是怎么一回事就可以了。&#xA;最后，交换空间的页面在使用时会首先被交换到物理内存，如果此时没有足够的物理内存来容纳这些页面，它们又会被马上交换出去，如此以来，虚拟内存中可能没有足够空间来存储这些交换页面，最终会导致linux出现假死机、服务异常等问题，linux虽然可以在一段时间内自行恢复，但是恢复后的系统已经基本不可用了。&#xA;因此，合理规划和设计linux内存的使用，是非常重要的。&#xA;虚拟内存原理：# 在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物理内存，将这部分资料存储在磁盘上直到进程下一次调用，并将释放出的内存提供给有需要的进程使用。&#xA;在Linux内存管理中，主要是通过“调页Paging”和“交换Swapping”来完成上述的内存调度。调页算法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整个进程，而不是部分页面，全部交换到磁盘上。&#xA;分页(Page)写入磁盘的过程被称作Page-Out，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误（Page Fault）。&#xA;当系统内核发现可运行内存变少时，就会通过Page-Out来释放一部分物理内存。经管Page-Out不是经常发生，但是如果Page-out频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系统效能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态亦被称作thrashing(颠簸)。&#xA;命令格式# $ vmstat [-a] [-n] [-S unit] [delay [ count]] $ vmstat [-s] [-n] [-S unit] $ vmstat [-m] [-n] [delay [ count]] $ vmstat [-d] [-n] [delay [ count]] $ vmstat [-p disk partition] [-n] [delay [ count]] $ vmstat [-f] $ vmstat [-V] 命令功能# 用来显示虚拟内存的信息</description>
    </item>
    <item>
      <title>每天一个linux命令（33）: free</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-33-free/</link>
      <pubDate>Mon, 02 Jan 2017 21:43:26 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-33-free/</guid>
      <description>　free命令可以显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer。在Linux系统监控的工具中，free命令是最经常使用的命令之一。&#xA;命令格式# $ free [参数] 命令功能# free 命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。共享内存将被忽略&#xA;命令参数# 命令 描述 -b 以Byte为单位显示内存使用情况 -k 以KB为单位显示内存使用情况 -m 以MB为单位显示内存使用情况 -g 以GB为单位显示内存使用情况 -o 不显示缓冲区调节列 -s&amp;lt;间隔秒数&amp;gt; 持续观察内存使用状况 -t 显示内存总和列 -V 显示版本信息 使用实例# 例一：显示内存使用情况&#xA;$ free total used free shared buff/cache available Mem: 12095180 8362640 198460 1379116 3534080 2100004 Swap: 8185112 40008 8145104 说明： total:总计物理内存的大小。 used:已使用多大。 free:可用有多少。 Shared:多个进程共享的内存总额。 Buffers/cached:磁盘缓存的大小。&#xA;例二：显示内存使用情况&#xA;$ free -t 例三：周期性的查询内存使用信息&#xA;## 每10s 执行一次命令 $ free -s 10 </description>
    </item>
    <item>
      <title>每天一个linux命令（32）: top</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-32-top/</link>
      <pubDate>Sun, 01 Jan 2017 19:31:28 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-32-top/</guid>
      <description>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。下面详细介绍它的使用方法。top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。&#xA;命令格式# $ top [参数] 命令功能# 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等&#xA;命令参数# 参数 描述 -b 批处理 -c 显示完整的治命令 -I 忽略失效过程 -s 保密模式 -S 累积模式 -i&amp;lt;时间&amp;gt; 设置间隔时间 -u&amp;lt;用户名&amp;gt; 指定用户名 -p&amp;lt;进程号&amp;gt; 指定进程 -n&amp;lt;次数&amp;gt; 循环显示的次数 top交互命令# 在top 命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了s 选项， 其中一些命令可能会被屏蔽。&#xA;参数 描述 h 显示帮助画面，给出一些简短的命令总结说明 k 终止一个进程。 i 忽略闲置和僵死进程。这是一个开关式命令 q 退出程序 r 重新安排一个进程的优先级别 S 切换到累计模式 s 改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s f或者F 从当前显示中添加或者删除项目 o或者O 改变显示项目的顺序 l 切换显示平均负载和启动时间信息 m 切换显示内存信息 t 切换显示进程和CPU状态信息 c 切换显示命令名称和完整命令行 M 根据驻留内存大小进行排序 P 根据CPU使用百分比大小进行排序 T 根据时间/累计时间进行排序 W 将当前设置写入~/.</description>
    </item>
    <item>
      <title>每天一个linux命令（31）: du</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-31-du/</link>
      <pubDate>Sat, 31 Dec 2016 14:36:01 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-31-du/</guid>
      <description>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的.&#xA;命令格式# $ du [选项][文件] 命令功能# 显示每个文件和目录的磁盘使用空间。&#xA;命令参数# 参数 描述 -a或-all 显示目录中个别文件的大小。 -b或-bytes 显示目录或文件大小时，以byte为单位。 -c或&amp;ndash;total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 -k或&amp;ndash;kilobytes 以KB(1024bytes)为单位输出。 -m或&amp;ndash;megabytes 以MB为单位输出。 -s或&amp;ndash;summarize 仅显示总计，只列出最后加总的值。 -h或&amp;ndash;human-readable 以K，M，G为单位，提高信息的可读性。 -x或&amp;ndash;one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。 -L&amp;lt;符号链接&amp;gt;或&amp;ndash;dereference&amp;lt;符号链接&amp;gt; 显示选项中所指定符号链接的源文件大小。 -S或&amp;ndash;separate-dirs 显示个别目录的大小时，并不含其子目录的大小。 -X&amp;lt;文件&amp;gt;或&amp;ndash;exclude-from=&amp;lt;文件&amp;gt; 在&amp;lt;文件&amp;gt;指定目录或文件。 &amp;ndash;exclude=&amp;lt;目录或文件&amp;gt; 略过指定的目录或文件。 -D或&amp;ndash;dereference-args 显示指定符号链接的源文件大小。 -H或&amp;ndash;si 与-h参数相同，但是K，M，G是以1000为换算单位。 -l或&amp;ndash;count-links 重复计算硬件链接的文件。 使用实例# 例一：显示目录或者文件所占空间&#xA;$ du 说明： 只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的1288为当前目录的总大小&#xA;例二：显示指定文件所占空间&#xA;$ du log2012.log 例三：查看指定目录的所占空间&#xA;$ du scf 例四：显示多个文件所占空间&#xA;$ du log30.tar.gz log31.tar.gz 例五：只显示总和的大小&#xA;$ du -s 例六：方便阅读的格式显示&#xA;$ du -h test 例七：文件和目录都显示</description>
    </item>
    <item>
      <title>每天一个linux命令（30）: df</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-30-df/</link>
      <pubDate>Fri, 30 Dec 2016 14:23:31 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-30-df/</guid>
      <description>linux中df命令的功能是用来检查linux服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。&#xA;命令格式# $ df [选项] [文件] 命令功能# 显示指定磁盘文件的可用空间。如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示&#xA;命令参数# 必要参数&#xA;参数 描述 -a 全部文件系统列表 -h 方便阅读方式显示 -H 等于“-h”，但是计算式，1K=1000，而不是1K=1024 -i 显示inode信息 -k 区块为1024字节 -l 只显示本地文件系统 -m 区块为1048576字节 &amp;ndash;no-sync 忽略 sync 命令 -P 输出格式为POSIX &amp;ndash;sync 在取得磁盘信息前，先执行sync命令 -T 文件系统类型 选择参数&#xA;参数 描述 &amp;ndash;block-size=&amp;lt;区块大小&amp;gt; 指定区块大小 -t&amp;lt;文件系统类型&amp;gt; 只显示选定文件系统的磁盘信息 -x&amp;lt;文件系统类型&amp;gt; 不显示选定文件系统的磁盘信息 &amp;ndash;help 显示帮助信息 &amp;ndash;version 显示版本信息 使用实例# 例一：显示磁盘使用情况&#xA;$ df 说明： linux中df命令的输出清单的第1列是代表文件系统对应的设备文件的路径名（一般是硬盘上的分区）；第2列给出分区包含的数据块（1024字节）的数目；第3，4列分别表示已用的和可用的数据块数目。用户也许会感到奇怪的是，第3，4列块数之和不等于第2列中的块数。这是因为缺省的每个分区都留了少量空间供系统管理员使用。即使遇到普通用户空间已满的情况，管理员仍能登录和留有解决问题所需的工作空间。清单中Use% 列表示普通用户空间使用的百分比，即使这一数字达到100％，分区仍然留有系统管理员使用的空间。最后，Mounted on列表示文件系统的挂载点。&#xA;例二：以inode模式来显示磁盘使用情况&#xA;$ df -i 例三：显示指定类型磁盘&#xA;$ df -t ext3 例四：列出各文件系统的i节点使用情况</description>
    </item>
    <item>
      <title>每天一个linux命令（29）: /etc/group文件详解</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-29-group/</link>
      <pubDate>Thu, 29 Dec 2016 14:13:05 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-29-group/</guid>
      <description>Linux /etc/group文件与/etc/passwd和/etc/shadow文件都是有关于系统管理员对用户和用户组管理时相关的文件。linux /etc/group文件是有关于系统管理员对用户和用户组管理的文件,linux用户组的所有信息都存放在/etc/group文件中。具有某种共同特征的用户集合起来就是用户组（Group）。用户组（Group）配置文件主要有 /etc/group和/etc/gshadow，其中/etc/gshadow是/etc/group的加密信息文件。&#xA;将用户分组是Linux系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不 同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。&#xA;用户组的所有信息都存放在/etc/group文件中。此文件的格式是由冒号(:)隔开若干个字段，这些字段具体如下：&#xA;组名:口令:组标识号:组内用户列表&#xA;解释# 组名： 组名是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。 口令： 口令字段存放的是用户组加密后的口令字。一般Linux系统的用户组都没有口令，即这个字段一般为空，或者是*。 组标识号： 组标识号与用户标识号类似，也是一个整数，被系统内部用来标识组。别称GID. 组内用户列表： 是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。&#xA;使用实例# $ cat /etc/group 说明： 我们以root:x:0:root,linuxsir 为例： 用户组root，x是密码段，表示没有设置密码，GID是0,root用户组下包括root、linuxsir以及GID为0的其它用户。</description>
    </item>
    <item>
      <title>每天一个linux命令（28）: chown</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-28-chown/</link>
      <pubDate>Wed, 28 Dec 2016 09:51:30 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-28-chown/</guid>
      <description>　chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将文件拷贝到另一个用户的名录下之后，让用户拥有使用该文件的权限。&#xA;命令格式# $ chown [选项]... [所有者][:[组]] 文件... 命令功能# 通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。&#xA;命令参数# 必要参数&#xA;参数 描述 -c 显示更改的部分的信息 -f 忽略错误信息 -h 修复符号链接 -R 处理指定目录以及其子目录下的所有文件 -v 显示详细的处理信息 -deference 作用于符号链接的指向，而不是链接文件本身 选择参数&#xA;参数 描述 &amp;ndash;reference=&amp;lt;目录或文件&amp;gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组 &amp;ndash;from=&amp;lt;当前用户：当前群组&amp;gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变 &amp;ndash;help 显示帮助信息 &amp;ndash;version 显示版本信息 命令实例# 例一：改变拥有者和群组&#xA;$ chown mail:mail log2012.log 例二：改变文件拥有者和群组&#xA;## 组可为空，默认为root所在组 $ chown root: log2012.log 例三：改变文件群组&#xA;## 只改变所在组 $ chown :mail log2012.log 例四：改变指定目录以及其子目录下的所有文件的拥有者和群组&#xA;$ chown -R -v root:mail test6 </description>
    </item>
    <item>
      <title>每天一个linux命令（27）: chgrp</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-27-chgrp/</link>
      <pubDate>Tue, 27 Dec 2016 09:40:06 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-27-chgrp/</guid>
      <description>　在lunix系统里，文件或目录的权限的掌控以拥有者及所诉群组来管理。可以使用chgrp指令取变更文件与目录所属群组，这种方式采用群组名称或群组识别码都可以。Chgrp命令就是change group的缩写！要被改变的组名必须要在/etc/group文件内存在才行。&#xA;命令格式# $ chgrp [选项] [组] [文件] 命令功能# chgrp命令可采用群组名称或群组识别码的方式改变文件或目录的所属群组。使用权限是超级用户。&#xA;命令参数# 必要参数&#xA;参数 描述 -c 当发生改变时，报告处理信息 -f 不显示错误信息 -R 处理指定目录以及其子目录下的所有文件 -v 运行时显示详细的处理信息 &amp;ndash;dereference 作用于符号链接的指向，而不是符号链接本身 &amp;ndash;no-dereference 作用于符号链接本身 选择参数&#xA;参数 描述 &amp;ndash;reference=&amp;lt;文件或者目录&amp;gt; 设置为和指定的文件或目录的权限一样 &amp;ndash;help 显示帮助信息 &amp;ndash;version 显示版本信息 命令实例# 例一：改变文件的群组属性&#xA;## 将log2012.log文件由root群组改为bin群组 $ chgrp -v bin log2012.log “log2012.log” 的所属组已更改为 bin 例二：根据指定文件改变文件的群组属性&#xA;## 改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同 $ chgrp --reference=log2012.log log2013.log 例三：改变指定目录以及其子目录下的所有文件的群组属性&#xA;## 改变指定目录以及其子目录下的所有文件的群组属性 $ chgrp -R bin test6 例四：通过群组识别码改变文件群组属性&#xA;## 通过群组识别码改变文件群组属性，100为users群组的识别码，具体群组和群组识别码可以去/etc/group文件中查看 $ chgrp -R 100 test6 </description>
    </item>
    <item>
      <title>每天一个linux命令（26）: chmod</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-26-chmod/</link>
      <pubDate>Mon, 26 Dec 2016 20:22:43 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-26-chmod/</guid>
      <description>chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。&#xA;Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。&#xA;文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。&#xA;有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。&#xA;每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 例如：&#xA;$ ls -al -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log 第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。&#xA;- rw- r-- r-- 表示log2012.log是一个普通文件；log2012.log的属主有读写权限；与log2012.log属主同组的用户只有读权限；其他用户也只有读权限。&#xA;确定了一个文件的访问权限后，用户可以利用Linux系统提供的chmod命令来重新设定不同的访问权限。也可以利用chown命令来更改某个文件或目录的所有者。利用chgrp命令来更改某个文件或目录的用户组。&#xA;chmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。chmod命令详细情况如下。&#xA;命令格式# $ chmod [-cfvR] [--help] [--version] mode file 命令功能# 用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。&#xA;命令参数# 必要参数&#xA;参数 描述 -c 当发生改变时，报告处理信息 -f 错误信息不输出 -R 处理指定目录以及其子目录下的所有文件 -v 运行时显示详细处理信息 选择参数&#xA;参数 描述 &amp;ndash;reference=&amp;lt;目录或者文件&amp;gt; 设置成具有指定目录或者文件具有相同的权限 &amp;ndash;version 显示版本信息 &amp;lt;权限范围&amp;gt;+&amp;lt;权限设置&amp;gt; 使权限范围内的目录或者文件具有指定的权限 &amp;lt;权限范围&amp;gt;-&amp;lt;权限设置&amp;gt; 删除权限范围的目录或者文件的指定权限 &amp;lt;权限范围&amp;gt;=&amp;lt;权限设置&amp;gt; 设置权限范围内的目录或者文件的权限为指定的值 权限范围&#xA;参数 描述 u 目录或者文件的当前的用户 g 目录或者文件的当前的群组 o 除了目录或者文件的当前用户或群组之外的用户或者群组 a 所有的用户及群组 权限代号</description>
    </item>
    <item>
      <title>每天一个linux命令（24）: tar</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-24-tar/</link>
      <pubDate>Sat, 24 Dec 2016 10:24:17 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-24-tar/</guid>
      <description>通过SSH访问服务器，难免会要用到压缩，解压缩，打包，解包等，这时候tar命令就是是必不可少的一个功能强大的工具。linux中最流行的tar是麻雀虽小，五脏俱全，功能强大。&#xA;tar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。&#xA;首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。&#xA;为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。&#xA;linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩。&#xA;命令格式# $ tar [必要参数] [选择参数] [文件] 命令功能# 用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的&#xA;命令参数# 必要参数&#xA;参数 描述 -A 新增压缩文件到已存在的压缩 -B 设置区块大小 -c 建立新的压缩文件 -d 记录文件的差别 -r 添加文件到已经压缩的文件 -u 添加改变了和现有的文件到已经存在的压缩文件 -x 从压缩的文件中提取文件 -t 显示压缩文件的内容 -z 支持gzip解压文件 -j 支持bzip2解压文件 -Z 支持compress解压文件 -v 显示操作过程 -l 文件系统边界设置 -k 保留原有文件不覆盖 -m 保留文件不被覆盖 -W 确认压缩文件的正确性 可选参数 参数 描述 -b 设置区块数目 -C 切换到指定目录 -f 指定压缩文件 &amp;ndash;help 显示帮助信息 &amp;ndash;version 显示版本信息 使常见解压/压缩命令# 例一：.tar文件&#xA;$ tar xvf FileName.tar ## 解包 $ tar cvf FileName.</description>
    </item>
    <item>
      <title>每天一个linux命令（23）: 用SecureCRT来上传和下载文件</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-23-securecrt/</link>
      <pubDate>Fri, 23 Dec 2016 09:48:15 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-23-securecrt/</guid>
      <description>用SSH管理linux服务器时经常需要远程与本地之间交互文件.而直接用SecureCRT自带的上传下载功能无疑是最方便的，SecureCRT下的文件传输协议有ASCII、Xmodem、Zmodem。&#xA;文件传输协议 文件传输是数据交换的主要形式。在进行文件传输时，为使文件能被正确识别和传送，我们需要在两台计算机之间建立统一的传输协议。这个协议包括了文件的识别、传送的起止时间、错误的判断与纠正等内容。常见的传输协议有以下几种：&#xA;ASCII：这是最快的传输协议，单只能传输文本文件。 Xmodem：这种古老的传输协议速度较慢，但由于使用了CRC错误侦测方法，传输的准确率可高达99.6%。 Ymodem：这是Xmodem的改良版，使用了1024位区段传送，速度比Xmodem要快 Zmodem：Zmodem采用了串流式（streaming）传输方式，传输速度较快，而且还具有自动改变区段大小和断点续传、快速错误侦测等功能。这是目前最流行的文件传输协议。 除以上几种外，还有Imodem、Jmodem、Bimodem、Kermit、Lynx等协议，由于没有多数厂商支持，这里就略去不讲。&#xA;SecureCRT可以使用linux下的zmodem协议来快速的传送文件,使用非常方便.具体步骤：&#xA;在使用SecureCRT上传下载之前需要给服务器安装lrzsz# 从下面的地址下载 lrzsz-0.12.20.tar.gz 我是下载地址 查看里面的INSTALL文档了解安装参数说明和细节 解压文件 $ tar zxvf lrzsz-0.12.20.tar.gz 进入目录，配置编译 $ cd lrzsz-0.12.20 $ ./configure --prefix=/usr/local/lrzsz $ make $ make install 建立软链接 $ cd /usr/bin $ ln -s /usr/local/lrzsz/bin/lrz rz $ ln -s /usr/local/lrzsz/bin/lsz sz 测试 运行 rz 弹出 SecureCrt上传窗口，用SecureCRT来上传和下载文件。&#xA;设置SecureCRT上传和下载的默认目录# options-&amp;gt;session options -&amp;gt;Terminal-&amp;gt;Xmodem/Zmodem 右栏directory设置上传和下载的目录&#xA;使用Zmodem从客户端上传文件到linux服务器# 用SecureCRT登陆linux终端&#xA;选中你要放置上传文件的路径，在目录下然后输入rz命令,SecureCRT会弹出文件选择对话框，在查找范围中找到你要上传的文件，按Add按钮。然后OK就可以把文件上传到linux上了。&#xA;或者在Transfer-&amp;gt;Zmodem Upoad list弹出文件选择对话框，选好文件后按Add按钮。然后OK窗口自动关闭。然后在linux下选中存放文件的目录，输入rz命令。liunx就把那个文件上传到这个目录下了。&#xA;使用Zmodem下载文件到客户端# $ sz filename zmodem 接收可以自行启动.下载的文件存放在你设定的默认下载目录下&#xA;rz，sz 是 Linux/Unix 同 Windows 进行 ZModem 文件传输的命令行工具 , windows 端需要支持ZModem的telnet/ssh客户端，SecureCRT 就可以用 SecureCRT 登陆到 Unix/Linux 主机（telnet或ssh均可）O 运行命令rz，即是接收文件，SecureCRT就会弹出文件选择对话框，选好文件之后关闭对话框，文件就会上传到当前目录 O 运行命令sz file1 file2就是发文件到windows上（保存的目录是可以配置） 比ftp命令方便多了，而且服务器不用再开FTP服务了</description>
    </item>
    <item>
      <title>每天一个linux命令（22）: find命令的参数详解</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-22-find-args/</link>
      <pubDate>Thu, 22 Dec 2016 11:44:14 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-22-find-args/</guid>
      <description>find一些常用参数的一些常用实例和一些具体用法和注意事项。&#xA;使用name选项# 文件名选项是find命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。&#xA;## 在自己的根目录$HOME中查找文件名符合*.log的文件，使用~作为 &amp;#39;pathname&amp;#39;参数，波浪号~代表了你的$HOME目录。 $ find ~ -name &amp;#34;*.log&amp;#34; -print ## 在当前目录及子目录中查找所有的‘ *.log‘文件 $ find . -name &amp;#34;*.log&amp;#34; -print ## 当前目录及子目录中查找文件名以一个大写字母开头的文件 $ find . -name &amp;#34;[A-Z]*&amp;#34; -print ## 在/etc目录中查找文件名以host开头的文件 $ find /etc -name &amp;#34;host*&amp;#34; -print ## 想要查找$HOME目录中的文件 $ find ~ -name &amp;#34;*&amp;#34; -print $ find . -print ## 让系统高负荷运行，就从根目录开始查找所有的文件 $ find / -name &amp;#34;*&amp;#34; -print ## 在当前目录查找文件名以一个个小写字母开头，最后是4到9加上.log结束的文件 $ find . -name &amp;#34;[a-z]*[4-9].log&amp;#34; -print 用perm选项# 按照文件权限模式用-perm选项,按文件权限模式来查找文件的话。最好使用八进制的权限表示法&#xA;## 在当前目录下查找文件权限位为755的文件 $ find .</description>
    </item>
    <item>
      <title>每天一个linux命令（21）: find命令之xargs</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-21-find-xargs/</link>
      <pubDate>Wed, 21 Dec 2016 11:08:01 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-21-find-xargs/</guid>
      <description>在使用 find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。&#xA;find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。&#xA;在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高； 而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。&#xA;使用实例# 例一：查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件&#xA;$ find . -type f -print | xargs file 例二：在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中&#xA;$ find / -name &amp;#34;core&amp;#34; -print | xargs echo &amp;#34;&amp;#34; &amp;gt;/tmp/core.log 例三：在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限&#xA;$ find . -perm -7 -print | xargs chmod o-w 例四：用grep命令在所有的普通文件中搜索hostname这个词&#xA;$ find . -type f -print | xargs grep &amp;#34;hostname&amp;#34; 例五：用grep命令在当前目录下的所有普通文件中搜索hostnames这个词&#xA;## \用来取消find命令中的*在shell中的特殊含义 $ find . -name \* -type f -print | xargs grep &amp;#34;hostnames&amp;#34; 例六：使用xargs执行mv</description>
    </item>
    <item>
      <title>每天一个linux命令（20）: find命令之exec</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-20-find-exec/</link>
      <pubDate>Tue, 20 Dec 2016 10:47:32 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-20-find-exec/</guid>
      <description>find是我们很常用的一个Linux命令，但是我们一般查找出来的并不仅仅是看看而已，还会有进一步的操作，这个时候exec的作用就显现出来了&#xA;命令介绍# -exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。&#xA;{} 花括号代表前面find查找出来的文件名。&#xA;使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，很方便的。在有些操作系统中只允许-exec选项执行诸如ls或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。 exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最后是一个分号。为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。&#xA;使用实例# 例一：ls -l命令放在find命令的-exec选项中&#xA;## find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出 $ find . -type f -exec ls -l {} \; 例二：在目录中查找更改时间在n日以前的文件并删除它们&#xA;$ find . -type f -mtime +14 -exec rm {} \; 例三：在目录中查找更改时间在n日以前的文件并删除它们，在删除之前先给出提示&#xA;$ find . -name &amp;#34;*.log&amp;#34; -mtime +5 -ok rm {} \; 例四：-exec中使用grep命令&#xA;$ find /etc -name &amp;#34;passwd*&amp;#34; -exec grep &amp;#34;root&amp;#34; {} \; 例五：查找文件移动到指定目录&#xA;$ find . -name &amp;#34;*.log&amp;#34; -exec mv {} .</description>
    </item>
    <item>
      <title>每天一个linux命令（19）: find命令概览</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-19-find/</link>
      <pubDate>Mon, 19 Dec 2016 15:19:10 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-19-find/</guid>
      <description>Linux下find命令在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。&#xA;命令格式# $ find pathname -options [-print -exec -ok ...] 命令功能# 用于在文件树种查找文件，并作出相应的处理&#xA;命令参数# 参数 描述 pathname find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录 -print find命令将匹配的文件输出到标准输出 -exec find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&amp;rsquo;command&amp;rsquo; { } ;，注意{ }和\；之间的空格 -ok 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行 命令选项# 选项 描述 -name 按照文件名查找文件 -perm 按照文件权限来查找文件 -prune 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略 -user 按照文件属主来查找文件 -group 按照文件所属的组来查找文件 -mtime -n +n 按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项 -nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在 -nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在 -newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件 -type 查找某一类型的文件,诸如：b - 块设备文件d - 目录c - 字符设备文件p - 管道文件l - 符号链接文件f - 普通文件 -size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找 -fstype 查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息 -mount 在查找文件时不跨越文件系统mount点 -follow 如果find命令遇到符号链接文件，就跟踪至链接所指向的文件 -cpio 对匹配的文件使用cpio命令，将这些文件备份到磁带设备中 -amin n 查找系统中最后N分钟访问的文件 -atime n 查找系统中最后n*24小时访问的文件 -cmin n 查找系统中最后N分钟被改变文件状态的文件 -ctime n 查找系统中最后n*24小时被改变文件状态的文件 -mmin n 查找系统中最后N分钟被改变文件数据的文件 -mtime n 查找系统中最后n*24小时被改变文件数据的文件 使用实例# 例一：查找指定时间内修改过的文件</description>
    </item>
    <item>
      <title>每天一个linux命令（18）: locate</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-18-locate/</link>
      <pubDate>Sun, 18 Dec 2016 15:09:28 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-18-locate/</guid>
      <description>　locate 让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的 distribution 之中，数据库的建立都被放在 crontab 中自动执行。&#xA;命令格式# $ locate [选择参数] [样式] 命令功能# locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)&#xA;locate指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录，可以使用特殊字元（如* 或 ?等）来指定范本样式，如指定范本为kcpa*ner, locate会找出所有起始字串为kcpa且结尾为ner的档案或目录，如名称为kcpartner若目录录名称为kcpa_ner则会列出该目录下包括 子目录在内的所有档案。&#xA;locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在 执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。&#xA;命令参数# 参数 描述 -e 将排除在寻找的范围之外 -1 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的权限资料 -f 将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案放在资料库中 -q 安静模式，不会显示任何错误讯息 -n 至多显示 n个输出 -r 使用正规运算式 做寻找的条件 -o 指定资料库存的名称 -d 指定资料库的路径 -h 显示辅助讯息 -V 显示程式的版本讯息 使用实例# 例一：查找和pwd相关的所有文件&#xA;$ locate pwd 例二：搜索etc目录下所有以sh开头的文件&#xA;$ locate /etc/sh </description>
    </item>
    <item>
      <title>每天一个linux命令（17）: whereis</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-17-whereis/</link>
      <pubDate>Sat, 17 Dec 2016 10:42:58 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-17-whereis/</guid>
      <description>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。&#xA;和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。&#xA;但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。&#xA;命令格式# $ whereis [-bmsu] [BMS 目录名 -f ] 文件名 命令功能# whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。&#xA;命令参数# 参数 描述 -b 定位可执行文件 -m 定位帮助文件 -s 定位源代码文件 -u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件 -B 指定搜索可执行文件的路径 -M 指定搜索帮助文件的路径 -S 指定搜索源代码文件的路径 使用实例# 例一：将和git文件相关的文件都查找出来&#xA;$ whereis git 例二：只将二进制文件 查找出来&#xA;$ whereis -b svn whereis -m svn 查出说明文档路径，whereis -s svn 找source源文件</description>
    </item>
    <item>
      <title>每天一个linux命令（16）: which</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-16-which/</link>
      <pubDate>Fri, 16 Dec 2016 11:25:49 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-16-which/</guid>
      <description>　我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。&#xA;命令格式# $ which 可执行文件名称 命令功能# which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。&#xA;命令参数# 参数 描述 -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名 -p 与-n参数相同，但此处的包括了文件的路径 -w 指定输出时栏位的宽度 -V 显示版本信息 使用实例# 例一：查找文件、显示命令路径&#xA;## which 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！ ## 所以，不同的 PATH 配置内容所找到的命令当然不一样的！ $ which pwd 例二：用 which 去找出 which&#xA;## 竟然会有两个 which ，其中一个是 alias 这就是所谓的『命令别名』，意思是输入 which 会等於后面接的那串命令！ $ which which 例三：找出 cd 这个命令&#xA;## cd 这个常用的命令竟然找不到啊！为什么呢？这是因为 cd 是bash 内建的命令！ ## 但是 which 默认是找 PATH 内所规范的目录，所以当然一定找不到的！ $ which cd </description>
    </item>
    <item>
      <title>每天一个linux命令（15）: tail</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-15-tail/</link>
      <pubDate>Thu, 15 Dec 2016 15:00:26 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-15-tail/</guid>
      <description>　tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容.&#xA;命令格式# tail[必要参数][选择参数][文件] 命令功能# 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。&#xA;命令参数# 参数 描述 -f 循环读取 -q 不显示处理信息 -v 显示详细的处理信息 -c&amp;lt;数目&amp;gt; 显示的字节数 -n&amp;lt;行数&amp;gt; 显示行数 &amp;ndash;pid=PID 与-f合用,表示在进程ID,PID死掉之后结束 -q, &amp;ndash;quiet, &amp;ndash;silent 从不输出给出文件名的首部 -s, &amp;ndash;sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 使用实例# 例一：显示文件末尾内容&#xA;## 显示文件最后5行内容 $ tail -n 5 log2014.log 例二：循环查看文件内容&#xA;$ tail -f test.log 例三：从第5行开始显示文件&#xA;$ tail -n +5 log2014.log </description>
    </item>
    <item>
      <title>每天一个linux命令（14）: head</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-14-head/</link>
      <pubDate>Wed, 14 Dec 2016 14:35:49 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-14-head/</guid>
      <description>　head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾。&#xA;命令格式# head [参数]... [文件]... 命令功能# head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。&#xA;命令参数# 参数 描述 -q 隐藏文件名 -v 显示文件名 -c&amp;lt;字节&amp;gt; 显示字节数 -n&amp;lt;行数&amp;gt; 显示的行数 使用实例# 例一：显示文件的前n行&#xA;$ head -n 5 log2014.log 例二：显示文件前n个字节&#xA;$ head -c 20 log2014.log 例三：文件的除了最后n个字节以外的内容&#xA;$ head -c -32 log2014.log 例四：输出文件除了最后n行的全部内容&#xA;$ head -n -6 log2014.log </description>
    </item>
    <item>
      <title>每天一个linux命令（13）: less</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-13-less/</link>
      <pubDate>Tue, 13 Dec 2016 21:46:14 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-13-less/</guid>
      <description>less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。&#xA;命令格式# $ less [参数] 文件 命令功能# less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。&#xA;命令参数# 参数 描述 -b &amp;lt;缓冲区大小&amp;gt; 设置缓冲区的大小 -e 当文件显示结束后，自动离开 -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 -g 只标志最后搜索的关键词 -i 忽略搜索时的大小写 -m 显示类似more命令的百分比 -N 显示每行的行号 -o &amp;lt;文件名&amp;gt; 将less 输出的内容在指定文件中保存起来 -Q 不使用警告音 -s 显示连续空行为一行 -S 行过长时间将超出部分舍弃 -x &amp;lt;数字&amp;gt; 将“tab”键显示为规定的数字空格 /字符串 向下搜索“字符串”的功能 ?字符串 向上搜索“字符串”的功能 n 重复前一个搜索（与 / 或 ?</description>
    </item>
    <item>
      <title>每天一个linux命令（12）: more</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-12-more/</link>
      <pubDate>Mon, 12 Dec 2016 21:29:39 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-12-more/</guid>
      <description>more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。&#xA;命令格式# $ more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] 命令功能# more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。&#xA;命令参数# 参数 描述 +n 从笫n行开始显示 -n 定义屏幕大小为n行 +/pattern 每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 常用操作# 操作 描述 Enter 向下n行，需要定义。默认为1行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 ：f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 命令实例# 例一：显示文件中从第3行起的内容</description>
    </item>
    <item>
      <title>每天一个linux命令（11）: nl</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-11-nl/</link>
      <pubDate>Sun, 11 Dec 2016 21:11:48 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-11-nl/</guid>
      <description>nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。&#xA;命令格式# $ nl [选项]... [文件]... 命令功能# nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。&#xA;命令参数# 种类 参数 描述 -b -b a 表示不论是否为空行，也同样列出行号(类似 cat -n) -b t 如果有空行，空的那一行不要列出行号(默认值) -n -n ln 行号在萤幕的最左方显示 -n rn 行号在自己栏位的最右方显示，且不加 0 -n rz 行号在自己栏位的最右方显示，且加 0 -w -w 行号栏位的占用的位数 -p -p 在逻辑定界符处不重新开始计算 命令实例# 例一：用 nl 列出 log2012.log 的内容&#xA;## 文件中的空白行，nl 不会加上行号 $ nl log2012.</description>
    </item>
    <item>
      <title>每天一个linux命令（10）: cat</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-10-cat/</link>
      <pubDate>Sat, 10 Dec 2016 10:52:50 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-10-cat/</guid>
      <description>cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。&#xA;命令格式# $ cat [选项] [文件]... 命令功能# cat主要有三大功能&#xA;一次显示整个文件:cat filename 从键盘创建一个文件:cat &amp;gt; filename 只能创建新文件,不能编辑已有文件. 将几个文件合并为一个文件:cat file1 file2 &amp;gt; file 命令参数# 参数 描述 -A, &amp;ndash;show-all 等价于 -vET -b, &amp;ndash;number-nonblank 对非空输出行编号 -e 等价于 -vE -E, &amp;ndash;show-ends 在每行结束处显示 $ -n, &amp;ndash;number 对输出的所有行编号,由1开始对所有输出的行数编号 -s, &amp;ndash;squeeze-blank 有连续两行以上的空白行，就代换为一行的空白行 -t 与 -vT 等价 -T, &amp;ndash;show-tabs 将跳格字符显示为 ^I -u (被忽略) -v, &amp;ndash;show-nonprinting 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 命令实例# 例一：把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里</description>
    </item>
    <item>
      <title>每天一个linux命令（9）: touch</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-9-touch/</link>
      <pubDate>Fri, 09 Dec 2016 07:15:12 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-9-touch/</guid>
      <description>linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。&#xA;命令格式# $ touch [选项]... 文件... 命令功能# touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。&#xA;命令参数# 参数 描述 -a 或&amp;ndash;time=atime或&amp;ndash;time=access或&amp;ndash;time=use 只更改存取时间 -c 或&amp;ndash;no-create 不建立任何文档 -d 使用指定的日期时间，而非现在的时间 -f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题 -m 或&amp;ndash;time=mtime或&amp;ndash;time=modify 只更改变动时间 -r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同 -t 使用指定的日期时间，而非现在的时间 命令实例# 例一：创建不存在的文件&#xA;$ touch 1.txt 例二：更新1.txt的时间和2.txt时间戳相同&#xA;$ touch -r 1.txt 2.txt 例三：设定文件的时间戳&#xA;$ touch -t 201211142234.50 1.txt 例四：创建不存在的文件&#xA;$ touch 1.txt 说明： -t time 使用指定的时间值 time 作为指定文件相应时间戳记的新值．此处的 time规定为如下形式的十进制数: [[CC]YY]MMDDhhmm[.SS] 这里，CC为年数中的前两位，即”世纪数”；YY为年数的后两位，即某世纪中的年数．如果不给出CC的值，则touch 将把年数CCYY限定在1969&amp;ndash;2068之内．MM为月数，DD为天将把年数CCYY限定在1969&amp;ndash;2068之内．MM为月数，DD为天数，hh 为小时数(几点)，mm为分钟数，SS为秒数．此处秒的设定范围是0&amp;ndash;61，这样可以处理闰秒．这些数字组成的时间是环境变量TZ指定的时区中的一个时 间．由于系统的限制，早于1970年1月1日的时间是错误的。</description>
    </item>
    <item>
      <title>每天一个linux命令（8）: cp</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-8-cp/</link>
      <pubDate>Thu, 08 Dec 2016 16:31:43 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-8-cp/</guid>
      <description>cp命令用来复制文件或者目录，是Linux系统中最常用的命令之一。一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。&#xA;命令格式# $ cp [选项]... [-T] 源 目的 $ cp [选项]... -t 目录 源... 命令功能# 将源文件复制至目标文件，或将多个源文件复制至目标目录。&#xA;命令参数# 参数 描述 -a,&amp;ndash;archive 为每个已存在的目标文件创建备份 -f, &amp;ndash;force 如果目标文件无法打开则将其移除并重试(当 -n 选项存在时则不需再选此项) -i, &amp;ndash;interactive 覆盖前询问(使前面的 -n 选项失效) -H 跟随源文件中的命令行符号链接 -l, &amp;ndash;link 链接文件而不复制 -L, &amp;ndash;dereference 总是跟随符号链接 -n, &amp;ndash;no-clobber 不要覆盖已存在的文件(使前面的 -i 选项失效) -P, &amp;ndash;no-dereference 不跟随源文件中的符号链接 -p 等于&amp;ndash;preserve=模式,所有权,时间戳 -R, -r, &amp;ndash;recursive 复制目录及目录内的所有项目 命令实例# 例一：复制单个文件到目标目录，文件在目标文件中存在，会询问覆盖&#xA;## 在没有带-a参数时，两个文件的时间是不一样的。在带了-a参数时，两个文件的时间是一致的。 $ cp 1.txt test5 例二：复制整个目录&#xA;## 注意目标目录存在与否结果是不一样的。目标目录存在时，整个源目录被复制到目标目录里面。 $ cp -a test3 test5 例三：复制的 log.</description>
    </item>
    <item>
      <title>每天一个linux命令（7）: mv</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-7-mv/</link>
      <pubDate>Wed, 07 Dec 2016 15:55:20 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-7-mv/</guid>
      <description>mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录&#xA;命令格式# $ mv [选项] 源文件或目录 目标文件或目录 命令功能# 视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。&#xA;命令参数# 参数 描述 -b 若需覆盖文件，则覆盖前先行备份。 -f force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i 若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u 若目标文件已经存在，且 source 比较新，才会更新(update) -t &amp;ndash;target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。 命令实例# 例一：文件改名&#xA;$ mv test.txt test1.txt 例二：移动文件&#xA;#将文件test.txt 移动到/usr/doc目录下 $ mv test.txt /usr/doc 例三：将文件log1.txt,log2.txt,log3.txt移动到目录/usr/doc中&#xA;$ mv log1.txt log2.txt log3.txt /usr/doc $ mv -t /usr/doc log1.txt log2.txt log3.txt 例四：将文件file1改名为file2，如果file2已经存在，则询问是否覆盖&#xA;$ mv -i log1.txt log2.txt 例五：将文件file1改名为file2，即使file2存在，也是直接覆盖掉</description>
    </item>
    <item>
      <title>每天一个linux命令（6）: rmdir</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-6-rmdir/</link>
      <pubDate>Tue, 06 Dec 2016 15:24:32 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-6-rmdir/</guid>
      <description>　今天学习一下linux中命令： rmdir命令。rmdir是常用的命令，该命令的功能是删除空目录，一个目录被删除之前必须是空的。（注意，rm - r dir命令可代替rmdir，但是有很大危险性。）删除某目录时也必须具有对父目录的写权限。&#xA;命令格式# $ rmdir [选项]... 目录... 命令功能# 该命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对父目录的写权限。&#xA;命令参数# 参数 描述 - p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息 -v, &amp;ndash;verbose 显示指令执行过程 命令实例# 例一：rmdir 不能删除非空目录&#xA;$ rmdir doc rmdir: doc: 目录非空 例二：rmdir -p 当子目录被删除后使它也成为空目录的话，则顺便一并删除&#xA;$ rmdir -p log/product </description>
    </item>
    <item>
      <title>每天一个linux命令（5）: rm</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-5-rm/</link>
      <pubDate>Mon, 05 Dec 2016 13:40:38 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-5-rm/</guid>
      <description>　rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。 rm是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。&#xA;命令格式# $ rm [选项] 文件... 命令功能# 参数 描述 -f, &amp;ndash;force 忽略不存在的文件，从不给出提示 -i, &amp;ndash;interactive 进行交互式删除 -r, -R, &amp;ndash;recursive 指示rm将参数中列出的全部目录和子目录均递归地删除 -v, &amp;ndash;verbose 详细显示进行的步骤 &amp;ndash;help 显示此帮助信息并退出 &amp;ndash;version 输出版本信息并退出 命令实例# 例一：删除文件file，系统会先询问是否删除&#xA;$ rm file 例二：强行删除file，系统不再提示&#xA;$ rm -f file **例三：删除任何.log文件；删除前逐一询问确认 **&#xA;$ rm -i *.log 例四：对test文件夹进行递归删除&#xA;$ rm -r test 例五：递归删除，系统不用一一确认&#xA;$ rm -rf test 例六：删除以 -f 开头的文件&#xA;$ rm -- -f 例七：自定义回收站功能&#xA;#下面的操作过程模拟了回收站的效果，即删除文件的时候只是把文件放到一个临时目录中，这样在需要的时候还可以恢复过来。 $ myrm(){ D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv &amp;#34;$@&amp;#34; $D &amp;amp;&amp;amp; echo &amp;#34;moved to $D ok&amp;#34;; } </description>
    </item>
    <item>
      <title>每天一个linux命令（4）: mkdir</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-4-mkdir/</link>
      <pubDate>Sun, 04 Dec 2016 09:27:32 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-4-mkdir/</guid>
      <description>　linux mkdir 命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。&#xA;命令格式# $ mkdir [选项] 目录... 命令功能# 通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。&#xA;命令参数# 参数 说明 -m, &amp;ndash;mode=模式 设定权限&amp;lt;模式&amp;gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask -p, &amp;ndash;parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录 -v, &amp;ndash;verbose 每次创建新目录都显示信息 &amp;ndash;help 显示此帮助信息并退出 &amp;ndash;version 输出版本信息并退出 命令是实例# 例一：创建一个空目录&#xA;$ mkdir test 例二：递归创建多个目录&#xA;#在当前目录创建一个嵌套文件夹test1/test11 $ mkdir -p test1/test11 例三：创建权限为777的目录&#xA;$ mkdir -m 777 test 例四：创建新目录都显示信息&#xA;$ mkdir -v test 例五：一个命令创建项目的目录结构&#xA;$ mkdir -vp scf/{lib/,bin/,doc/{info,product},logs/{info,product},service/deploy/{info,product}} mkdir: 已创建目录 “scf” mkdir: 已创建目录 “scf/lib” mkdir: 已创建目录 “scf/bin” mkdir: 已创建目录 “scf/doc” mkdir: 已创建目录 “scf/doc/info” mkdir: 已创建目录 “scf/doc/product” mkdir: 已创建目录 “scf/logs” mkdir: 已创建目录 “scf/logs/info” mkdir: 已创建目录 “scf/logs/product” mkdir: 已创建目录 “scf/service” mkdir: 已创建目录 “scf/service/deploy” mkdir: 已创建目录 “scf/service/deploy/info” mkdir: 已创建目录 “scf/service/deploy/product” [root@localhost test]## tree scf/ scf/ |-- bin |-- doc | |-- info | `-- product |-- lib |-- logs | |-- info | `-- product `-- service `-- deploy |-- info `-- product 12 directories, 0 files </description>
    </item>
    <item>
      <title>每天一个linux命令（3）: pwd</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-3-pwd/</link>
      <pubDate>Sat, 03 Dec 2016 09:15:52 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-3-pwd/</guid>
      <description>　Linux中用 pwd 命令来查看”当前工作目录“的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。 在不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置。&#xA;命令格式# $ pwd [选项] 命令功能# 查看”当前工作目录“的完整路径&#xA;常用参数# 一般情况下不带任何参数 如果目录是链接时： 格式：pwd -P 显示出实际路径，而非使用链接（link） 的路径&#xA;实用实例# 例一：用 pwd 命令查看当前工作目录的完整路径&#xA;$ pwd /home/faker 例二：目录连接链接时，pwd -P 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径&#xA;#目录为链接时，输出链接路径 $ pwd -L #目录为链接时，输出物理路径 $ pwd -P /home/faker 例三：当前目录被删除了，而pwd命令仍然显示那个目录&#xA;$ cd /opt/soft $ rm ../soft -rf $ pwd /opt/soft $ /bin/pwd /bin/pwd: couldnt find directory entry in “..” with matching i-node /home/faker </description>
    </item>
    <item>
      <title>每天一个linux命令（2）: cd</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-2-cd/</link>
      <pubDate>Fri, 02 Dec 2016 11:04:55 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-2-cd/</guid>
      <description>&lt;p&gt;　　Linux cd 命令可以说是Linux中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。所以，学习Linux 常用命令，首先就要学好 cd 命令的使用方法技巧。&lt;/p&gt;</description>
    </item>
    <item>
      <title>每天一个linux命令（1）: ls</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-1-ls/</link>
      <pubDate>Thu, 01 Dec 2016 09:38:59 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-1-ls/</guid>
      <description>ls命令是linux下最常用的命令。ls命令就是list的缩写，缺省下ls用来打印出当前目录的清单，如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。 通过ls命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)、查看目录信息等等。ls命令在日常的linux操作中用的很多!&#xA;命令格式# $ ls [选项] [目录名] 命令功能# 列出目标目录中所有的子目录和文件。&#xA;常用参数# 参数 说明 -a,&amp;ndash;all 列出目录下的所有文件，包括以 . 开头的隐含文件 -A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。 -c 配合 -lt 根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -lt：显示 ctime 但根据名称排序否则：根据 ctime 排序 -C 每栏由上至下列出项目 -color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是&amp;rsquo;never&amp;rsquo;、&amp;lsquo;always&amp;rsquo;或&amp;rsquo;auto&amp;rsquo;其中之一 -d,&amp;ndash;directory 将目录象文件一样显示，而不是显示其下的文件。 -D,&amp;ndash;dired 产生适合 Emacs 的 dired 模式使用的结果 -f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效 -g 类似 -l,但不列出所有者 -G, &amp;ndash;no-group 不列出任何有关组的信息 -h,&amp;ndash;human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G) &amp;ndash;si 类似 -h,但文件大小取 1000 的次方而不是 1024 -H, &amp;ndash;dereference-command-line 使用命令列中的符号链接指示的真正目的地 &amp;ndash;indicator-style=&amp;lt;方式&amp;gt; 指定在每个项目名称后加上指示符号&amp;lt;方式&amp;gt;：none (默认)，classify (-F)，file-type (-p) -i, &amp;ndash;inode 印出每个文件的 inode 号 -I,&amp;ndash;ignore=样式 不印出任何符合 shell 万用字符&amp;lt;样式&amp;gt;的项目 -k 即 –block-size=1K,以 k 字节的形式表示文件的大小 -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。 -L, &amp;ndash;dereference -m 所有项目以逗号分隔，并填满整行行宽 -o 类似 -l,显示文件的除组信息外的详细信息。 -r, &amp;ndash;reverse 依相反次序排列 -R, &amp;ndash;recursive 同时列出所有子目录层 -s,&amp;ndash;size 以块大小为单位列出所有文件的大小 -S 根据文件大小排序 &amp;ndash;sort=WORD 可选用的 WORD 和它们代表的相应选项： extension -X status -cnone -U time -tsize -S atime -utime -t access -uversion -v use -u -t 以文件修改时间排序 -u 配合 -lt:显示访问时间而且依访问时间排序配合 -l:显示访问时间但根据名称排序否则：根据访问时间排序 -U 不进行排序;依文件系统原有的次序列出项目 -v 根据版本进行排序 -w, &amp;ndash;width=COLS 自行指定屏幕宽度而不使用目前的数值 -x 逐行列出项目而不是逐栏列出 -X 根据扩展名排序 -1 每行只列出一个文件 &amp;ndash;help 显示此帮助信息并离开 &amp;ndash;version 显示版本信息并离开 常用范例# 例一：列出/home/faker/ 文件夹下的所有文件和目录的详细资料</description>
    </item>
  </channel>
</rss>

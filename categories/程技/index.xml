<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>程技 on 樊刹</title>
    <link>https://richfan.site/categories/%E7%A8%8B%E6%8A%80/</link>
    <description>Recent content in 程技 on 樊刹</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Mon, 23 Oct 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://richfan.site/categories/%E7%A8%8B%E6%8A%80/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>程技</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/</guid>
      <description> Blog butterfly docsify Emoji 使用Git将文件夹上传到Github以及使用Git LFS上传大文件 博客搭建工具 博客部署 Excel 史上最全的数据透视表用法 Golang Golang入门笔记-CH01-Go语言介绍与安装 Golang入门笔记-CH02-Go语言基本语法和结构 Golang入门笔记-CH03-Go语言基本数据类型 Golang入门笔记-CH04-Go语言流程控制 Golang入门笔记-CH05-数组和切片 Golang入门笔记-CH06-Map Golang入门笔记-CH07-结构体和方法 Golang入门笔记-CH08-接口 Golang入门笔记-CH09-反射 Golang入门笔记-CH10-函数高级特性 Golang入门笔记-CH11-错误处理 Golang入门笔记-CH12-并发 Linux Linux-command 每天一个linux命令（25）: gzip 每天一个linux命令（58）: sort 每天一个linux命令（57）: sftp 每天一个linux命令（56）: tailf 每天一个linux命令（55）: crontab 每天一个linux命令（54）: at 每天一个linux命令（53）: watch 每天一个linux命令（52）: ps 每天一个linux命令（51）: wc 每天一个linux命令（50）: grep 每天一个linux命令（49）: cal 每天一个linux命令（48）: date 每天一个linux命令（47）: diff 每天一个linux命令（46）: ln 每天一个linux命令（45）: scp 每天一个linux命令（44）: rcp 每天一个linux命令（43）: telnet 每天一个linux命令（42）: ss 每天一个linux命令（41）: netstat 每天一个linux命令（40）: traceroute 每天一个linux命令（39）: ping 每天一个linux命令（38）: route 每天一个linux命令（37）: ifconfig 每天一个linux命令（36）: lsof 每天一个linux命令（35）: iostat 每天一个linux命令（34）: vmstat 每天一个linux命令（33）: free 每天一个linux命令（32）: top 每天一个linux命令（31）: du 每天一个linux命令（30）: df 每天一个linux命令（29）: /etc/group文件详解 每天一个linux命令（28）: chown 每天一个linux命令（27）: chgrp 每天一个linux命令（26）: chmod 每天一个linux命令（24）: tar 每天一个linux命令（23）: 用SecureCRT来上传和下载文件 每天一个linux命令（22）: find命令的参数详解 每天一个linux命令（21）: find命令之xargs 每天一个linux命令（20）: find命令之exec 每天一个linux命令（19）: find命令概览 每天一个linux命令（18）: locate 每天一个linux命令（17）: whereis 每天一个linux命令（16）: which 每天一个linux命令（15）: tail 每天一个linux命令（14）: head 每天一个linux命令（13）: less 每天一个linux命令（12）: more 每天一个linux命令（11）: nl 每天一个linux命令（10）: cat 每天一个linux命令（9）: touch 每天一个linux命令（8）: cp 每天一个linux命令（7）: mv 每天一个linux命令（6）: rmdir 每天一个linux命令（5）: rm 每天一个linux命令（4）: mkdir 每天一个linux命令（3）: pwd 每天一个linux命令（2）: cd 每天一个linux命令（1）: ls 2022年我在使用这些vim插件 Docker 技术整理 shell速查表 nginx配置记录 linux下修改按键ESC&amp;lt;=&amp;gt;CAPSLOCK和Control=&amp;gt;ALT_R [转]字符编解码的故事（ASCII，ANSI，Unicode，Utf-8区别） docker报错集锦 CentOS7使用Firewalld docker备份恢复之save与export sudo命令免密码设置 600 条最强 Linux 命令总结 搭建Maven私服-Nexus CentOS7安装配置匿名访问Samba 解决粘贴到vim缩进错乱问题 进入docker容器命令制作 docker数据管理 docker容器 docker仓库 CentOS修改DNS/GW/IP Dockerfile指令详解 docker镜像 docker初体验 linux无损调整分区大小 解决linux下zip文件解压乱码 Vim命令速查表 如何在linux中搭建ftp服务 Python 9款最佳Python脚本：让工作自动化起来！ 1 顺序表 2 单链表 3 栈 6 小时 Python 入门 Anaconda 入门指南 Jupyter notebook 使用指南 Jupyter添加目录toc Pandas常用操作 PyCharm 优化使用 第八章 数据规整：聚合、合并和重塑 第二章 Python 语法基础，IPython 和 Jupyter Notebooks 第九章 绘图可视化 第六章 数据加载、存储与文件格式 第七章 数据清洗和准备 第三章 Python 的数据结构、函数和文件 第十二章 Pandas 高级应用 第十三章 Python 建模库介绍 第十四章 数据分析案例 第十一章 时间序列 第十章 数据聚合与分组运算 第四章 Numpy 基础 第五章 Pandas 入门 第一章 准备工作 附录A-NumPy高级应用 附录B-更多关于IPython的内容 Pandas最常用的15个函数 python数据分析专用数据库，与pandas结合，10倍提速&amp;#43;极致体验 数据库连接轻松搞定：Python 数据库推荐 ExcelToPDF Spider 审计技能|Python语句（四）：常用查询函数 SQL MySQL常用函数 live_max_online MySQL常用30种SQL查询语句优化方法 SQL每日一题(20230814) SQL每日一题F0215，多种方法及思路讲解 SQL每日一题F1021，while循环操作 SQL每日一题F1025，复杂逻辑处理 SQL每日一题F1028，关联子查询 top10_sql_skills 查询连续登陆3天的用户id和登陆天数 给定用户登录表，求表中每一天的3天留存率 求占据前90%销售额的商品类型 System QEMU - QuickStart WSL（适用于 Linux 的 Windows 子系统）Kali在线安装 Linux windows重装 VBA 【VBA案例001】实现VLOOKUP功能 【VBA案例002】一对多查询 【VBA案例003】模糊查询 【VBA案例004】自动填充表单 【VBA案例005】自动汇总表单 【VBA案例006】数据去重 【VBA案例007】多条件汇总 【VBA案例008】多条件查询 【VBA案例009】合并单元格汇总 【VBA案例010】下拉多选 【VBA案例011】合并工作表 【VBA案例012】合并工作簿 【VBA案例013】多个工作簿所有Sheet汇总到一个工作簿中 【VBA案例014】拆分工作表（上） 【VBA案例015】拆分工作表（下） 【VBA案例016】拆分工作簿 【VBA案例017】合并单元格 【VBA案例018】取消合并单元格 【VBA案例019】合并单元格自适应大小 【VBA案例020】整合工作簿 a段落处理 b表单处理 c数字 d文字 e大纲 fExcel贴数 g批注 h行列校验 i多表处理 JsonConverter j页面设置 k访谈提纲 底稿小帮手代码 更新 类模块 Git 的使用 Python pandas数据分析基础100问(有重复) emoji 国内AI集锦 审计工具 </description>
    </item>
    <item>
      <title>Blog</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/</link>
      <pubDate>Wed, 23 Feb 2022 17:56:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/</guid>
      <description> butterfly docsify Emoji 使用Git将文件夹上传到Github以及使用Git LFS上传大文件 博客搭建工具 博客部署 </description>
    </item>
    <item>
      <title>Excel</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/excel/</link>
      <pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/excel/</guid>
      <description> 史上最全的数据透视表用法 </description>
    </item>
    <item>
      <title>Golang</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/</guid>
      <description> Golang入门笔记-CH01-Go语言介绍与安装 Golang入门笔记-CH02-Go语言基本语法和结构 Golang入门笔记-CH03-Go语言基本数据类型 Golang入门笔记-CH04-Go语言流程控制 Golang入门笔记-CH05-数组和切片 Golang入门笔记-CH06-Map Golang入门笔记-CH07-结构体和方法 Golang入门笔记-CH08-接口 Golang入门笔记-CH09-反射 Golang入门笔记-CH10-函数高级特性 Golang入门笔记-CH11-错误处理 Golang入门笔记-CH12-并发 </description>
    </item>
    <item>
      <title>Linux</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/</link>
      <pubDate>Mon, 27 Jun 2022 15:07:39 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/</guid>
      <description> Linux-command 每天一个linux命令（25）: gzip 每天一个linux命令（58）: sort 每天一个linux命令（57）: sftp 每天一个linux命令（56）: tailf 每天一个linux命令（55）: crontab 每天一个linux命令（54）: at 每天一个linux命令（53）: watch 每天一个linux命令（52）: ps 每天一个linux命令（51）: wc 每天一个linux命令（50）: grep 每天一个linux命令（49）: cal 每天一个linux命令（48）: date 每天一个linux命令（47）: diff 每天一个linux命令（46）: ln 每天一个linux命令（45）: scp 每天一个linux命令（44）: rcp 每天一个linux命令（43）: telnet 每天一个linux命令（42）: ss 每天一个linux命令（41）: netstat 每天一个linux命令（40）: traceroute 每天一个linux命令（39）: ping 每天一个linux命令（38）: route 每天一个linux命令（37）: ifconfig 每天一个linux命令（36）: lsof 每天一个linux命令（35）: iostat 每天一个linux命令（34）: vmstat 每天一个linux命令（33）: free 每天一个linux命令（32）: top 每天一个linux命令（31）: du 每天一个linux命令（30）: df 每天一个linux命令（29）: /etc/group文件详解 每天一个linux命令（28）: chown 每天一个linux命令（27）: chgrp 每天一个linux命令（26）: chmod 每天一个linux命令（24）: tar 每天一个linux命令（23）: 用SecureCRT来上传和下载文件 每天一个linux命令（22）: find命令的参数详解 每天一个linux命令（21）: find命令之xargs 每天一个linux命令（20）: find命令之exec 每天一个linux命令（19）: find命令概览 每天一个linux命令（18）: locate 每天一个linux命令（17）: whereis 每天一个linux命令（16）: which 每天一个linux命令（15）: tail 每天一个linux命令（14）: head 每天一个linux命令（13）: less 每天一个linux命令（12）: more 每天一个linux命令（11）: nl 每天一个linux命令（10）: cat 每天一个linux命令（9）: touch 每天一个linux命令（8）: cp 每天一个linux命令（7）: mv 每天一个linux命令（6）: rmdir 每天一个linux命令（5）: rm 每天一个linux命令（4）: mkdir 每天一个linux命令（3）: pwd 每天一个linux命令（2）: cd 每天一个linux命令（1）: ls 2022年我在使用这些vim插件 Docker 技术整理 shell速查表 nginx配置记录 linux下修改按键ESC&amp;lt;=&amp;gt;CAPSLOCK和Control=&amp;gt;ALT_R [转]字符编解码的故事（ASCII，ANSI，Unicode，Utf-8区别） docker报错集锦 CentOS7使用Firewalld docker备份恢复之save与export sudo命令免密码设置 600 条最强 Linux 命令总结 搭建Maven私服-Nexus CentOS7安装配置匿名访问Samba 解决粘贴到vim缩进错乱问题 进入docker容器命令制作 docker数据管理 docker容器 docker仓库 CentOS修改DNS/GW/IP Dockerfile指令详解 docker镜像 docker初体验 linux无损调整分区大小 解决linux下zip文件解压乱码 Vim命令速查表 如何在linux中搭建ftp服务 </description>
    </item>
    <item>
      <title>Python</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/</guid>
      <description> 9款最佳Python脚本：让工作自动化起来！ 1 顺序表 2 单链表 3 栈 6 小时 Python 入门 Anaconda 入门指南 Jupyter notebook 使用指南 Jupyter添加目录toc Pandas常用操作 PyCharm 优化使用 第八章 数据规整：聚合、合并和重塑 第二章 Python 语法基础，IPython 和 Jupyter Notebooks 第九章 绘图可视化 第六章 数据加载、存储与文件格式 第七章 数据清洗和准备 第三章 Python 的数据结构、函数和文件 第十二章 Pandas 高级应用 第十三章 Python 建模库介绍 第十四章 数据分析案例 第十一章 时间序列 第十章 数据聚合与分组运算 第四章 Numpy 基础 第五章 Pandas 入门 第一章 准备工作 附录A-NumPy高级应用 附录B-更多关于IPython的内容 Pandas最常用的15个函数 python数据分析专用数据库，与pandas结合，10倍提速&amp;#43;极致体验 数据库连接轻松搞定：Python 数据库推荐 ExcelToPDF </description>
    </item>
    <item>
      <title>Spider</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/spider/</link>
      <pubDate>Tue, 15 Aug 2023 17:56:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/spider/</guid>
      <description> 审计技能|Python语句（四）：常用查询函数 </description>
    </item>
    <item>
      <title>SQL</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/</link>
      <pubDate>Tue, 19 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/</guid>
      <description> MySQL常用函数 live_max_online MySQL常用30种SQL查询语句优化方法 SQL每日一题(20230814) SQL每日一题F0215，多种方法及思路讲解 SQL每日一题F1021，while循环操作 SQL每日一题F1025，复杂逻辑处理 SQL每日一题F1028，关联子查询 top10_sql_skills 查询连续登陆3天的用户id和登陆天数 给定用户登录表，求表中每一天的3天留存率 求占据前90%销售额的商品类型 </description>
    </item>
    <item>
      <title>System</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/system/</link>
      <pubDate>Sun, 06 Aug 2023 18:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/system/</guid>
      <description> QEMU - QuickStart WSL（适用于 Linux 的 Windows 子系统）Kali在线安装 Linux windows重装 </description>
    </item>
    <item>
      <title>VBA</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/</guid>
      <description> 【VBA案例001】实现VLOOKUP功能 【VBA案例002】一对多查询 【VBA案例003】模糊查询 【VBA案例004】自动填充表单 【VBA案例005】自动汇总表单 【VBA案例006】数据去重 【VBA案例007】多条件汇总 【VBA案例008】多条件查询 【VBA案例009】合并单元格汇总 【VBA案例010】下拉多选 【VBA案例011】合并工作表 【VBA案例012】合并工作簿 【VBA案例013】多个工作簿所有Sheet汇总到一个工作簿中 【VBA案例014】拆分工作表（上） 【VBA案例015】拆分工作表（下） 【VBA案例016】拆分工作簿 【VBA案例017】合并单元格 【VBA案例018】取消合并单元格 【VBA案例019】合并单元格自适应大小 【VBA案例020】整合工作簿 a段落处理 b表单处理 c数字 d文字 e大纲 fExcel贴数 g批注 h行列校验 i多表处理 JsonConverter j页面设置 k访谈提纲 底稿小帮手代码 更新 类模块 </description>
    </item>
    <item>
      <title>Linux-command</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/</guid>
      <description> 每天一个linux命令（25）: gzip 每天一个linux命令（58）: sort 每天一个linux命令（57）: sftp 每天一个linux命令（56）: tailf 每天一个linux命令（55）: crontab 每天一个linux命令（54）: at 每天一个linux命令（53）: watch 每天一个linux命令（52）: ps 每天一个linux命令（51）: wc 每天一个linux命令（50）: grep 每天一个linux命令（49）: cal 每天一个linux命令（48）: date 每天一个linux命令（47）: diff 每天一个linux命令（46）: ln 每天一个linux命令（45）: scp 每天一个linux命令（44）: rcp 每天一个linux命令（43）: telnet 每天一个linux命令（42）: ss 每天一个linux命令（41）: netstat 每天一个linux命令（40）: traceroute 每天一个linux命令（39）: ping 每天一个linux命令（38）: route 每天一个linux命令（37）: ifconfig 每天一个linux命令（36）: lsof 每天一个linux命令（35）: iostat 每天一个linux命令（34）: vmstat 每天一个linux命令（33）: free 每天一个linux命令（32）: top 每天一个linux命令（31）: du 每天一个linux命令（30）: df 每天一个linux命令（29）: /etc/group文件详解 每天一个linux命令（28）: chown 每天一个linux命令（27）: chgrp 每天一个linux命令（26）: chmod 每天一个linux命令（24）: tar 每天一个linux命令（23）: 用SecureCRT来上传和下载文件 每天一个linux命令（22）: find命令的参数详解 每天一个linux命令（21）: find命令之xargs 每天一个linux命令（20）: find命令之exec 每天一个linux命令（19）: find命令概览 每天一个linux命令（18）: locate 每天一个linux命令（17）: whereis 每天一个linux命令（16）: which 每天一个linux命令（15）: tail 每天一个linux命令（14）: head 每天一个linux命令（13）: less 每天一个linux命令（12）: more 每天一个linux命令（11）: nl 每天一个linux命令（10）: cat 每天一个linux命令（9）: touch 每天一个linux命令（8）: cp 每天一个linux命令（7）: mv 每天一个linux命令（6）: rmdir 每天一个linux命令（5）: rm 每天一个linux命令（4）: mkdir 每天一个linux命令（3）: pwd 每天一个linux命令（2）: cd 每天一个linux命令（1）: ls </description>
    </item>
    <item>
      <title>【VBA案例001】实现VLOOKUP功能</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B001%E5%AE%9E%E7%8E%B0vlookup%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B001%E5%AE%9E%E7%8E%B0vlookup%E5%8A%9F%E8%83%BD/</guid>
      <description>VBA实现VLOOKUP函数功能# 数据 VBA 姓名 年龄 姓名 年龄 潘全桂 24 荆琛泽 霍栋保 35 吉栋松 荆琛泽 24 百里刚晓 越伦信 25 农康雪 吉栋松 34 越伦信 桂真顺 27 霍栋保 百里刚晓 19 潘全桂 农康雪 33 桂真顺 直接附上VBA代码：# &amp;#39;Option Explicit Sub 单元格循环() Dim cel As Range Dim cel2 As Range Dim t As Double t = Timer [e6:e13] = &amp;#34;&amp;#34; For Each cel In Range(&amp;#34;a6:a13&amp;#34;) For Each cel2 In Range(&amp;#34;d6:d13&amp;#34;) If cel.Value = cel2.Value Then cel2.Offset(0, 1).</description>
    </item>
    <item>
      <title>【VBA案例002】一对多查询</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B002%E4%B8%80%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B002%E4%B8%80%E5%AF%B9%E5%A4%9A%E6%9F%A5%E8%AF%A2/</guid>
      <description>一对多查询的方法有很多，这里附上VBA代码，详细过程请看文章最后的视频。&#xA;方法一：# Sub 单元格循环() Dim i, j, k, irow Dim cel As Range Dim t As Double t = Timer Sheets(&amp;#34;查询&amp;#34;).Range(&amp;#34;a6:d65536&amp;#34;).ClearContents Dim str As String str = Sheets(&amp;#34;查询&amp;#34;).Range(&amp;#34;b3&amp;#34;) k = 5 With Sheets(&amp;#34;数据源&amp;#34;) For Each cel In .Range(&amp;#34;a2:d&amp;#34; &amp;amp; .[a65536].End(3).Row) &amp;#39;xlup If cel.Value = str Then k = k + 1 For j = 1 To 4 Sheets(&amp;#34;查询&amp;#34;).Cells(k, j) = cel.Offset(0, j - 1) Next End If Next End With MsgBox Format(Timer - t, &amp;#34;0.</description>
    </item>
    <item>
      <title>【VBA案例003】模糊查询</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B003%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B003%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2/</guid>
      <description>大家好，模糊查询，在平时工作中会经常遇到。&#xA;本期呢，会将模糊查询的两个最常用的方法分享给大家。&#xA;1、instr函数 2、like运算符&#xA;在开始之前，我建议先把上一期的【VBA案例002】一对多查询看一遍。因为本次内容是基于上次的文件衍生出来的。并且代码也大同小异。&#xA;先附上VBA代码，详细内容，请看文章最后的视频哦！~&#xA;方法一：# Sub 单元格循环() Dim i, j, k, irow Dim cel As Range Dim t As Double t = Timer Sheets(&amp;#34;查询&amp;#34;).Range(&amp;#34;a6:d65536&amp;#34;).ClearContents Dim str As String str = Sheets(&amp;#34;查询&amp;#34;).Range(&amp;#34;b3&amp;#34;) k = 5 With Sheets(&amp;#34;数据源&amp;#34;) For Each cel In .Range(&amp;#34;a2:d&amp;#34; &amp;amp; .[a65536].End(3).Row) &amp;#39;xlup &amp;#39;If cel.Value = str Then &amp;#39;If InStr(cel.Value, str) &amp;gt; 0 Then If cel.Value Like &amp;#34;*&amp;#34; &amp;amp; str &amp;amp; &amp;#34;*&amp;#34; Then k = k + 1 For j = 1 To 4 Sheets(&amp;#34;查询&amp;#34;).</description>
    </item>
    <item>
      <title>【VBA案例004】自动填充表单</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B004%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E8%A1%A8%E5%8D%95/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B004%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E8%A1%A8%E5%8D%95/</guid>
      <description>大家好！今天我们分享一个有关VBA自动填充表单的案例，帮助大家简化表单填写的过程，提高工作效率。&#xA;我们经常需要填写大量重复的表单，例如报销单、数据输入表格等，并且每个表单都有各自的字段需要填写。手动逐个填写这些表单既耗时又容易出错。&#xA;使用VBA自动填充表单可以极大地简化这一过程，让我们能够更专注于其他重要的工作。&#xA;譬如说，现在有两个表格，一个是人员清单，另一个的表单。&#xA;现在要做的是，将人员清单中的每一行信息，填到表单里，并导出为一个单独的工作簿。&#xA;下面是VBA的代码分享，你也可以观看下方的视频解析：&#xA;方法一：# Sub 表格填充() Dim i, j, k Dim xinXiSht As Worksheet Dim qingDanSht As Worksheet Set xinXiSht = ThisWorkbook.Worksheets(&amp;#34;信息卡&amp;#34;) Set qingDanSht = ThisWorkbook.Worksheets(&amp;#34;人员清单&amp;#34;) With qingDanSht For i = 2 To .Range(&amp;#34;a&amp;#34; &amp;amp; .Rows.Count).End(xlUp).Row For j = 1 To 5 xinXiSht.Range(&amp;#34;c&amp;#34; &amp;amp; j + 4) = .Cells(i, j) Next j xinXiSht.Copy ActiveWorkbook.SaveAs ThisWorkbook.Path &amp;amp; &amp;#34;\&amp;#34; &amp;amp; .Range(&amp;#34;a&amp;#34; &amp;amp; i) &amp;amp; &amp;#34;.xlsx&amp;#34; ActiveWorkbook.Close True Next i End With End Sub 方法二：# Sub 表格填充优化() Dim i, j, k Dim xinXiSht As Worksheet Dim qingDanSht As Worksheet Set xinXiSht = ThisWorkbook.</description>
    </item>
    <item>
      <title>【VBA案例005】自动汇总表单</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B005%E8%87%AA%E5%8A%A8%E6%B1%87%E6%80%BB%E8%A1%A8%E5%8D%95/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B005%E8%87%AA%E5%8A%A8%E6%B1%87%E6%80%BB%E8%A1%A8%E5%8D%95/</guid>
      <description>大家好！书接上文。&#xA;有时候，我们需要处理多个工作簿，每个工作簿中包含一些特定的信息。为了将这些信息汇总到一个表中，我们可能需要手动打开每个工作簿，然后复制粘贴所需的数据。但这样做既费时又容易出错。&#xA;所以，使用VBA依然可以解决这个问题。极大地简化这一过程，让我们能够更专注于其他重要的工作。&#xA;举个例子，现在我们有100个工作簿。&#xA;需要从里边提取员工信息汇总到一个表里边。&#xA;猜猜看，用VBA处理这些需要多久？&#xA;下面是VBA的代码分享，你也可以观看下方的视频解析：&#xA;公共函数：&#xA;Private Function filelist(folderspec, Optional pstr = &amp;#34;*.txt&amp;#34;) On Error GoTo errline Dim fs, f, f1, fc, i, farr Set fs = CreateObject(&amp;#34;Scripting.FileSystemObject&amp;#34;) Set f = fs.GetFolder(folderspec) Set fc = f.Files ReDim farr(1 To fc.Count) For Each f1 In fc If f1.Name Like pstr And Not f1.Name Like &amp;#34;*~$*&amp;#34; Then i = i + 1 farr(i) = f1.Name End If Next ReDim Preserve farr(1 To i) filelist = farr errline: End Function 方法一：# Sub 方法一() Dim i, j, k Dim filePath As String, fileAr filePath = ThisWorkbook.</description>
    </item>
    <item>
      <title>【VBA案例006】数据去重</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B006%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B006%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D/</guid>
      <description>大家好！你是否在为数据去重感到烦恼？&#xA;今天，我们将分享两种高效的 VBA 方法，帮助你轻松应对数据去重难题。&#xA;举个例子。&#xA;我们要对以下数据的产品和型号进行数据去重，保留唯一值。&#xA;以下是VBA代码，你也可以直接观看下方的视频解析：&#xA;方法一：# Sub 方法一() Range(&amp;#34;f1:h18&amp;#34;).RemoveDuplicates Array(1, 2), xlYes End Sub 方法二：# Sub 方法二第一次出现的值() Dim i, j, k Dim ar, br() ar = Range(&amp;#34;a1:c18&amp;#34;) ReDim br(1 To UBound(ar), 1 To UBound(ar, 2)) Dim d As Object, kw$ Set d = CreateObject(&amp;#34;Scripting.Dictionary&amp;#34;) &amp;#39;d.CompareMode = vbTextCompare &amp;#39;不区分大小写 For i = 1 To UBound(ar) kw = ar(i, 1) &amp;amp; ar(i, 2) If Not d.exists(kw) Then k = k + 1 For j = 1 To UBound(br, 2) br(k, j) = ar(i, j) Next j d(kw) = &amp;#34;&amp;#34; End If Next i [f1].</description>
    </item>
    <item>
      <title>【VBA案例007】多条件汇总</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B007%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%B1%87%E6%80%BB/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B007%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%B1%87%E6%80%BB/</guid>
      <description>大家好！今天回答一位网友的问题。&#xA;就是用VBA进行多条件汇总，来实现数据透视表的效果，并且要对结果进行排序。&#xA;先来看例子。&#xA;假如我们有一份产品信息表，需要对它的所有产品和型号进行汇总。左侧是原始数据，右侧是处理结果。&#xA;我们来通过三个不同的方法，来解决这个问题。其中方法一：最容易理解，适合对字典刚入门的情况。方法二：具有有一定的难度，需要对字典有更加深刻的了解。方法三：作为拓展内容。&#xA;以下是VBA代码，你也可以直接观看下方的视频解析：&#xA;方法一：# Sub 方法一() Dim i, j, k Dim ar Dim d1 As Object, d2 As Object, d3 As Object Set d1 = CreateObject(&amp;#34;Scripting.Dictionary&amp;#34;) Set d2 = CreateObject(&amp;#34;Scripting.Dictionary&amp;#34;) Set d3 = CreateObject(&amp;#34;Scripting.Dictionary&amp;#34;) ar = Range(&amp;#34;a1:c&amp;#34; &amp;amp; [a65536].End(3).Row) For i = 2 To UBound(ar) d1(ar(i, 1)) = &amp;#34;&amp;#34; d2(ar(i, 2)) = &amp;#34;&amp;#34; d3(ar(i, 1) &amp;amp; ar(i, 2)) = d3(ar(i, 1) &amp;amp; ar(i, 2)) + ar(i, 3) Next i [f2].</description>
    </item>
    <item>
      <title>【VBA案例008】多条件查询</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B008%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B008%E5%A4%9A%E6%9D%A1%E4%BB%B6%E6%9F%A5%E8%AF%A2/</guid>
      <description>大家好！今天分享的案例是多条件查询。&#xA;这个查询在进销存或者库存管理中特别常用，如果你准备或者正在做一个自己的管理查询工具，这个方法一定要会。先来看一下数据。&#xA;比如说，现在有一份产品信息表。&#xA;我们要做的是在查询页面，输入参数后，查询出所有满足条件的内容。其中参数可以不填，不填就表示要查询所有内容。&#xA;本期将使用2个方法来实现效果，以下是VBA代码，详细视频解析在文末。&#xA;方法一：# Sub 方法一() Dim i, j, k Dim ar, br() With Sheet2 ar = .Range(&amp;#34;a1:f&amp;#34; &amp;amp; .[a65536].End(3).Row) End With ReDim br(1 To UBound(ar), 1 To UBound(ar, 2)) Dim customer, product, startDate As Date, endDate As Date With Sheet1 customer = IIf(.[b2] = &amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;,&amp;#34; &amp;amp; .[b2] &amp;amp; &amp;#34;,&amp;#34;) product = IIf(.[d2] = &amp;#34;&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;,&amp;#34; &amp;amp; .[d2] &amp;amp; &amp;#34;,&amp;#34;) startDate = IIf(.[f2] = &amp;#34;&amp;#34;, #1/1/1900#, .</description>
    </item>
    <item>
      <title>【VBA案例009】合并单元格汇总</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B009%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC%E6%B1%87%E6%80%BB/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B009%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC%E6%B1%87%E6%80%BB/</guid>
      <description>大家好！今天分享一下遇到合并单元格的处理思路。&#xA;工作中，为了方便查看数据，很多朋友习惯性的把单元格合并起来，这样使得表格看起来清晰美观了不少。但这样做的同时，会给以后的计算增加很多困难。&#xA;比如下边：要计算产品的总库存。&#xA;当我们要对合并单元格进行汇总统计的时候，总会遇到很多问题。其实只要你明白合并单元格的底层逻辑之后，问题就会变的简单起来。&#xA;合并单元格：其实只保留了区域左上角的一个值，其他位置都是空的。&#xA;明白原理之后，我们再来看下VBA代码，详细解析请看文末视频。&#xA;Sub 汇总() Dim i, j, k Dim ar ar = Range(&amp;#34;a1:c&amp;#34; &amp;amp; [c65536].End(3).Row) Dim d As Object, kw$ Set d = CreateObject(&amp;#34;Scripting.Dictionary&amp;#34;) &amp;#39;d.CompareMode = vbTextCompare &amp;#39;不区分大小写 For i = 2 To UBound(ar) If ar(i, 1) = &amp;#34;&amp;#34; Then ar(i, 1) = ar(i - 1, 1) d(ar(i, 1)) = d(ar(i, 1)) + ar(i, 3) Next [F2].Resize(d.Count) = Application.WorksheetFunction.Transpose(d.keys) [g2].Resize(d.Count) = Application.WorksheetFunction.Transpose(d.items) End Sub 原始链接 </description>
    </item>
    <item>
      <title>【VBA案例010】下拉多选</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B010%E4%B8%8B%E6%8B%89%E5%A4%9A%E9%80%89/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B010%E4%B8%8B%E6%8B%89%E5%A4%9A%E9%80%89/</guid>
      <description>大家好！今天将为大家介绍在Excel中如何实现下拉多选功能，让数据输入更加灵活高效。&#xA;下拉多选功能不仅提高了数据输入的灵活性，还减少了输入错误的可能性，为我们的数据处理工作带来了更高的效率。&#xA;也许你见过使用表单控件的方式实现下拉多选，但是通过数据验证和VBA，我们同样能够轻松创建具有下拉多选功能的工作表。&#xA;以下是VBA代码，详细解析请看文末视频。&#xA;Private Sub Worksheet_Change(ByVal Target As Range) Dim rngDV As Range Dim oldVal As String Dim newVal As String Dim fenGeFu As String If Target.CountLarge &amp;gt; 1 Then Exit Sub fenGeFu = &amp;#34;,&amp;#34; &amp;#39;规定用逗号分隔 On Error Resume Next Set rngDV = Cells.SpecialCells(xlCellTypeAllValidation) If rngDV Is Nothing Then Exit Sub If Intersect(Target, rngDV) Is Nothing Then Exit Sub Application.EnableEvents = False newVal = Target.Value Application.Undo oldVal = Target.Value Target.</description>
    </item>
    <item>
      <title>【VBA案例011】合并工作表</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B011%E5%90%88%E5%B9%B6%E5%B7%A5%E4%BD%9C%E8%A1%A8/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B011%E5%90%88%E5%B9%B6%E5%B7%A5%E4%BD%9C%E8%A1%A8/</guid>
      <description>大家好！终于放假了，知了祝大家双节快乐！~&#xA;今天分享的案例非常的经典，它让我首次见识了VBA的魅力。也是从那会儿开始，命运的齿轮开始转动，走上了学习VBA的道路。&#xA;它就是：合并工作表。&#xA;问题很简单：就是把一个工作簿里的所有sheet合并到一个总表里边。&#xA;如下图：将 4个班级的信息合并。&#xA;以下是VBA代码（长按复制，可向右托动），详细解析请看文末视频。&#xA;方法一：复制粘贴# Sub 复制粘贴() Dim sht As Worksheet Dim zongSht As Worksheet Set zongSht = Worksheets(&amp;#34;总表&amp;#34;) Dim rowsCount, zongRows For Each sht In Worksheets If sht.Name &amp;lt;&amp;gt; &amp;#34;总表&amp;#34; Then With sht rowsCount = .[a65536].End(3).Row zongRows = zongSht.[a65536].End(3).Row + 1 .Range(&amp;#34;a2:d&amp;#34; &amp;amp; rowsCount).Copy zongSht.Range(&amp;#34;a&amp;#34; &amp;amp; zongRows) End With End If Next End Sub 方法二：数组# Sub 数组() Dim sht As Worksheet Dim zongSht As Worksheet Set zongSht = Worksheets(&amp;#34;总表&amp;#34;) Dim rowsCount, zongRows Dim tmpAr For Each sht In Worksheets If sht.</description>
    </item>
    <item>
      <title>【VBA案例012】合并工作簿</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B012%E5%90%88%E5%B9%B6%E5%B7%A5%E4%BD%9C%E7%B0%BF/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B012%E5%90%88%E5%B9%B6%E5%B7%A5%E4%BD%9C%E7%B0%BF/</guid>
      <description>大家好！这次分享的是非常经典的案例：合并工作簿。&#xA;相信大家已经很熟悉这个问题了，就是把多个工作簿里的工作表合并到同一个sheet里。&#xA;这次同样分享两个方法，以下是VBA代码。详细解析请看文末的视频。&#xA;自定义函数：&#xA;Private Function filelist(folderspec, Optional pstr = &amp;#34;*.txt&amp;#34;) On Error GoTo errline Dim fs, f, f1, fc, i, farr Set fs = CreateObject(&amp;#34;Scripting.FileSystemObject&amp;#34;) Set f = fs.GetFolder(folderspec) Set fc = f.Files ReDim farr(1 To fc.Count) For Each f1 In fc If f1.Name Like pstr And Not f1.Name Like &amp;#34;*~$*&amp;#34; Then i = i + 1 farr(i) = f1.Name End If Next ReDim Preserve farr(1 To i) filelist = farr errline: End Function 方法一：复制粘贴# Sub 复制粘贴() Dim i, j, k Dim fileAr fileAr = filelist(ThisWorkbook.</description>
    </item>
    <item>
      <title>【VBA案例013】多个工作簿所有Sheet汇总到一个工作簿中</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B013%E5%A4%9A%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%B0%BF%E6%89%80%E6%9C%89sheet%E6%B1%87%E6%80%BB%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%B0%BF%E4%B8%AD/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B013%E5%A4%9A%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%B0%BF%E6%89%80%E6%9C%89sheet%E6%B1%87%E6%80%BB%E5%88%B0%E4%B8%80%E4%B8%AA%E5%B7%A5%E4%BD%9C%E7%B0%BF%E4%B8%AD/</guid>
      <description>大家好！昨天视频放错了，今天重新发一下。图片&#xA;这次分享的是合并系列的最后一个案例：汇总工作簿。&#xA;打个比方：把多个工作簿中的每个Sheet，汇总到一个工作簿里，汇总完之后是所有的Sheet都在同一个工作簿里。&#xA;这次使用了Dir函数，以下是VBA代码。详细解析请看文末的视频。&#xA;&amp;lsquo;Dir函数：返回的是指定路径下【文件】或者【文件夹】的名称。如果不存在，就返回 &amp;quot;&amp;quot; 字符串 &amp;lsquo;Dir 函数一般搭配 do while 循环遍历文件，结束的条件就是Dir返回空值。&#xA;&amp;lsquo;举例： &amp;lsquo;fileName1 = Dir(&amp;ldquo;E:\test*.xlsx&amp;rdquo;) 查找E盘test文件夹里边的xlsx工作簿，将第一个工作簿名称返回 &amp;lsquo;fileName2 = Dir 查找下一个，并且不需要写参数 &amp;lsquo;fileName3 = Dir 查找下一个，并且不需要写参数 &amp;lsquo;fileName4 = Dir 查找下一个，并且不需要写参数 &amp;lsquo;&amp;hellip;&amp;hellip; &amp;hellip;&amp;hellip; &amp;lsquo;当返回 &amp;quot;&amp;quot; 的时候说明查找完了。如果直接 fileName_N = Dir 就会报错，需要重新指定参数&#xA;Sub 汇总工作簿() Dim filePath, fileName Dim sht As Worksheet filePath = ThisWorkbook.Path &amp;amp; &amp;#34;\文件夹\&amp;#34; fileName = Dir(filePath &amp;amp; &amp;#34;*.xlsx&amp;#34;) Application.ScreenUpdating = False Do While fileName &amp;lt;&amp;gt; &amp;#34;&amp;#34; With Workbooks.Open(filePath &amp;amp; fileName) For Each sht In .</description>
    </item>
    <item>
      <title>【VBA案例014】拆分工作表（上）</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B014%E6%8B%86%E5%88%86%E5%B7%A5%E4%BD%9C%E8%A1%A8%E4%B8%8A/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B014%E6%8B%86%E5%88%86%E5%B7%A5%E4%BD%9C%E8%A1%A8%E4%B8%8A/</guid>
      <description>大家好！如何按照表中的某一列，拆分成独立的Sheet? 如下：&#xA;这是一个特别常见常用的问题，本期分享本人用的最多的两个方法中的第一个。&#xA;因为确实不太容易理解，所以分为两部分。&#xA;这个方法非常的实用，在其他地方也可以发挥很大的作用，所以墙裂推荐大家掌握！&#xA;以下是VBA代码。详细解析请看文末的视频。&#xA;Sub 数组装进字典() Dim i, j, k Dim ar, tmp() Dim d As Object, kw$ Set d = CreateObject(&amp;#34;Scripting.Dictionary&amp;#34;) &amp;#39;d.CompareMode = vbTextCompare &amp;#39;不区分大小写 ar = Range(&amp;#34;a1:e&amp;#34; &amp;amp; [a65536].End(3).Row) Dim irow For i = 2 To UBound(ar) kw = ar(i, 4) If Not d.exists(kw) Then ReDim tmp(1 To 5000, 1 To UBound(ar, 2) + 1) For j = 1 To UBound(ar, 2) tmp(1, j) = ar(1, j) tmp(2, j) = ar(i, j) Next tmp(1, UBound(ar, 2) + 1) = 2 d(kw) = tmp Else tmp = d(kw) irow = tmp(1, UBound(ar, 2) + 1) + 1 For j = 1 To UBound(ar, 2) tmp(irow, j) = ar(i, j) Next tmp(1, UBound(ar, 2) + 1) = irow d(kw) = tmp End If Next i Dim dk For Each dk In d.</description>
    </item>
    <item>
      <title>【VBA案例015】拆分工作表（下）</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B015%E6%8B%86%E5%88%86%E5%B7%A5%E4%BD%9C%E8%A1%A8%E4%B8%8B/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B015%E6%8B%86%E5%88%86%E5%B7%A5%E4%BD%9C%E8%A1%A8%E4%B8%8B/</guid>
      <description>大家好！书接上文，继续聊一聊拆分工作表的第二个方法。&#xA;众所周知，字典中的值不仅可以是数字、字符串，还可以是数组和对象！&#xA;上一个方法是将数组装到了字典里，这第二个方法想必大家已经猜到了，就是把对象装进字典里。&#xA;首先简单介绍一下Union函数的使用方法。Union：返回两个或多个区域的合并区域。&#xA;语法： Union(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9, Arg10, Arg11, Arg12, Arg13, Arg14, Arg15, Arg16, Arg17, Arg18, Arg19, Arg20, Arg21, Arg22, Arg23, Arg24, Arg25, Arg26, Arg27, Arg28, Arg29, Arg30) AS Range 参数： Arg1 必需 Range类型。 Arg2 必需 Range类型。 Arg3– Arg30 可选 Variant类型。 返回： Range类型。 另外一点需要强调的是，VBA中给对象变量赋值使用Set，并且Set不能省略。&#xA;以下是VBA代码。详细解析请看文末的视频。&#xA;Sub range装进字典() Dim i, j, k Dim ar, tmp() Dim d As Object, kw$ Set d = CreateObject(&amp;#34;Scripting.Dictionary&amp;#34;) &amp;#39;d.</description>
    </item>
    <item>
      <title>【VBA案例016】拆分工作簿</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B016%E6%8B%86%E5%88%86%E5%B7%A5%E4%BD%9C%E7%B0%BF/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B016%E6%8B%86%E5%88%86%E5%B7%A5%E4%BD%9C%E7%B0%BF/</guid>
      <description>大家好！&#xA;通过本次和之前几次的分享。对工作表、工作簿的拆分、合并都做了最基础的介绍以及案例演示。&#xA;而面对实际工作中经常遇到的工作表、工作簿的合并拆分问题，相信大家通过对这几个案例的交汇融合，基本上都可以找到对应的解决方案。&#xA;今天分享的是拆分系列的最有一项内容：拆分工作簿。就是把一个工作簿中的所有Sheet拆分成一个一个的独立的工作簿。&#xA;通过今天的案例，你将掌握工作表对象的Move和Copy方法。听起来很陌生，其实是你经常在用的一个很普通的功能：&#xA;语法： Sheet.Copy([Before],[After])&amp;lsquo;参数可选，非必须 Sheet.Move([Before],[After])&amp;lsquo;参数可选，非必须 注意： 如果不填参数，将会把Sheet移动或复制到一个新的工作簿中 以下是VBA代码。详细解析请看文末的视频。&#xA;Option Explicit Sub 拆分工作簿() Dim sht As Worksheet Dim filePath filePath = ThisWorkbook.Path &amp;amp; &amp;#34;\&amp;#34; Application.ScreenUpdating = False For Each sht In ThisWorkbook.Worksheets If sht.Name &amp;lt;&amp;gt; &amp;#34;首页&amp;#34; Then &amp;#39;sht.Move sht.Copy ActiveWorkbook.SaveAs filePath &amp;amp; sht.Name &amp;amp; &amp;#34;.xlsx&amp;#34; ActiveWorkbook.Close End If Next Application.ScreenUpdating = True End Sub 原始链接 </description>
    </item>
    <item>
      <title>【VBA案例017】合并单元格</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B017%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B017%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC/</guid>
      <description>大家好！&#xA;合并单元格是经常遇到的操作，在WPS中，提供了非常好用的快捷按钮。遗憾的是Excel里并没有这个一键合并单元格的功能。&#xA;今天分享用VBA合并单元格的两个最常用的方法，如果你是WPS用户，虽然不需要代码，但是编程的思路，还是有参考价值的。&#xA;以下是VBA代码。详细解析请看文末的视频。&#xA;方法一：# Sub union并集函数() Dim i Dim rng As Range Set rng = [a2] Application.DisplayAlerts = False For i = 2 To 20 If Range(&amp;#34;a&amp;#34; &amp;amp; i + 1) = Range(&amp;#34;a&amp;#34; &amp;amp; i) Then Set rng = Union(rng, Range(&amp;#34;a&amp;#34; &amp;amp; i + 1)) Else rng.Merge Set rng = Range(&amp;#34;a&amp;#34; &amp;amp; i + 1) End If Next i Application.DisplayAlerts = True End Sub 方法二：# Sub 循环数组() Dim i, j, ar Dim start_row, end_row ar = [a1:a20] start_row = 2 Application.</description>
    </item>
    <item>
      <title>【VBA案例018】取消合并单元格</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B018%E5%8F%96%E6%B6%88%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B018%E5%8F%96%E6%B6%88%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC/</guid>
      <description>大家好！&#xA;上一篇内容分享了，用VBA合并单元格的两个方法。本期就来看一下如何取消合并的单元格。&#xA;同样的，WPS内置了一键取消合并单元格并填充内容的功能，而Excel用户只能流下羡慕的泪水。&#xA;这次介绍两个方法，来实现和WPS一模一样的功能。&#xA;第一个方法：使用录制宏的操作，把平时手动取消合并的操作记录下来，并对代码加以修改，来达到目的。第二个方法：使用的循环单元格判断是否合并的方法，其中有几个常用的属性是我们必须要了解掌握的。&#xA;两个方法都比较简单。大家可以根据实际情况，酌情选择适用的方法。&#xA;以下是VBA代码。详细解析请看文末的视频。&#xA;方法一：# Sub 宏2() Range(&amp;#34;a1:a20&amp;#34;).UnMerge Range(&amp;#34;a1:a20&amp;#34;).SpecialCells(xlCellTypeBlanks).FormulaR1C1 = &amp;#34;=R[-1]C&amp;#34; Range(&amp;#34;a1:a20&amp;#34;).Value = Range(&amp;#34;a1:a20&amp;#34;).Value End Sub 方法二：# Sub 取消合并单元格() Dim cel As Range Dim mRng As Range Dim mRngVal For Each cel In Range(&amp;#34;a1:a20&amp;#34;) If cel.MergeCells Then Set mRng = cel.MergeArea mRngVal = mRng(1, 1) mRng.UnMerge mRng.Value = mRngVal End If Next End Sub 原始链接 </description>
    </item>
    <item>
      <title>【VBA案例019】合并单元格自适应大小</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B019%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B019%E5%90%88%E5%B9%B6%E5%8D%95%E5%85%83%E6%A0%BC%E8%87%AA%E9%80%82%E5%BA%94%E5%A4%A7%E5%B0%8F/</guid>
      <description>大家好！&#xA;如果你是文职类工作，可能会遇到下面这种情况：&#xA;经常面对各种各样的表格，并且很多都是制式的，里边又充满个各种各样的格式，其中就有今天的主角儿：合并单元格。&#xA;而你的工作看似也不复杂，就是把合并单元格中显示不全的内容，通过调整单元格的大小来显示出来。&#xA;这种痛苦，只有手动调整过的人能懂。&#xA;所以，通过今天的案例讲解，将解决你的烦恼，文末视频对这个过程做了详细的讲解演示，希望对你有帮助。&#xA;以下是VBA代码。详细解析请看文末的视频。&#xA;调整合并单元格行高：&#xA;Sub 调整合并单元格行高() Dim cel As Range Dim rng As Range Dim n, r, c Dim mergeWidth, newHeight, celWidth Set rng = Range(&amp;#34;B4&amp;#34;) For Each cel In rng If cel.MergeCells Then With cel.MergeArea mergeWidth = 0 For Each c In .Columns &amp;#39;合并区域中的每一个单元格 mergeWidth = mergeWidth + c.ColumnWidth &amp;#39;新合并区域列宽=每一列列宽宽的和 Next .MergeCells = False &amp;#39;取消合并单元格 With .Cells(1) .WrapText = True &amp;#39;自动换行 celWidth = .ColumnWidth &amp;#39;记录取消合并后列宽，目的是调整回去 .</description>
    </item>
    <item>
      <title>【VBA案例020】整合工作簿</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B020%E6%95%B4%E5%90%88%E5%B7%A5%E4%BD%9C%E7%B0%BF/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/vba%E6%A1%88%E5%88%97/vba%E6%A1%88%E4%BE%8B020%E6%95%B4%E5%90%88%E5%B7%A5%E4%BD%9C%E7%B0%BF/</guid>
      <description>大家好！今天回答一位粉丝朋友的提问。&#xA;问题是：将多个工作簿中的所有工作表合并汇总，要求名称相同的工作表内容要合并在一起，名称不同的要单独作为一个工作表。&#xA;为此，我模拟了一份数据，结构如下图：&#xA;这个问题，其实是我之前分享的【案例011合并工作表】和【案例013汇总工作簿】的融合版。方法非常的相似。其实对于工作簿和工作表的合并与拆分的操作，之前的案例基本都分享完了。只要融会贯通，举一反三，相信这种问题将迎刃而解。&#xA;效果就不演示了，以下是VBA代码。详细解析请看文末的视频。&#xA;Option Explicit Sub 汇总合并工作簿() Dim shtName Dim sht As Worksheet For Each sht In ThisWorkbook.Worksheets shtName = shtName &amp;amp; &amp;#34;,&amp;#34; &amp;amp; sht.Name Next Dim filePath$, fileName As String filePath = ThisWorkbook.Path &amp;amp; &amp;#34;\文件夹\&amp;#34; fileName = Dir(filePath &amp;amp; &amp;#34;*.xlsx&amp;#34;) Dim row_count, thisRow_count Application.ScreenUpdating = False Do While fileName &amp;lt;&amp;gt; &amp;#34;&amp;#34; With Workbooks.Open(filePath &amp;amp; fileName) For Each sht In .Worksheets If InStr(&amp;#34;,&amp;#34; &amp;amp; shtName &amp;amp; &amp;#34;,&amp;#34;, &amp;#34;,&amp;#34; &amp;amp; sht.</description>
    </item>
    <item>
      <title>9款最佳Python脚本：让工作自动化起来！</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/9%E6%AC%BE%E6%9C%80%E4%BD%B3python%E8%84%9A%E6%9C%AC%E8%AE%A9%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%B5%B7%E6%9D%A5/</link>
      <pubDate>Sun, 22 Oct 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/9%E6%AC%BE%E6%9C%80%E4%BD%B3python%E8%84%9A%E6%9C%AC%E8%AE%A9%E5%B7%A5%E4%BD%9C%E8%87%AA%E5%8A%A8%E5%8C%96%E8%B5%B7%E6%9D%A5/</guid>
      <description>一、自动化文件管理# 1.在目录中对文件进行排序# # Python脚本用于按文件扩展名对目录中的文件进行排序 import os from shutil import move def sort_files(directory_path): for filename in os.listdir(directory_path): if os.path.isfile(os.path.join(directory_path, filename)): file_extension = filename.split(&amp;#39;.&amp;#39;)[-1] destination_directory = os.path.join(directory_path, file_extension) if not os.path.exists(destination_directory): os.makedirs(destination_directory) move(os.path.join(directory_path, filename), os.path.join(destination_directory, filename) 这个Python脚本通过根据文件扩展名将文件分类到子目录中来整理目录中的文件。&#xA;它识别文件扩展名并将文件移动到相应的子目录中。这对于清理下载文件夹或为特定项目组织文件非常有用。&#xA;2.删除空文件# # 用Python脚本删除目录中的空文件夹 import os def remove_empty_folders(directory_path): for root, dirs, files in os.walk(directory_path, topdown=False): for folder in dirs: folder_path = os.path.join(root, folder) if not os.listdir(folder_path): os.rmdir(folder_path) 此Python脚本在指定目录中搜索并删除空文件夹。它可以帮助您保持整洁的文件夹结构，特别是在处理大量数据集时。&#xA;3.重命名多个文件# # 用Python脚本重命名目录中的多个文件 import os def rename_files(directory_path, old_name, new_name): for filename in os.</description>
    </item>
    <item>
      <title>1 顺序表</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1-%E9%A1%BA%E5%BA%8F%E8%A1%A8/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1-%E9%A1%BA%E5%BA%8F%E8%A1%A8/</guid>
      <description>突发奇想，想用Python把数据结构的知识再过一遍，所以就开始从顺序表从头来一遍，Python内置了一些功能，感觉只需要定义方法调用就好了，或者不想这么干的话，直接调用内置的方法咯。&#xA;list 是一种元素个数可变的线性表，采用了分离式技术实现的动态顺序表。可以加入和删除元素，并在各种操作中维持已有元素的顺序（即保序）。&#xA;1.1 创建顺序表# # 创建顺序表 def CreateSeqList(self): element = input(&amp;#34;please enter(input #:end):&amp;#34;) while element != &amp;#39;#&amp;#39;: self.seqList.append(int(element)) element = input(&amp;#34;please enter(input #:end):&amp;#34;) 1.2 查找元素# # 查找顺序表中某一个元素 def FindElement(self): key = int(input(&amp;#34;please enter what you want to find:&amp;#34;)) if key in self.seqList: keyPosition = self.seqList.index(key) result = keyPosition else: result = &amp;#34;none&amp;#34; return result 1.3 插入元素# # 在指定位置上插入元素 def InsertElement(self): postion = int(input(&amp;#34;请输入要插入的位置：&amp;#34;)) key = int(input(&amp;#34;请输入要插入的值：&amp;#34;)) print(&amp;#34;插入前顺序：&amp;#34;, self.seqList) self.seqList.insert(postion, key) print(&amp;#34;插入后顺序：&amp;#34;, self.</description>
    </item>
    <item>
      <title>2 单链表</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2-%E5%8D%95%E9%93%BE%E8%A1%A8/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2-%E5%8D%95%E9%93%BE%E8%A1%A8/</guid>
      <description>单链表是一种链式的数据结构，链表中的数据用结点表示，保持了数据之间的逻辑关系，但存储空间不一定是按照顺序存储。&#xA;链表的基本元素有：&#xA;节点：包括数据域和指针域，数据域存放数据，指针域存放指向下一个元素的指针 head：头结点 tail：尾结点 None：链表最后一个结点的指针域为None Python中没有显式的指针，但是有引用啊，所以我们可以通过定义节点类和引用来实现链表！&#xA;链表分为单链表和单循环链表，双向链表和双向循环链表，本篇先讲一下单链表：&#xA;2.1 定义节点类# 节点类中包括节点数据和下一个节点地址，即引用&#xA;# 节点类 class Node(object): # 单个节点 初始化 输入一个值data，将值变为一个节点 def __init__(self, data): self.data = data self.next = None # 打印对象中具体的属性值 def __str__(self): # 测试基本功能，输出data return self.data # 输出data print(Node(&amp;#39;data&amp;#39;)) 这里的__str__可以不用写，这里是在进行测试，在后面的具体实现部分可以不用这个，str函数可以方便我们打印对象中具体的属性值，也是很nice了！具体使用如上&#xA;2.2 获取链表的长度# # 获取链表的长度 def length(self): cur = self.head count = 0 while cur is not None: count += 1 cur = cur.next return count 2.3 头插元素# # 头部添加元素 def add_fist(self, data): node = Node(data) node.</description>
    </item>
    <item>
      <title>3 栈</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-%E6%A0%88/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3-%E6%A0%88/</guid>
      <description>栈是一种数据结构，只能从一端插入和删除操作，遵循着先进后出原则存储数据。&#xA;3.1 栈的初始化# def __init__(self): self.stack = [] # 栈列表 self.size = 20 # 栈大小 self.top = -1 # 栈顶位置 3.2 元素进栈# # 元素进栈 def push(self, element): self.stack.append(element) self.top += 1 3.3 元素出栈# # 元素出栈 def pop(self): element = self.stack[-1] self.top -= 1 del self.stack[-1] return element 这里可以直接调用pop函数，使用如下：&#xA;self.stack.pop() # 弹出栈顶元素 3.4 获取栈顶元素# # 获取栈顶位置 def getTop(self): return self.top 这里也可以直接使用列表，使用如下：&#xA;self.stack[-1] 3.5 清空栈# # 清空栈 def empty(self): self.stack = [] self.</description>
    </item>
    <item>
      <title>6 小时 Python 入门</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/6%E5%B0%8F%E6%97%B6python%E5%85%A5%E9%97%A8/6%E5%B0%8F%E6%97%B6python%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/6%E5%B0%8F%E6%97%B6python%E5%85%A5%E9%97%A8/6%E5%B0%8F%E6%97%B6python%E5%85%A5%E9%97%A8/</guid>
      <description>以下操作均在 Windows 环境下进行操作，先说明一下哈&#xA;一、安装 Python# 1、官网下载 Python&#xA;进入官网（https://www.python.org ），点击 Downloads，选择要下载的版本：&#xA;2、安装 Python&#xA;安装时注意下图勾选部分一定要勾选：&#xA;二、安装代码编辑器 PyCharm# 1、官网下载 PyCharm&#xA;进入官网（https://www.jetbrains.com/pycharm ），点击 Downloads，选择要下载的版本：&#xA;2、安装 PyCharm&#xA;设置安装路径之后，一直点 next 即可。&#xA;3、优化 PyCharm 使用&#xA;三、HelloWorld# 创建第一个项目 HelloWorld &amp;ndash;&amp;gt; 创建文件 app.py &amp;ndash;&amp;gt; 写入代码：&#xA;print(&amp;#34;HelloWorld&amp;#34;) 效果图：&#xA;四、Python 语法# 看语法部分之前，推荐直接看下面入门练习题，潜移默化中对 Python 基本语法会有一定了解之后，再回来看这一部分，会更加熟悉 Python 的使用！&#xA;五、入门练习题# 1.打印 10 个 *# 使用到表达式&#xA;print(&amp;#39;*&amp;#39; * 10) 2.打印价格# 使用到变量&#xA;price = 10 print(price) 3.描述医院病人的信息# #!/usr/bin/env python3 # -*- coding: utf-8 -*- &amp;#34;&amp;#34;&amp;#34; @Time : 2020/5/18 @Author : WuGenQiang @File : hospital @Description : 描述医院病人的信息 &amp;#34;&amp;#34;&amp;#34; full_name = &amp;#39;John Smith&amp;#39; age = 20 is_new = True 4.</description>
    </item>
    <item>
      <title>Anaconda 入门指南</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/anaconda/anaconda%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/anaconda/anaconda%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</guid>
      <description>一、下载安装 Anaconda# 1、下载地址：Anaconda 推荐下载 python3 版本, 毕竟未来 python2 是要停止维护的。&#xA;2、安装 Anaconda&#xA;按照安装程序提示一步步安装就好了, 安装完成之后会多几个应用：&#xA;Anaconda Navigtor ：用于管理工具包和环境的图形用户界面，后续涉及的众多管理命令也可以在 Navigator 中手工实现。 Jupyter notebook ：基于 web 的交互式计算环境，可以编辑易于人们阅读的文档，用于展示数据分析的过程。 qtconsole ：一个可执行 IPython 的仿终端图形界面程序，相比 Python Shell 界面，qtconsole 可以直接显示代码生成的图形，实现多行代码输入执行，以及内置许多有用的功能和函数。 spyder ：一个使用 Python 语言、跨平台的、科学运算集成开发环境。 二、配置环境变量# 如果是 windows 的话需要去 控制面板\系统和安全\系统\高级系统设置\环境变量\用户变量\PATH 中添加 anaconda 的安装目录的 Scripts 文件夹，比如我的路径是D:\developer_tools\python3\Anaconda3\Scripts，看个人安装路径不同需要自己调整。&#xA;之后就可以打开命令行(最好用管理员模式打开) 输入 conda --version&#xA;如果输出conda 4.8.2之类的就说明环境变量设置成功了。&#xA;为了避免可能发生的错误，我们在命令行输入conda upgrade --all 先把所有工具包进行升级。&#xA;三、管理虚拟环境# 接下来我们就可以用 Anaconda 来创建我们一个个独立的 Python 环境了。接下来的例子都是在命令行操作的，请打开你的命令行吧。&#xA;1. activate# activate 能将我们引入 anaconda 设定的虚拟环境中，如果你后面什么参数都不加那么会进入 anaconda 自带的 base 环境。</description>
    </item>
    <item>
      <title>Git 的使用</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/git/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/git/</guid>
      <description>1 前言# 1.1 Git 与 GitHub 的来历# Linux 之父 Linus 在 1991 年创建开源的 Linux 操作系统之后，多年来依靠全世界广大热心志愿者的共同建设，经过长足发展，现已成为世界上最大的服务器系统。系统创建之初，代码贡献者将源码文件发送给 Linus，由其手动合并。这种方式维持多年后，代码量已经庞大到人工合并难以为继，于是深恶集中式版本控制系统的 Linus 选择了一个分布式商业版本控制系统 BitKeeper，不过 Linux 社区的建设者们可以免费使用它。BitKeeper 改变了 Linus 对版本控制的认识，同时 Linus 发现 BitKeeper 有一些不足，而且有个关键性的问题使之不能被广泛使用，就是不开源。&#xA;在 2005 年，BitKeeper 所在公司发现 Linux 社区有人企图破解它，BitKeeper 决定收回 Linux 社区的免费使用权。Linus 对此事调节数周无果，找遍了当时已知的各种版本控制系统，没有一个看上眼的，一怒之下决定自己搞一个。Linus 花了十天时间用 C 语言写好了一个开源的版本控制系统，就是著名的 Git。&#xA;2007 年旧金山三个年轻人觉得 Git 是个好东西，就搞了一个公司名字叫 GitHub，第二年上线了使用 Ruby 编写的同名网站 GitHub，这是一个基于 Git 的免费代码托管网站（有付费服务）。十年间，该网站迅速蹿红，击败了实力雄厚的 Google Code，成为全世界最受欢迎的代码托管网站。2018 年 6 月，GitHub 被财大气粗的 Microsoft 收购。2019 年 1 月 GitHub 宣布用户可以免费创建私有仓库。根据 2018 年 10 月的 GitHub 年度报告显示，目前有 3100 万开发者创建了 9600 万个项目仓库，有 210 万企业入驻。</description>
    </item>
    <item>
      <title>Jupyter notebook 使用指南</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/jupyter-notebook%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/jupyter-notebook%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid>
      <description>前言# 在我们的日常学习中，能够编写和运行 Python 文件的程序很多，比如 Python 安装自带的 IDE、程序员喜爱的Pycharm、数据科学全家桶 Anaconda，还有 Spyder、Thonny 等。就我个人使用而言，如果进行大型项目推荐使用 Pycharm，如果进行数据处理和分析，最好选用 Jupyter notebook。可以说，Jupyter notebook 是用Python 进行数据科学、机器学习的必备工具。&#xA;🔊 突出优点：&#xA;学习 Jupyter notebook 非常容易，按照我的教程一步一步做，再自己尝试一下，之后写代码即可健步如飞。&#xA;能够独立运行一个、几个或全部 Python 代码块，更容易看到中间变量的值，从而进行调试&#xA;可以插入 Markdown 说明文字和 Latex 数学公式，让枯燥的代码充满颜值，可读性爆表&#xA;能够调用 Ipython 丰富的“魔法函数”，比如程序计时、重复运行、显示图片等&#xA;写好的代码和文档能够以网页和 ppt 的形式在线分享。在线看 Jupyter notebook 文件 可以在云端远程服务器运行，不需本地安装配置各种环境。体验一下 🔔 文件中包含了 Markdown 说明文档、代码块、代码运行结果、图片嵌入等元素，特别适合 Python 数据科学和机器学习撰写文档。&#xA;🔔 吴恩达的《深度学习》慕课的课后编程作业、大数据竞赛网站 Kaggle 上的代码文档、美国大学的数据科学课程的课后资料及编程作业，都是以 Jupyter notebook 文件的形式给出的，也就是.ipynb文件。&#xA;其实 Jupyter notebook 不止可以运行 Python，还可以运行 Julia、R、Javascript 等语言，这也是jupyter这个名字的由来。Jupyter notebook 支持的编程语言 🔔 Jupyter notebook 集编程和写作于一身，这就叫做“文学编程”。&#xA;安装和运行# 在浏览器网页中运行 Python&#xA;Ipython 内核# Ipython 是更高级的 Python 解释器，而 Jupyter notebook 是基于 Ipython 内核的，在浏览器中以网页形式运行 Python 代码的工具，十分方便。</description>
    </item>
    <item>
      <title>Jupyter添加目录toc</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/anaconda/jupyter%E6%B7%BB%E5%8A%A0toc/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/anaconda/jupyter%E6%B7%BB%E5%8A%A0toc/</guid>
      <description>最近在使用Jupyter notebook的时候感觉到，没有个目录真心难受，当想查找需要的函数的时候，不能很快速的找到，这个时候，要是有个目录就好很多了，很不幸的是，默认Jupyter notebook事没有生成目录这个功能的，但很巧的是，有人已经开发了Jupyter插件，里面包含toc目录功能，开森 🦞&#xA;效果图如下：&#xA;同时toc目录的大小和位置可以随意改变，也支持对每个标题自动编号，默认的就挺好哈哈哈。&#xA;如何安装呢？&#xA;第一步：安装Jupyter notebook&#xA;这个不用说应该都安装了吧，数据分析特别好用的工具，没有之一。&#xA;第二步：安装Jupyter notebook extensions&#xA;conda install -c conda-forge jupyter_contrib_nbextensions 第三步：开启toc插件&#xA;重新运行Jupyter notebook，会发现，多了Nbextensions按钮，点击这个tab，按照下图操作：&#xA;注意：旧版本可能不支持，试试把disable configuration那行前面的✅取消掉再试试，我就是遇到这个问题。&#xA;第四步：生成目录&#xA;创建或者打开一个Jupyter notebook，会发现，多了一个生成目录图标，同时左侧已经支持了目录显示。&#xA;📚 Reference&#xA;[1] https://zhuanlan.zhihu.com/p/24029578/ [2] https://github.com/ipython-contrib/jupyter_contrib_nbextensions [3] https://jupyter-contrib-nbextensions.readthedocs.io/en/latest/install.html </description>
    </item>
    <item>
      <title>Pandas常用操作</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/pandas/pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/pandas/pandas%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid>
      <description></description>
    </item>
    <item>
      <title>PyCharm 优化使用</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/pycharm%E4%BC%98%E5%8C%96%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/pycharm%E4%BC%98%E5%8C%96%E4%BD%BF%E7%94%A8/</guid>
      <description>设置 Python 路径（解释器设置）# 1、打开设置对话框&#xA;点击File &amp;ndash;&amp;gt; settings，弹出设置对话框&#xA;2、设置 Python 路径（解释器设置）&#xA;点击 Project &amp;ndash;&amp;gt; Project Interpreter，在右侧 Project Interpreter 下拉，选择 python 路径（若没有，选择 show all），实现 pycharm的 python 路径设置。&#xA;然后如下图操作即可&#xA;设置成功显示下图&#xA;编码设置# Python 的编码问题由来已久，为了避免一步一坑， Pycharm 提供了方便直接的解决方案 在 IDE Encoding、Project Encoding、Property Files 三处都使用 UTF-8 编码，同时在文件头添加&#xA;#-*- coding: utf-8 -* 快捷键风格# 对于常用的快捷键，可以设置为自己熟悉的风格，我选的是 Eclipse。&#xA;File &amp;ndash;&amp;gt; Setting &amp;ndash;&amp;gt; Keymap &amp;ndash;&amp;gt; Keymaps &amp;ndash;&amp;gt; XXX &amp;ndash;&amp;gt; Apply&#xA;改变字体大小# 1、修改代码栏字体&#xA;通过 File &amp;ndash;&amp;gt; Setting &amp;ndash;&amp;gt; Editor &amp;ndash;&amp;gt; Font 调节&#xA;2、修改菜单栏列表框字体</description>
    </item>
    <item>
      <title>Python pandas数据分析基础100问(有重复)</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python-pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80100%E9%97%AE%E6%9C%89%E9%87%8D%E5%A4%8D/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python-pandas%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80100%E9%97%AE%E6%9C%89%E9%87%8D%E5%A4%8D/</guid>
      <description>题目来自B站上看的一个讲爬虫的老师发的视频，不过代码没完全照那人的来，由于在平板上写的代码，就没有执行结果，感兴趣自行到B站搜原视频。&#xA;import pandas as pd 1、将list转为dataframe&#xA;ls = [(&amp;#34;join&amp;#34;, 25, &amp;#34;male&amp;#34;), (&amp;#34;lisa&amp;#34;, 29, &amp;#34;female&amp;#34;), (&amp;#34;david&amp;#34;, 27, &amp;#34;male&amp;#34;)``df = pd.DataFrame(ls, columns=[&amp;#34;name&amp;#34;, &amp;#34;age&amp;#34;, &amp;#34;gender&amp;#34;])``display(df) 2、从csv文件中读取数据&#xA;df = pd.read_csv(&amp;#34;filenpath&amp;#34;, encoding=&amp;#34;utf8&amp;#34;)``# filepath_or_buffer: filepath 文件路径``# usecols: 需要读取的行列表``# nrows: 读取的行数``# na_values: 空值``# encoding: 编码格式 3、将dataframe导入到mysql&#xA;from sqlalchemy import create_engine``from sqlclchemy.type import *``df = pd.DataFrame() # 数据集``# 创建引擎``conn = create_engine(&amp;#34;mysql+mysqlconnector://username:password@127.0.0.1:3306/db_name&amp;#34;)``# 写入到数据库``df.to_sql(&amp;#34;table_name&amp;#34;, engine) 4、查看一个dataframe的行数、列数&#xA;# 行``df.shape[0]``# 列``df.shape[1] 5、查看dataframe的列名&#xA;df.columns # serise格式``df.columns.tolist() # list格式 6、查看dataframe索引&#xA;df.index # series格式``df.index.tolist() 7、查看pandas库的版本号</description>
    </item>
    <item>
      <title>第八章 数据规整：聚合、合并和重塑</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch08-%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%E8%81%9A%E5%90%88%E5%90%88%E5%B9%B6%E5%92%8C%E9%87%8D%E5%A1%91/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch08-%E6%95%B0%E6%8D%AE%E8%A7%84%E6%95%B4%E8%81%9A%E5%90%88%E5%90%88%E5%B9%B6%E5%92%8C%E9%87%8D%E5%A1%91/</guid>
      <description>在许多应用中，数据可能分散在许多文件或数据库中，存储的形式也不利于分析。本章关注可以聚合、合并、重塑数据的方法。&#xA;首先，我会介绍pandas的层次化索引，它广泛用于以上操作。然后，我深入介绍了一些特殊的数据操作。在第14章，你可以看到这些工具的多种应用。&#xA;8.1 层次化索引# 层次化索引（hierarchical indexing）是pandas的一项重要功能，它使你能在一个轴上拥有多个（两个以上）索引级别。抽象点说，它使你能以低维度形式处理高维度数据。我们先来看一个简单的例子：创建一个Series，并用一个由列表或数组组成的列表作为索引：&#xA;In [9]: data = pd.Series(np.random.randn(9), ...: index=[[&amp;#39;a&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39;d&amp;#39;], ...: [1, 2, 3, 1, 3, 1, 2, 2, 3]]) In [10]: data Out[10]: a 1 -0.204708 2 0.478943 3 -0.519439 b 1 -0.555730 3 1.965781 c 1 1.393406 2 0.092908 d 2 0.281746 3 0.769023 dtype: float64 看到的结果是经过美化的带有MultiIndex索引的Series的格式。索引之间的“间隔”表示“直接使用上面的标签”：&#xA;In [11]: data.index Out[11]: MultiIndex(levels=[[&amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;c&amp;#39;, &amp;#39;d&amp;#39;], [1, 2, 3]], labels=[[0, 0, 0, 1, 1, 2, 2, 3, 3], [0, 1, 2, 0, 2, 0, 1, 1, 2]]) 对于一个层次化索引的对象，可以使用所谓的部分索引，使用它选取数据子集的操作更简单：</description>
    </item>
    <item>
      <title>第二章 Python 语法基础，IPython 和 Jupyter Notebooks</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch02-python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E5%92%8Cipython%E4%BB%A5%E5%8F%8Ajupyternotebooks/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch02-python%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E5%92%8Cipython%E4%BB%A5%E5%8F%8Ajupyternotebooks/</guid>
      <description>我们现在使用的库，有 pandas、scikit-learn 和 statsmodels，2017年，数据科学、数据分析和机器学习的资源已经很多，原来通用的科学计算拓展到了计算机科学家、物理学家和其它研究领域的工作人员。学习 Python 和成为软件工程师的优秀书籍也有了。&#xA;因为这本书是专注于 Python 数据处理的，对于一些 Python 的数据结构和库的特性难免不足。因此，本章和第 3 章的内容只够你能学习本书后面的内容。&#xA;在我来看，没有必要为了数据分析而去精通 Python。我鼓励你使用IPython shell和Jupyter试验示例代码，并学习不同类型、函数和方法的文档。虽然我已尽力让本书内容循序渐进，但读者偶尔仍会碰到没有之前介绍过的内容。&#xA;本书大部分内容关注的是基于表格的分析和处理大规模数据集的数据准备工具。为了使用这些工具，必须首先将混乱的数据规整为整洁的表格（或结构化）形式。幸好，Python 是一个理想的语言，可以快速整理数据。Python 使用得越熟练，越容易准备新数据集以进行分析。&#xA;最好在 IPython 和 Jupyter 中亲自尝试本书中使用的工具。当你学会了如何启动 Ipython 和 Jupyter，我建议你跟随示例代码进行练习。与任何键盘驱动的操作环境一样，记住常见的命令也是学习曲线的一部分。&#xA;笔记：本章没有介绍Python的某些概念，如类和面向对象编程，你可能会发现它们在Python数据分析中很有用。 为了加强Python知识，我建议你学习官方Python教程，https://docs.python.org/3/，或是通用的Python教程书籍，比如：&#xA;Python Cookbook，第3版，David Beazley和Brian K. Jones著（O’Reilly） 流畅的Python，Luciano Ramalho著 (O’Reilly) 高效的Python，Brett Slatkin著 (Pearson) 2.1 Python解释器# Python是解释性语言。Python解释器同一时间只能运行一个程序的一条语句。标准的交互Python解释器可以在命令行中通过键入python命令打开：&#xA;wugenqiang@bogon ~ % python Python 3.8.3 (default, Jul 2 2020, 11:26:31) [Clang 10.0.0 ] :: Anaconda, Inc. on darwin Type &amp;#34;help&amp;#34;, &amp;#34;copyright&amp;#34;, &amp;#34;credits&amp;#34; or &amp;#34;license&amp;#34; for more information.</description>
    </item>
    <item>
      <title>第九章 绘图可视化</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch09-%E7%BB%98%E5%9B%BE%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%96/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch09-%E7%BB%98%E5%9B%BE%E5%92%8C%E5%8F%AF%E8%A7%86%E5%8C%96/</guid>
      <description>信息可视化（也叫绘图）是数据分析中最重要的工作之一。它可能是探索过程的一部分，例如，帮助我们找出异常值、必要的数据转换、得出有关模型的idea等。另外，做一个可交互的数据可视化也许是工作的最终目标。&#xA;Python有许多库进行静态或动态的数据可视化，但我这里重要关注于matplotlib（http://matplotlib.org/）和基于它的库。&#xA;matplotlib是一个用于创建出版质量图表的桌面绘图包（主要是2D方面）。该项目是由John Hunter于2002年启动的，其目的是为Python构建一个MATLAB式的绘图接口。matplotlib和IPython社区进行合作，简化了从IPython shell（包括现在的Jupyter notebook）进行交互式绘图。matplotlib支持各种操作系统上许多不同的GUI后端，而且还能将图片导出为各种常见的矢量（vector）和光栅（raster）图：PDF、SVG、JPG、PNG、BMP、GIF等。除了几张，本书中的大部分图都是用它生成的。&#xA;随着时间的发展，matplotlib衍生出了多个数据可视化的工具集，它们使用matplotlib作为底层。其中之一是seaborn（http://seaborn.pydata.org/），本章后面会学习它。&#xA;学习本章代码案例的最简单方法是在Jupyter notebook进行交互式绘图。在Jupyter notebook中执行下面的语句：&#xA;%matplotlib notebook 9.1 matplotlib API入门# matplotlib的通常引入约定是：&#xA;In [11]: import matplotlib.pyplot as plt 在Jupyter中运行%matplotlib notebook（或在IPython中运行%matplotlib），就可以创建一个简单的图形。如果一切设置正确，会看到图9-1：&#xA;In [12]: import numpy as np In [13]: data = np.arange(10) In [14]: data Out[14]: array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) In [15]: plt.plot(data) 虽然seaborn这样的库和pandas的内置绘图函数能够处理许多普通的绘图任务，但如果需要自定义一些高级功能的话就必须学习matplotlib API。&#xA;笔记：虽然本书没有详细地讨论matplotlib的各种功能，但足以将你引入门。matplotlib的示例库和文档是学习高级特性的最好资源。&#xA;9.1.1 Figure和Subplot# matplotlib的图像都位于Figure对象中。你可以用plt.figure创建一个新的Figure：&#xA;In [16]: fig = plt.figure() 如果用的是IPython，这时会弹出一个空窗口，但在Jupyter中，必须再输入更多命令才能看到。plt.figure有一些选项，特别是figsize，它用于确保当图片保存到磁盘时具有一定的大小和纵横比。&#xA;不能通过空Figure绘图。必须用add_subplot创建一个或多个subplot才行：&#xA;In [17]: ax1 = fig.add_subplot(2, 2, 1) 这条代码的意思是：图像应该是2×2的（即最多4张图），且当前选中的是4个subplot中的第一个（编号从1开始）。如果再把后面两个subplot也创建出来，最终得到的图像如图9-2所示：</description>
    </item>
    <item>
      <title>第六章 数据加载、存储与文件格式</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch06-%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%AD%98%E5%82%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch06-%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%AD%98%E5%82%A8%E4%B8%8E%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</guid>
      <description>访问数据是使用本书所介绍的这些工具的第一步。我会着重介绍pandas的数据输入与输出，虽然别的库中也有不少以此为目的的工具。&#xA;输入输出通常可以划分为几个大类：读取文本文件和其他更高效的磁盘存储格式，加载数据库中的数据，利用Web API操作网络资源。&#xA;6.1 读写文本格式的数据# pandas提供了一些用于将表格型数据读取为DataFrame对象的函数。表6-1对它们进行了总结，其中read_csv和read_table可能会是你今后用得最多的。&#xA;我将大致介绍一下这些函数在将文本数据转换为DataFrame时所用到的一些技术。这些函数的选项可以划分为以下几个大类：&#xA;索引：将一个或多个列当做返回的DataFrame处理，以及是否从文件、用户获取列名。 类型推断和数据转换：包括用户定义值的转换、和自定义的缺失值标记列表等。 日期解析：包括组合功能，比如将分散在多个列中的日期时间信息组合成结果中的单个列。 迭代：支持对大文件进行逐块迭代。 不规整数据问题：跳过一些行、页脚、注释或其他一些不重要的东西（比如由成千上万个逗号隔开的数值数据）。 因为工作中实际碰到的数据可能十分混乱，一些数据加载函数（尤其是read_csv）的选项逐渐变得复杂起来。面对不同的参数，感到头痛很正常（read_csv有超过50个参数）。pandas文档有这些参数的例子，如果你感到阅读某个文件很难，可以通过相似的足够多的例子找到正确的参数。&#xA;其中一些函数，比如pandas.read_csv，有类型推断功能，因为列数据的类型不属于数据类型。也就是说，你不需要指定列的类型到底是数值、整数、布尔值，还是字符串。其它的数据格式，如HDF5、Feather和msgpack，会在格式中存储数据类型。&#xA;日期和其他自定义类型的处理需要多花点工夫才行。首先我们来看一个以逗号分隔的（CSV）文本文件：&#xA;In [8]: !cat examples/ex1.csv a,b,c,d,message 1,2,3,4,hello 5,6,7,8,world 9,10,11,12,foo 笔记：这里，我用的是Unix的cat shell命令将文件的原始内容打印到屏幕上。如果你用的是Windows，你可以使用type达到同样的效果。&#xA;由于该文件以逗号分隔，所以我们可以使用read_csv将其读入一个DataFrame：&#xA;In [9]: df = pd.read_csv(&amp;#39;examples/ex1.csv&amp;#39;) In [10]: df Out[10]: a b c d message 0 1 2 3 4 hello 1 5 6 7 8 world 2 9 10 11 12 foo 我们还可以使用read_table，并指定分隔符：&#xA;In [11]: pd.read_table(&amp;#39;examples/ex1.csv&amp;#39;, sep=&amp;#39;,&amp;#39;) Out[11]: a b c d message 0 1 2 3 4 hello 1 5 6 7 8 world 2 9 10 11 12 foo 并不是所有文件都有标题行。看看下面这个文件：</description>
    </item>
    <item>
      <title>第七章 数据清洗和准备</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch07-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E5%92%8C%E5%87%86%E5%A4%87/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch07-%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E5%92%8C%E5%87%86%E5%A4%87/</guid>
      <description>在数据分析和建模的过程中，相当多的时间要用在数据准备上：加载、清理、转换以及重塑。这些工作会占到分析师时间的80%或更多。有时，存储在文件和数据库中的数据的格式不适合某个特定的任务。许多研究者都选择使用通用编程语言（如Python、Perl、R或Java）或UNIX文本处理工具（如sed或awk）对数据格式进行专门处理。幸运的是，pandas和内置的Python标准库提供了一组高级的、灵活的、快速的工具，可以让你轻松地将数据规整为想要的格式。&#xA;实际上，pandas的许多设计和实现都是由真实应用的需求所驱动的。&#xA;在本章中，我会讨论处理缺失数据、重复数据、字符串操作和其它分析数据转换的工具。下一章，我会关注于用多种方法合并、重塑数据集。&#xA;7.1 处理缺失数据# 在许多数据分析工作中，缺失数据是经常发生的。pandas的目标之一就是尽量轻松地处理缺失数据。例如，pandas对象的所有描述性统计默认都不包括缺失数据。&#xA;缺失数据在pandas中呈现的方式有些不完美，但对于大多数用户可以保证功能正常。对于数值数据，pandas使用浮点值NaN（Not a Number）表示缺失数据。我们称其为哨兵值，可以方便的检测出来：&#xA;In [10]: string_data = pd.Series([&amp;#39;aardvark&amp;#39;, &amp;#39;artichoke&amp;#39;, np.nan, &amp;#39;avocado&amp;#39;]) In [11]: string_data Out[11]: 0 aardvark 1 artichoke 2 NaN 3 avocado dtype: object In [12]: string_data.isnull() Out[12]: 0 False 1 False 2 True 3 False dtype: bool 在pandas中，我们采用了R语言中的惯用法，即将缺失值表示为NA，它表示不可用not available。在统计应用中，NA数据可能是不存在的数据或者虽然存在，但是没有观察到（例如，数据采集中发生了问题）。当进行数据清洗以进行分析时，最好直接对缺失数据进行分析，以判断数据采集的问题或缺失数据可能导致的偏差。&#xA;Python内置的None值在对象数组中也可以作为NA：&#xA;In [13]: string_data[0] = None In [14]: string_data.isnull() Out[14]: 0 True 1 False 2 True 3 False dtype: bool pandas项目中还在不断优化内部细节以更好处理缺失数据，像用户API功能，例如pandas.isnull，去除了许多恼人的细节。表7-1列出了一些关于缺失数据处理的函数。&#xA;7.1.1 滤除缺失数据# 过滤掉缺失数据的办法有很多种。你可以通过pandas.</description>
    </item>
    <item>
      <title>第三章 Python 的数据结构、函数和文件</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch03-python%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%87%E4%BB%B6/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch03-python%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%96%87%E4%BB%B6/</guid>
      <description>🐹 本章讨论Python的内置功能，这些功能本书会用到很多。虽然扩展库，比如pandas和Numpy，使处理大数据集很方便，但它们是和Python的内置数据处理工具一同使用的。&#xA;我们会从Python最基础的数据结构开始：元组、列表、字典和集合。然后会讨论创建你自己的、可重复使用的Python函数。最后，会学习Python的文件对象，以及如何与本地硬盘交互。&#xA;3.1 数据结构和序列# Python的数据结构简单而强大。通晓它们才能成为熟练的Python程序员。&#xA;3.1.1 元组# 元组是一个固定长度，不可改变的Python序列对象。创建元组的最简单方式，是用逗号分隔一列值：&#xA;In [1]: tup = 4, 5, 6 In [2]: tup Out[2]: (4, 5, 6) 当用复杂的表达式定义元组，最好将值放到圆括号内，如下所示：&#xA;In [3]: nested_tup = (4, 5, 6), (7, 8) In [4]: nested_tup Out[4]: ((4, 5, 6), (7, 8)) 用tuple可以将任意序列或迭代器转换成元组：&#xA;In [5]: tuple([4, 0, 2]) Out[5]: (4, 0, 2) In [6]: tup = tuple(&amp;#39;string&amp;#39;) In [7]: tup Out[7]: (&amp;#39;s&amp;#39;, &amp;#39;t&amp;#39;, &amp;#39;r&amp;#39;, &amp;#39;i&amp;#39;, &amp;#39;n&amp;#39;, &amp;#39;g&amp;#39;) 可以用方括号访问元组中的元素。和C、C++、JAVA等语言一样，序列是从0开始的：&#xA;In [8]: tup[0] Out[8]: &amp;#39;s&amp;#39; 元组中存储的对象可能是可变对象。一旦创建了元组，元组中的对象就不能修改了：</description>
    </item>
    <item>
      <title>第十二章 Pandas 高级应用</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch12-pandas%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch12-pandas%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</guid>
      <description>前面的章节关注于不同类型的数据规整流程和NumPy、pandas与其它库的特点。随着时间的发展，pandas发展出了更多适合高级用户的功能。本章就要深入学习pandas的高级功能。&#xA;12.1 分类数据# 这一节介绍的是pandas的分类类型。我会向你展示通过使用它，提高性能和内存的使用率。我还会介绍一些在统计和机器学习中使用分类数据的工具。&#xA;12.1.1 背景和目的# 表中的一列通常会有重复的包含不同值的小集合的情况。我们已经学过了unique和value_counts，它们可以从数组提取出不同的值，并分别计算频率：&#xA;In [10]: import numpy as np; import pandas as pd In [11]: values = pd.Series([&amp;#39;apple&amp;#39;, &amp;#39;orange&amp;#39;, &amp;#39;apple&amp;#39;, ....: &amp;#39;apple&amp;#39;] * 2) In [12]: values Out[12]: 0 apple 1 orange 2 apple 3 apple 4 apple 5 orange 6 apple 7 apple dtype: object In [13]: pd.unique(values) Out[13]: array([&amp;#39;apple&amp;#39;, &amp;#39;orange&amp;#39;], dtype=object) In [14]: pd.value_counts(values) Out[14]: apple 6 orange 2 dtype: int64 许多数据系统（数据仓库、统计计算或其它应用）都发展出了特定的表征重复值的方法，以进行高效的存储和计算。在数据仓库中，最好的方法是使用所谓的包含不同值的维表(Dimension Table)，将主要的参数存储为引用维表整数键：&#xA;In [15]: values = pd.</description>
    </item>
    <item>
      <title>第十三章 Python 建模库介绍</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch13-python%E5%BB%BA%E6%A8%A1%E5%BA%93%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch13-python%E5%BB%BA%E6%A8%A1%E5%BA%93%E4%BB%8B%E7%BB%8D/</guid>
      <description>本书中，我已经介绍了Python数据分析的编程基础。因为数据分析师和科学家总是在数据规整和准备上花费大量时间，这本书的重点在于掌握这些功能。&#xA;开发模型选用什么库取决于应用本身。许多统计问题可以用简单方法解决，比如普通的最小二乘回归，其它问题可能需要复杂的机器学习方法。幸运的是，Python已经成为了运用这些分析方法的语言之一，因此读完此书，你可以探索许多工具。&#xA;本章中，我会回顾一些pandas的特点，在你胶着于pandas数据规整和模型拟合和评分时，它们可能派上用场。然后我会简短介绍两个流行的建模工具，statsmodels和scikit-learn。这二者每个都值得再写一本书，我就不做全面的介绍，而是建议你学习两个项目的线上文档和其它基于Python的数据科学、统计和机器学习的书籍。&#xA;13.1 pandas与模型代码的接口# 模型开发的通常工作流是使用pandas进行数据加载和清洗，然后切换到建模库进行建模。**开发模型的重要一环是机器学习中的“特征工程”。**它可以描述从原始数据集中提取信息的任何数据转换或分析，这些数据集可能在建模中有用。本书中学习的数据聚合和GroupBy工具常用于特征工程中。&#xA;优秀的特征工程超出了本书的范围，我会尽量直白地介绍一些用于数据操作和建模切换的方法。&#xA;pandas与其它分析库通常是靠NumPy的数组联系起来的。将DataFrame转换为NumPy数组，可以使用.values属性：&#xA;In [10]: import pandas as pd In [11]: import numpy as np In [12]: data = pd.DataFrame({ ....: &amp;#39;x0&amp;#39;: [1, 2, 3, 4, 5], ....: &amp;#39;x1&amp;#39;: [0.01, -0.01, 0.25, -4.1, 0.], ....: &amp;#39;y&amp;#39;: [-1.5, 0., 3.6, 1.3, -2.]}) In [13]: data Out[13]: x0 x1 y 0 1 0.01 -1.5 1 2 -0.01 0.0 2 3 0.25 3.6 3 4 -4.10 1.3 4 5 0.</description>
    </item>
    <item>
      <title>第十四章 数据分析案例</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch14-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch14-%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E6%A1%88%E4%BE%8B/</guid>
      <description>本书正文的最后一章，我们来看一些真实世界的数据集。对于每个数据集，我们会用之前介绍的方法，从原始数据中提取有意义的内容。展示的方法适用于其它数据集，也包括你的。本章包含了一些各种各样的案例数据集，可以用来练习。&#xA;案例数据集可以在Github仓库找到，见第一章。&#xA;14.1 来自Bitly的USA.gov数据# 2011年，URL缩短服务Bitly跟美国政府网站USA.gov合作，提供了一份从生成.gov或.mil短链接的用户那里收集来的匿名数据。在2011年，除实时数据之外，还可以下载文本文件形式的每小时快照。写作此书时（2017年），这项服务已经关闭，但我们保存一份数据用于本书的案例。&#xA;以每小时快照为例，文件中各行的格式为JSON（即JavaScript Object Notation，这是一种常用的Web数据格式）。例如，如果我们只读取某个文件中的第一行，那么所看到的结果应该是下面这样：&#xA;In [5]: path = &amp;#39;datasets/bitly_usagov/example.txt&amp;#39; In [6]: open(path).readline() Out[6]: &amp;#39;{ &amp;#34;a&amp;#34;: &amp;#34;Mozilla\\/5.0 (Windows NT 6.1; WOW64) AppleWebKit\\/535.11 (KHTML, like Gecko) Chrome\\/17.0.963.78 Safari\\/535.11&amp;#34;, &amp;#34;c&amp;#34;: &amp;#34;US&amp;#34;, &amp;#34;nk&amp;#34;: 1, &amp;#34;tz&amp;#34;: &amp;#34;America\\/New_York&amp;#34;, &amp;#34;gr&amp;#34;: &amp;#34;MA&amp;#34;, &amp;#34;g&amp;#34;: &amp;#34;A6qOVH&amp;#34;, &amp;#34;h&amp;#34;: &amp;#34;wfLQtf&amp;#34;, &amp;#34;l&amp;#34;: &amp;#34;orofrog&amp;#34;, &amp;#34;al&amp;#34;: &amp;#34;en-US,en;q=0.8&amp;#34;, &amp;#34;hh&amp;#34;: &amp;#34;1.usa.gov&amp;#34;, &amp;#34;r&amp;#34;: &amp;#34;http:\\/\\/www.facebook.com\\/l\\/7AQEFzjSi\\/1.usa.gov\\/wfLQtf&amp;#34;, &amp;#34;u&amp;#34;: &amp;#34;http:\\/\\/www.ncbi.nlm.nih.gov\\/pubmed\\/22415991&amp;#34;, &amp;#34;t&amp;#34;: 1331923247, &amp;#34;hc&amp;#34;: 1331822918, &amp;#34;cy&amp;#34;: &amp;#34;Danvers&amp;#34;, &amp;#34;ll&amp;#34;: [ 42.576698, -70.954903 ] }\n&amp;#39; Python有内置或第三方模块可以将JSON字符串转换成Python字典对象。这里，我将使用json模块及其loads函数逐行加载已经下载好的数据文件：&#xA;import json path = &amp;#39;datasets/bitly_usagov/example.txt&amp;#39; records = [json.</description>
    </item>
    <item>
      <title>第十一章 时间序列</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch11-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch11-%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/</guid>
      <description>时间序列（time series）数据是一种重要的结构化数据形式，应用于多个领域，包括金融学、经济学、生态学、神经科学、物理学等。在多个时间点观察或测量到的任何事物都可以形成一段时间序列。很多时间序列是固定频率的，也就是说，数据点是根据某种规律定期出现的（比如每15秒、每5分钟、每月出现一次）。时间序列也可以是不定期的，没有固定的时间单位或单位之间的偏移量。时间序列数据的意义取决于具体的应用场景，主要有以下几种：&#xA;时间戳（timestamp），特定的时刻。 固定时期（period），如2007年1月或2010年全年。 时间间隔（interval），由起始和结束时间戳表示。时期（period）可以被看做间隔（interval）的特例。 实验或过程时间，每个时间点都是相对于特定起始时间的一个度量。例如，从放入烤箱时起，每秒钟饼干的直径。 本章主要讲解前3种时间序列。许多技术都可用于处理实验型时间序列，其索引可能是一个整数或浮点数（表示从实验开始算起已经过去的时间）。最简单也最常见的时间序列都是用时间戳进行索引的。&#xA;提示：pandas也支持基于timedeltas的指数，它可以有效代表实验或经过的时间。这本书不涉及timedelta指数，但你可以学习pandas的文档（http://pandas.pydata.org/）。&#xA;pandas提供了许多内置的时间序列处理工具和数据算法。因此，你可以高效处理非常大的时间序列，轻松地进行切片/切块、聚合、对定期/不定期的时间序列进行重采样等。有些工具特别适合金融和经济应用，你当然也可以用它们来分析服务器日志数据。&#xA;11.1 日期和时间数据类型及工具# Python标准库包含用于日期（date）和时间（time）数据的数据类型，而且还有日历方面的功能。我们主要会用到datetime、time以及calendar模块。datetime.datetime（也可以简写为datetime）是用得最多的数据类型：&#xA;In [10]: from datetime import datetime In [11]: now = datetime.now() In [12]: now Out[12]: datetime.datetime(2017, 9, 25, 14, 5, 52, 72973) In [13]: now.year, now.month, now.day Out[13]: (2017, 9, 25) datetime以毫秒形式存储日期和时间。timedelta表示两个datetime对象之间的时间差：&#xA;In [14]: delta = datetime(2011, 1, 7) - datetime(2008, 6, 24, 8, 15) In [15]: delta Out[15]: datetime.timedelta(926, 56700) In [16]: delta.days Out[16]: 926 In [17]: delta.</description>
    </item>
    <item>
      <title>第十章 数据聚合与分组运算</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch10-%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88%E4%B8%8E%E5%88%86%E7%BB%84%E8%BF%90%E7%AE%97/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch10-%E6%95%B0%E6%8D%AE%E8%81%9A%E5%90%88%E4%B8%8E%E5%88%86%E7%BB%84%E8%BF%90%E7%AE%97/</guid>
      <description>对数据集进行分组并对各组应用一个函数（无论是聚合还是转换），通常是数据分析工作中的重要环节。在将数据集加载、融合、准备好之后，通常就是计算分组统计或生成透视表。pandas提供了一个灵活高效的groupby功能，它使你能以一种自然的方式对数据集进行切片、切块、摘要等操作。&#xA;关系型数据库和SQL（Structured Query Language，结构化查询语言）能够如此流行的原因之一就是其能够方便地对数据进行连接、过滤、转换和聚合。但是，像SQL这样的查询语言所能执行的分组运算的种类很有限。在本章中你将会看到，由于Python和pandas强大的表达能力，我们可以执行复杂得多的分组运算（利用任何可以接受pandas对象或NumPy数组的函数）。在本章中，你将会学到：&#xA;使用一个或多个键（形式可以是函数、数组或DataFrame列名）分割pandas对象。 计算分组的概述统计，比如数量、平均值或标准差，或是用户定义的函数。 应用组内转换或其他运算，如规格化、线性回归、排名或选取子集等。 计算透视表或交叉表。 执行分位数分析以及其它统计分组分析。 笔记：对时间序列数据的聚合（groupby的特殊用法之一）也称作重采样（resampling），将在第11章中单独对其进行讲解。&#xA;10.1 GroupBy机制# Hadley Wickham（许多热门R语言包的作者）创造了一个用于表示分组运算的术语&amp;quot;split-apply-combine&amp;quot;（拆分－应用－合并）。第一个阶段，pandas对象（无论是Series、DataFrame还是其他的）中的数据会根据你所提供的一个或多个键被拆分（split）为多组。拆分操作是在对象的特定轴上执行的。例如，DataFrame可以在其行（axis=0）或列（axis=1）上进行分组。然后，将一个函数应用（apply）到各个分组并产生一个新值。最后，所有这些函数的执行结果会被合并（combine）到最终的结果对象中。结果对象的形式一般取决于数据上所执行的操作。图10-1大致说明了一个简单的分组聚合过程。&#xA;分组键可以有多种形式，且类型不必相同：&#xA;列表或数组，其长度与待分组的轴一样。 表示DataFrame某个列名的值。 字典或Series，给出待分组轴上的值与分组名之间的对应关系。 函数，用于处理轴索引或索引中的各个标签。 注意，后三种都只是快捷方式而已，其最终目的仍然是产生一组用于拆分对象的值。如果觉得这些东西看起来很抽象，不用担心，我将在本章中给出大量有关于此的示例。首先来看看下面这个非常简单的表格型数据集（以DataFrame的形式）：&#xA;In [10]: df = pd.DataFrame({&amp;#39;key1&amp;#39; : [&amp;#39;a&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;b&amp;#39;, &amp;#39;a&amp;#39;], ....: &amp;#39;key2&amp;#39; : [&amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;, &amp;#39;one&amp;#39;, &amp;#39;two&amp;#39;, &amp;#39;one&amp;#39;], ....: &amp;#39;data1&amp;#39; : np.random.randn(5), ....: &amp;#39;data2&amp;#39; : np.random.randn(5)}) In [11]: df Out[11]: data1 data2 key1 key2 0 -0.204708 1.393406 a one 1 0.478943 0.092908 a two 2 -0.519439 0.281746 b one 3 -0.</description>
    </item>
    <item>
      <title>第四章 Numpy 基础</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch04-numpy%E5%9F%BA%E7%A1%80%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A2%E9%87%8F%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch04-numpy%E5%9F%BA%E7%A1%80%E6%95%B0%E7%BB%84%E5%92%8C%E7%9F%A2%E9%87%8F%E8%AE%A1%E7%AE%97/</guid>
      <description>NumPy（Numerical Python的简称）是Python数值计算最重要的基础包。大多数提供科学计算的包都是用NumPy的数组作为构建基础。&#xA;NumPy的部分功能如下：&#xA;ndarray，一个具有矢量算术运算和复杂广播能力的快速且节省空间的多维数组。 用于对整组数据进行快速运算的标准数学函数（无需编写循环）。 用于读写磁盘数据的工具以及用于操作内存映射文件的工具。 线性代数、随机数生成以及傅里叶变换功能。 用于集成由C、C++、Fortran等语言编写的代码的A C API。 由于NumPy提供了一个简单易用的C API，因此很容易将数据传递给由低级语言编写的外部库，外部库也能以NumPy数组的形式将数据返回给Python。这个功能使Python成为一种包装C/C++/Fortran历史代码库的选择，并使被包装库拥有一个动态的、易用的接口。&#xA;NumPy本身并没有提供多么高级的数据分析功能，理解NumPy数组以及面向数组的计算将有助于你更加高效地使用诸如pandas之类的工具。因为NumPy是一个很大的题目，我会在附录A中介绍更多NumPy高级功能，比如广播。&#xA;对于大部分数据分析应用而言，我最关注的功能主要集中在：&#xA;用于数据整理和清理、子集构造和过滤、转换等快速的矢量化数组运算。 常用的数组算法，如排序、唯一化、集合运算等。 高效的描述统计和数据聚合/摘要运算。 用于异构数据集的合并/连接运算的数据对齐和关系型数据运算。 将条件逻辑表述为数组表达式（而不是带有if-elif-else分支的循环）。 数据的分组运算（聚合、转换、函数应用等）。。 虽然NumPy提供了通用的数值数据处理的计算基础，但大多数读者可能还是想将pandas作为统计和分析工作的基础，尤其是处理表格数据时。pandas还提供了一些NumPy所没有的领域特定的功能，如时间序列处理等。&#xA;🐰 笔记：Python的面向数组计算可以追溯到1995年，Jim Hugunin创建了Numeric库。接下来的10年，许多科学编程社区纷纷开始使用Python的数组编程，但是进入21世纪，库的生态系统变得碎片化了。2005年，Travis Oliphant从Numeric和Numarray项目整合出了NumPy项目，进而所有社区都集合到了这个框架下。&#xA;NumPy对于数值计算特别重要的原因之一，是**因为它可以高效处理大数组的数据。**这是因为：&#xA;NumPy是在一个连续的内存块中存储数据，独立于其他Python内置对象。NumPy的C语言编写的算法库可以操作内存，而不必进行类型检查或其它前期工作。比起Python的内置序列，NumPy数组使用的内存更少。 NumPy可以在整个数组上执行复杂的计算，而不需要Python的for循环。 要搞明白具体的性能差距，考察一个包含一百万整数的数组，和一个等价的Python列表：&#xA;In [7]: import numpy as np In [8]: my_arr = np.arange(1000000) In [9]: my_list = list(range(1000000)) 各个序列分别乘以2：&#xA;In [10]: %time for _ in range(10): my_arr2 = my_arr * 2 CPU times: user 20 ms, sys: 50 ms, total: 70 ms Wall time: 72.</description>
    </item>
    <item>
      <title>第五章 Pandas 入门</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch05-pandas%E5%85%A5%E9%97%A8/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch05-pandas%E5%85%A5%E9%97%A8/</guid>
      <description>pandas是本书后续内容的首选库。它含有使数据清洗和分析工作变得更快更简单的数据结构和操作工具。pandas经常和其它工具一同使用，如数值计算工具NumPy和SciPy，分析库statsmodels和scikit-learn，和数据可视化库matplotlib。pandas是基于NumPy数组构建的，特别是基于数组的函数和不使用for循环的数据处理。&#xA;虽然pandas采用了大量的NumPy编码风格，但二者最大的不同是pandas是专门为处理表格和混杂数据设计的。而NumPy更适合处理统一的数值数组数据。&#xA;自从2010年pandas开源以来，pandas逐渐成长为一个非常大的库，应用于许多真实案例。开发者社区已经有了800个独立的贡献者，他们在解决日常数据问题的同时为这个项目提供贡献。&#xA;在本书后续部分中，我将使用下面这样的pandas引入约定：&#xA;In [1]: import pandas as pd 因此，只要你在代码中看到pd.，就得想到这是pandas。因为Series和DataFrame用的次数非常多，所以将其引入本地命名空间中会更方便：&#xA;In [2]: from pandas import Series, DataFrame 5.1 pandas的数据结构介绍# 要使用pandas，你首先就得熟悉它的两个主要数据结构：Series和DataFrame。虽然它们并不能解决所有问题，但它们为大多数应用提供了一种可靠的、易于使用的基础。&#xA;5.1.1 Series# Series是一种类似于一维数组的对象，它由一组数据（各种NumPy数据类型）以及一组与之相关的数据标签（即索引）组成。仅由一组数据即可产生最简单的Series：&#xA;In [11]: obj = pd.Series([4, 7, -5, 3]) In [12]: obj Out[12]: 0 4 1 7 2 -5 3 3 dtype: int64 Series的字符串表现形式为：索引在左边，值在右边。由于我们没有为数据指定索引，于是会自动创建一个0到N-1（N为数据的长度）的整数型索引。你可以通过Series 的values和index属性获取其数组表示形式和索引对象：&#xA;In [13]: obj.values Out[13]: array([ 4, 7, -5, 3]) In [14]: obj.index # like range(4) Out[14]: RangeIndex(start=0, stop=4, step=1) 通常，我们希望所创建的Series带有一个可以对各个数据点进行标记的索引：&#xA;In [15]: obj2 = pd.</description>
    </item>
    <item>
      <title>第一章 准备工作</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch01-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/ch01-%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C/</guid>
      <description>1.1 本书的内容# Python 数据分析这本书讲的是利用 Python 进行数据控制、处理、整理、分析等方面的具体细节和基本要点。作者介绍 Python 编程和用于数据处理的库和工具环境，掌握这些，可以让你成为一个数据分析专家。虽然本书的标题是“数据分析”，重点却是 Python 编程、库，以及用于数据分析的工具。这就是数据分析要用到的 Python 编程。&#xA;1.1.1 什么样的数据？# 🔰 当书中出现“数据”时，究竟指的是什么呢？&#xA;主要指的是结构化数据（structured data），这个故意含糊其辞的术语代指了所有通用格式的数据，例如：&#xA;表格型数据，其中各列可能是不同的类型（字符串、数值、日期等）。比如保存在关系型数据库中或以制表符/逗号为分隔符的文本文件中的那些数据。 多维数组（矩阵）。 通过关键列（对于 SQL 用户而言，就是主键和外键）相互联系的多个表。 间隔平均或不平均的时间序列。 这绝不是一个完整的列表。大部分数据集都能被转化为更加适合分析和建模的结构化形式，虽然有时这并不是很明显。如果不行的话，也可以将数据集的特征提取为某种结构化形式。例如，一组新闻文章可以被处理为一张词频表，而这张词频表就可以用于情感分析。&#xA;大部分电子表格软件（比如 Microsoft Excel，它可能是世界上使用最广泛的数据分析工具了）的用户不会对此类数据感到陌生。&#xA;1.2 为什么要使用 Python 进行数据分析# 许许多多的人（包括我自己）都很容易爱上 Python 这门语言。自从1991年诞生以来，Python 现在已经成为最受欢迎的动态编程语言之一，其他还有Perl、Ruby等。由于拥有大量的Web框架（比如Rails（Ruby）和Django（Python）），自从2005年，使用Python和Ruby进行网站建设工作非常流行。这些语言常被称作脚本（scripting）语言，因为它们可以用于编写简短而粗糙的小程序（也就是脚本）。我个人并不喜欢“脚本语言”这个术语，因为它好像在说这些语言无法用于构建严谨的软件。在众多解释型语言中，由于各种历史和文化的原因，Python发展出了一个巨大而活跃的科学计算（scientific computing）社区。在过去的10年，Python从一个边缘或“自担风险”的科学计算语言，成为了数据科学、机器学习、学界和工业界软件开发最重要的语言之一。&#xA;在数据分析、交互式计算以及数据可视化方面，Python将不可避免地与其他开源和商业的领域特定编程语言/工具进行对比，如R、MATLAB、SAS、Stata等。近年来，由于Python的库（例如pandas和scikit-learn）不断改良，使其成为数据分析任务的一个优选方案。结合其在通用编程方面的强大实力，我们完全可以只使用Python这一种语言构建以数据为中心的应用。&#xA;1.2.1 Python作为胶水语言# Python成为成功的科学计算工具的部分原因是，它能够轻松地集成C、C++以及Fortran代码。大部分现代计算环境都利用了一些Fortran和C库来实现线性代数、优选、积分、快速傅里叶变换以及其他诸如此类的算法。许多企业和国家实验室也利用Python来“粘合”那些已经用了多年的遗留软件系统。&#xA;大多数软件都是由两部分代码组成的：少量需要占用大部分执行时间的代码，以及大量不经常执行的“胶水代码”。大部分情况下，胶水代码的执行时间是微不足道的。开发人员的精力几乎都是花在优化计算瓶颈上面，有时更是直接转用更低级的语言（比如C）。&#xA;1.2.2 解决“两种语言”问题# 很多组织通常都会用一种类似于领域特定的计算语言（如SAS和R）对新想法做研究、原型构建和测试，然后再将这些想法移植到某个更大的生产系统中去（可能是用Java、C#或C++编写的）。人们逐渐意识到，Python不仅适用于研究和原型构建，同时也适用于构建生产系统。为什么一种语言就够了，却要使用两个语言的开发环境呢？我相信越来越多的企业也会这样看，因为研究人员和工程技术人员使用同一种编程工具将会给企业带来非常显著的组织效益。&#xA;1.2.3 为什么不选Python# 虽然Python非常适合构建分析应用以及通用系统，但它对不少应用场景适用性较差。&#xA;由于Python是一种解释型编程语言，因此大部分Python代码都要比用编译型语言（比如Java和C++）编写的代码运行慢得多。由于程序员的时间通常都比CPU时间值钱，因此许多人也愿意对此做一些取舍。但是，在那些延迟要求非常小或高资源利用率的应用中（例如高频交易系统），耗费时间使用诸如C++这样更低级、更低生产率的语言进行编程也是值得的。&#xA;对于高并发、多线程的应用程序而言（尤其是拥有许多计算密集型线程的应用程序），Python并不是一种理想的编程语言。这是因为Python有一个叫做全局解释器锁（Global Interpreter Lock，GIL）的组件，这是一种防止解释器同时执行多条Python字节码指令的机制。有关“为什么会存在GIL”的技术性原因超出了本书的范围。虽然很多大数据处理应用程序为了能在较短的时间内完成数据集的处理工作都需要运行在计算机集群上，但是仍然有一些情况需要用单进程多线程系统来解决。&#xA;这并不是说Python不能执行真正的多线程并行代码。例如，Python的C插件使用原生的C或C++的多线程，可以并行运行而不被GIL影响，只要它们不频繁地与Python对象交互。&#xA;1.3 重要的Python库# 考虑到那些还不太了解Python科学计算生态系统和库的读者，下面我先对各个库做一个简单的介绍。&#xA;1.3.1 NumPy# NumPy（Numerical Python的简称）是Python科学计算的基础包。本书大部分内容都基于NumPy以及构建于其上的库。它提供了以下功能（不限于此）：&#xA;快速高效的多维数组对象ndarray。&#xA;用于对数组执行元素级计算以及直接对数组执行数学运算的函数。&#xA;用于读写硬盘上基于数组的数据集的工具。&#xA;线性代数运算、傅里叶变换，以及随机数生成。&#xA;-成熟的C API， 用于Python插件和原生C、C++、Fortran代码访问NumPy的数据结构和计算工具。&#xA;除了为Python提供快速的数组处理能力，NumPy在数据分析方面还有另外一个主要作用，即作为在算法和库之间传递数据的容器。对于数值型数据，NumPy数组在存储和处理数据时要比内置的Python数据结构高效得多。此外，由低级语言（比如C和Fortran）编写的库可以直接操作NumPy数组中的数据，无需进行任何数据复制工作。因此，许多Python的数值计算工具要么使用NumPy数组作为主要的数据结构，要么可以与NumPy进行无缝交互操作。&#xA;1.3.2 pandas# pandas提供了快速便捷处理结构化数据的大量数据结构和函数。自从2010年出现以来，它助使Python成为强大而高效的数据分析环境。本书用得最多的pandas对象是DataFrame，它是一个面向列（column-oriented）的二维表结构，另一个是Series，一个一维的标签化数组对象。</description>
    </item>
    <item>
      <title>附录A-NumPy高级应用</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E9%99%84%E5%BD%95a-numpy%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E9%99%84%E5%BD%95a-numpy%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8/</guid>
      <description>在这篇附录中，我会深入NumPy库的数组计算。这会包括ndarray更内部的细节，和更高级的数组操作和算法。&#xA;本章包括了一些杂乱的章节，不需要仔细研究。&#xA;A.1 ndarray对象的内部机理# NumPy的ndarray提供了一种将同质数据块（可以是连续或跨越）解释为多维数组对象的方式。正如你之前所看到的那样，数据类型（dtype）决定了数据的解释方式，比如浮点数、整数、布尔值等。&#xA;ndarray如此强大的部分原因是所有数组对象都是数据块的一个跨度视图（strided view）。你可能想知道数组视图arr[::2,::-1]不复制任何数据的原因是什么。简单地说，ndarray不只是一块内存和一个dtype，它还有跨度信息，这使得数组能以各种步幅（step size）在内存中移动。更准确地讲，ndarray内部由以下内容组成：&#xA;一个指向数据（内存或内存映射文件中的一块数据）的指针。 数据类型或dtype，描述在数组中的固定大小值的格子。 一个表示数组形状（shape）的元组。 一个跨度元组（stride），其中的整数指的是为了前进到当前维度下一个元素需要“跨过”的字节数。 图A-1简单地说明了ndarray的内部结构。&#xA;例如，一个10×5的数组，其形状为(10,5)：&#xA;In [10]: np.ones((10, 5)).shape Out[10]: (10, 5) 一个典型的（C顺序，稍后将详细讲解）3×4×5的float64（8个字节）数组，其跨度为(160,40,8) —— 知道跨度是非常有用的，通常，跨度在一个轴上越大，沿这个轴进行计算的开销就越大：&#xA;In [11]: np.ones((3, 4, 5), dtype=np.float64).strides Out[11]: (160, 40, 8) 虽然NumPy用户很少会对数组的跨度信息感兴趣，但它们却是构建非复制式数组视图的重要因素。跨度甚至可以是负数，这样会使数组在内存中后向移动，比如在切片obj[::-1]或obj[:,::-1]中就是这样的。&#xA;NumPy数据类型体系# 你可能偶尔需要检查数组中所包含的是否是整数、浮点数、字符串或Python对象。因为浮点数的种类很多（从float16到float128），判断dtype是否属于某个大类的工作非常繁琐。幸运的是，dtype都有一个超类（比如np.integer和np.floating），它们可以跟np.issubdtype函数结合使用：&#xA;In [12]: ints = np.ones(10, dtype=np.uint16) In [13]: floats = np.ones(10, dtype=np.float32) In [14]: np.issubdtype(ints.dtype, np.integer) Out[14]: True In [15]: np.issubdtype(floats.dtype, np.floating) Out[15]: True 调用dtype的mro方法即可查看其所有的父类：&#xA;In [16]: np.float64.mro() Out[16]: [numpy.float64, numpy.floating, numpy.inexact, numpy.number, numpy.</description>
    </item>
    <item>
      <title>附录B-更多关于IPython的内容</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E9%99%84%E5%BD%95b-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8Eipython%E7%9A%84%E5%86%85%E5%AE%B9/</link>
      <pubDate>Mon, 25 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/%E9%99%84%E5%BD%95b-%E6%9B%B4%E5%A4%9A%E5%85%B3%E4%BA%8Eipython%E7%9A%84%E5%86%85%E5%AE%B9/</guid>
      <description>第2章中，我们学习了IPython shell和Jupyter notebook的基础。本章中，我们会探索IPython更深层次的功能，可以从控制台或在jupyter使用。&#xA;B.1 使用命令历史# Ipython维护了一个位于磁盘的小型数据库，用于保存执行的每条指令。它的用途有：&#xA;只用最少的输入，就能搜索、补全和执行先前运行过的指令； 在不同session间保存命令历史； 将日志输入/输出历史到一个文件 这些功能在shell中，要比notebook更为有用，因为notebook从设计上是将输入和输出的代码放到每个代码格子中。&#xA;搜索和重复使用命令历史# Ipython可以让你搜索和执行之前的代码或其他命令。这个功能非常有用，因为你可能需要重复执行同样的命令，例如%run命令，或其它代码。假设你必须要执行：&#xA;In[7]: %run first/second/third/data_script.py 运行成功，然后检查结果，发现计算有错。解决完问题，然后修改了data_script.py，你就可以输入一些%run命令，然后按Ctrl+P或上箭头。这样就可以搜索历史命令，匹配输入字符的命令。多次按Ctrl+P或上箭头，会继续搜索命令。如果你要执行你想要执行的命令，不要害怕。你可以按下Ctrl-N或下箭头，向前移动历史命令。这样做了几次后，你可以不假思索地按下这些键！&#xA;Ctrl-R可以带来如同Unix风格shell（比如bash shell）的readline的部分增量搜索功能。在Windows上，readline功能是被IPython模仿的。要使用这个功能，先按Ctrl-R，然后输入一些包含于输入行的想要搜索的字符：&#xA;In [1]: a_command = foo(x, y, z) (reverse-i-search)`com&amp;#39;: a_command = foo(x, y, z) Ctrl-R会循环历史，找到匹配字符的每一行。&#xA;输入和输出变量# 忘记将函数调用的结果分配给变量是非常烦人的。IPython的一个session会在一个特殊变量，存储输入和输出Python对象的引用。前面两个输出会分别存储在 _（一个下划线）和 __（两个下划线）变量：&#xA;In [24]: 2 ** 27 Out[24]: 134217728 In [25]: _ Out[25]: 134217728 输入变量是存储在名字类似_iX的变量中，X是输入行的编号。对于每个输入变量，都有一个对应的输出变量_X。因此在输入第27行之后，会有两个新变量_27 （输出）和_i27（输入）:&#xA;In [26]: foo = &amp;#39;bar&amp;#39; In [27]: foo Out[27]: &amp;#39;bar&amp;#39; In [28]: _i27 Out[28]: u&amp;#39;foo&amp;#39; In [29]: _27 Out[29]: &amp;#39;bar&amp;#39; 因为输入变量是字符串，它们可以用Python的exec关键字再次执行：</description>
    </item>
    <item>
      <title>MySQL常用函数</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 19 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/mysql%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</guid>
      <description>1、数学函数# ABS(x) --返回x的绝对值 BIN(x) --返回x的二进制（OCT返回八进制，HEX返回十六进制） CEILING(x) --返回大于x的最小整数值 EXP(x) --返回值e（自然对数的底）的x次方 FLOOR(x) --返回小于x的最大整数值 GREATEST(x1,x2,...,xn) --返回集合中最大的值 LEAST(x1,x2,...,xn) --返回集合中最小的值 LN(x) --返回x的自然对数 LOG(x,y) --返回x的以y为底的对数 MOD(x,y) --返回x/y的模（余数） PI() --返回pi的值（圆周率） RAND() --返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。 ROUND(x,y) --返回参数x的四舍五入的有y位小数的值 SIGN(x) --返回代表数字x的符号的值 SQRT(x) --返回一个数的平方根 TRUNCATE(x,y) --返回数字x截短为y位小数的结果 2、聚合函数# AVG(X) --返回指定列的平均值 COUNT(X) --返回指定列中非NULL值的个数 MIN(X) --返回指定列的最小值 MAX(X) --返回指定列的最大值 SUM(X) --返回指定列的所有值之和 GROUP_CONCAT(X) --返回由属于一组的列值连接组合而成的结果，非常有用 3、字符串函数（20个）&#xA;ASCII(char) --返回字符的ASCII码值 BIT_LENGTH(str) --返回字符串的比特长度 CONCAT(s1,s2...,sn) --将s1,s2...,sn连接成字符串 CONCAT_WS(sep,s1,s2...,sn) --将s1,s2...,sn连接成字符串，并用sep字符间隔 INSERT(str,x,y,instr) --将字符串str从第x位置开始，y个字符长的子串替换为字符串instr，返回结果 FIND_IN_SET(str,list) --分析逗号分隔的list列表，如果发现str，返回str在list中的位置 LCASE(str)或LOWER(str) --返回将字符串str中所有字符改变为小写后的结果 LEFT(str,x) --返回字符串str中最左边的x个字符 LENGTH(s) --返回字符串str中的字符数 LTRIM(str) --从字符串str中切掉开头的空格 POSITION(substr,str) --返回子串substr在字符串str中第一次出现的位置 QUOTE(str) --用反斜杠转义str中的单引号 REPEAT(str,srchstr,rplcstr) --返回字符串str重复x次的结果 REVERSE(str) --返回颠倒字符串str的结果 RIGHT(str,x) --返回字符串str中最右边的x个字符 RTRIM(str) --返回字符串str尾部的空格 STRCMP(s1,s2) --比较字符串s1和s2 TRIM(str) --去除字符串首部和尾部的所有空格 UCASE(str)或UPPER(str) --返回将字符串str中所有字符转变为大写后的结果 4、日期和时间函数# CURDATE()或CURRENT_DATE() --返回当前的日期 CURTIME()或CURRENT_TIME() --返回当前的时间 DATE_ADD(date,INTERVAL int keyword) --返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化) 例如 SELECT DATE_ADD(CURRENT_DATE,INTERVAL 6 MONTH); DATE_FORMAT(date,fmt) --依照指定的fmt格式格式化日期date值 DATE_SUB(date,INTERVAL int keyword) --返回日期date加上间隔时间int的结果(int必须按照关键字进行格式化) 例如 SELECT DATE_SUB(CURRENT_DATE,INTERVAL 6 MONTH); DAYOFWEEK(date) --返回date所代表的一星期中的第几天(1~7) DAYOFMONTH(date) --返回date是一个月的第几天(1~31) DAYOFYEAR(date) --返回date是一年的第几天(1~366) DAYNAME(date) --返回date的星期名，如：SELECT DAYNAME(CURRENT_DATE); FROM_UNIXTIME(ts,fmt) --根据指定的fmt格式，格式化UNIX时间戳ts HOUR(time) --返回time的小时值(0~23) MINUTE(time) --返回time的分钟值(0~59) MONTH(date) --返回date的月份值(1~12) MONTHNAME(date) --返回date的月份名，如：SELECT MONTHNAME(CURRENT_DATE); NOW() --返回当前的日期和时间 QUARTER(date) --返回date在一年中的季度(1~4) 例如 SELECT QUARTER(CURRENT_DATE); WEEK(date) --返回日期date为一年中第几周(0~53) YEAR(date) --返回日期date的年份(1000~9999) 例如，获取当前系统时间 SELECT FROM_UNIXTIME(UNIX_TIMESTAMP()); SELECT EXTRACT(YEAR_MONTH FROM CURRENT_DATE); SELECT EXTRACT(DAY_SECOND FROM CURRENT_DATE); SELECT EXTRACT(HOUR_MINUTE FROM CURRENT_DATE); 返回两个日期值之间的差值(月数) SELECT PERIOD_DIFF(200302,199802); 在Mysql中计算年龄： SELECT DATE_FORMAT(FROM_DAYS(TO_DAYS(NOW())-TO_DAYS(birthday)),&amp;#39;%Y&amp;#39;)+0 AS age FROM employee; 这样，如果Brithday是未来的年月日的话，计算结果为0。 下面的SQL语句计算员工的绝对年龄，即当Birthday是未来的日期时，将得到负值。 SELECT DATE_FORMAT(NOW(), &amp;#39;%Y&amp;#39;) - DATE_FORMAT(birthday, &amp;#39;%Y&amp;#39;) -(DATE_FORMAT(NOW(), &amp;#39;00-%m-%d&amp;#39;) &amp;lt; DATE_FORMAT(birthday, &amp;#39;00-%m-%d&amp;#39;)) AS age from employee 5、加密函数# AES_ENCRYPT(str,key) --返回用密钥key对字符串str利用高级加密标准算法加密后的结果，调用AES_ENCRYPT的结果是一个二进制字符串，以BLOB类型存储 AES_DECRYPT(str,key) --返回用密钥key对字符串str利用高级加密标准算法解密后的结果 DECODE(str,key) --使用key作为密钥解密加密字符串str ENCRYPT(str,salt) --使用UNIXcrypt()函数，用关键词salt(一个可以惟一确定口令的字符串，就像钥匙一样)加密字符串str ENCODE(str,key) --使用key作为密钥加密字符串str，调用ENCODE()的结果是一个二进制字符串，它以BLOB类型存储 MD5() --计算字符串str的MD5校验和 PASSWORD(str) --返回字符串str的加密版本，这个加密过程是不可逆转的，和UNIX密码加密过程使用不同的算法。 SHA() --计算字符串str的安全散列算法(SHA)校验和 例如 SELECT ENCRYPT(&amp;#39;root&amp;#39;,&amp;#39;salt&amp;#39;) ; SELECT ENCODE(&amp;#39;xufeng&amp;#39;,&amp;#39;key&amp;#39;) ; SELECT DECODE(ENCODE(&amp;#39;xufeng&amp;#39;,&amp;#39;key&amp;#39;),&amp;#39;key&amp;#39;) ;--加解密放在一起 SELECT AES_ENCRYPT(&amp;#39;root&amp;#39;,&amp;#39;key&amp;#39;) ; SELECT AES_DECRYPT(AES_ENCRYPT(&amp;#39;root&amp;#39;,&amp;#39;key&amp;#39;),&amp;#39;key&amp;#39;) ; SELECT MD5(&amp;#39;123456&amp;#39;) ; SELECT SHA(&amp;#39;123456&amp;#39;) ; 6、控制流函数# CASE WHEN [test1] THEN [result1].</description>
    </item>
    <item>
      <title>Pandas最常用的15个函数</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/pandas/pandas%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%8415%E4%B8%AA%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 19 Sep 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/pandas/pandas%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%8415%E4%B8%AA%E5%87%BD%E6%95%B0/</guid>
      <description>Pandas是一个功能强大的数据处理库，它提供了大量的函数和方法，用于数据的读取、清洗、转换、分析和可视化。下面是Pandas中最常用的15个函数及其代码示例：&#xA;read_csv()：用于读取CSV文件中的数据并创建DataFrame对象。 import pandas as pd df = pd.read_csv(&amp;#39;data.csv&amp;#39;) print(df) head()：用于查看DataFrame中的前几行数据，默认显示前5行。 print(df.head()) tail()：用于查看DataFrame中的后几行数据，默认显示后5行。 print(df.tail()) info()：用于查看DataFrame的基本信息，包括列名、数据类型、非空值数量等。 print(df.info()) describe()：用于生成DataFrame中数值列的统计摘要，包括计数、均值、标准差、最小值、25%分位数、中位数、75%分位数和最大值。 print(df.describe()) shape：用于获取DataFrame的形状，即行数和列数。 print(df.shape) columns：用于获取DataFrame的列名。 print(df.columns) fillna()：用于填充DataFrame中的缺失值。 df.fillna(0, inplace=True) print(df) groupby()：用于对DataFrame进行分组操作。 grouped = df.groupby(&amp;#39;category&amp;#39;) print(grouped.mean()) sort_values()：用于对DataFrame按照指定列进行排序。 sorted_df = df.sort_values(&amp;#39;column_name&amp;#39;) print(sorted_df) drop_duplicates()：用于移除DataFrame中的重复行。 df.drop_duplicates(inplace=True) print(df) value_counts()：用于计算DataFrame中某一列的唯一值计数。 print(df[&amp;#39;column_name&amp;#39;].value_counts()) apply()：用于对DataFrame的某一列或多列应用自定义函数。 def custom_function(x): # 自定义处理逻辑 return x * 2 df[&amp;#39;column_name&amp;#39;] = df[&amp;#39;column_name&amp;#39;].apply(custom_function) print(df) merge()：用于合并两个DataFrame对象。 merged_df = pd.merge(df1, df2, on=&amp;#39;key_column&amp;#39;) print(merged_df) plot()：用于绘制DataFrame中的数据图表。 df.plot(x=&amp;#39;column_name1&amp;#39;, y=&amp;#39;column_name2&amp;#39;, kind=&amp;#39;line&amp;#39;) plt.show() 通过掌握这些常用函数，您可以更加高效地使用Pandas进行数据处理和分析。它们提供了基本的数据操作和转换功能，为您的数据工作提供了便利。&#xA;总结：本文介绍了Pandas中最常用的15个函数，并提供了相应的代码示例。这些函数涵盖了数据读取、查看、描述统计、缺失值处理、分组、排序、去重、计数、自定义函数应用、合并和可视化等常见的数据处理任务。掌握这些函数将帮助您更加熟练地使用Pandas进行数据分析和处理。</description>
    </item>
    <item>
      <title>python数据分析专用数据库，与pandas结合，10倍提速&#43;极致体验</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%93%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8Epandas%E7%BB%93%E5%90%8810%E5%80%8D%E6%8F%90%E9%80%9F&#43;%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Sat, 12 Aug 2023 17:56:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%93%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8Epandas%E7%BB%93%E5%90%8810%E5%80%8D%E6%8F%90%E9%80%9F&#43;%E6%9E%81%E8%87%B4%E4%BD%93%E9%AA%8C/</guid>
      <description>前言# 你有想过在 pandas 中直接使用 sql吗？我知道许多小伙伴已经知道一些库也可以做到这种体验，不过他们的性能太差劲了(基于sqlite，或其他服务端数据库)。&#xA;今天我要介绍另一个专用于数据分析的列式数据库，性能是其他同体验的库的1000倍以上。可以无缝接入 pandas ，做到了性能与使用体验同时提升。&#xA;这就是今天的主角，duckdb。&#xA;特点# duckdb 是一个单机数据库，你大概率会用它与 sqlite 比较。&#xA;最明显的区别就是，duckdb 是一个分析数据管理系统，而 sqlite 是一个事务型关系数据库。&#xA;这意味着，如果你现在有一大堆数据处理任务，期间无须顾忌会有其他用户插入新数据或删除数据。那么 duckdb 就可以非常好应对这种场景。&#xA;对于我们这种 pandas 老用户，duckdb 支持 pandas 的 dataFrame 通用底层格式(parquet/arrow等)上并行运行查询，而且没有单独的导入步骤。这就是它能保持使用体验的同时，大幅提升查询性能的最大原因。&#xA;我们需要安装这些库&#xA;pip install pandas duckdb -U&#xA;先看一个例子，看看它是如何便捷与 dataframe 交互。&#xA;变量等于表名？# 首先，导入今天需要用到的库&#xA;我们有一大堆销售数据，加载其中一份数据看看： 此时，希望使用 sql 做一些数据查询处理，你认为下面的 sql 简单吗？&#xA;直接使用 dataframe 的变量名作为表名查询 这真的可以做到吗？加上一点点 duckdb 的调用即可：&#xA;duckdb.query 做查询&#xA;df，把查询结果转回 dataframe&#xA;也就是，可以直接使用当前环境下的变量作为表名。&#xA;我知道之前就有其他的库可以做到这种体验，但是必需强调，duckdb 是直接使用 dataframe 的内存数据(因为底层数据格式通用)，因此，这个过程中的输入和输出数据的传输时间几乎可以忽略不计。&#xA;并且，这个过程中，duckdb比 pandas 更快处理数据(多线程)，并且内存使用量也比 pandas 要低得多。&#xA;特别在一些需要分组的数据处理任务上，就算只使用单线程的 duckdb 也会比 pandas 的快两倍。如果是过滤+分组+列投影，会存在 5-8倍 的差异。</description>
    </item>
    <item>
      <title>数据库连接轻松搞定：Python 数据库推荐</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9Apython-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A8%E8%8D%90/</link>
      <pubDate>Sat, 12 Aug 2023 17:56:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E8%BD%BB%E6%9D%BE%E6%90%9E%E5%AE%9Apython-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8E%A8%E8%8D%90/</guid>
      <description>SQLite3：轻巧便捷的数据库连接# 首先，让我们认识一下 SQLite3 这个轻巧便捷的库。它是 Python 中自带的数据库模块，适用于小型应用和快速原型开发。&#xA;让我们来看看 SQLite3 的魔法：&#xA;import sqlite3 ## 连接数据库 conn = sqlite3.connect(&amp;#34;mydatabase.db&amp;#34;) ## 创建表格 cursor = conn.cursor() cursor.execute(&amp;#34;CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY, name TEXT, age INTEGER)&amp;#34;) ## 插入数据 cursor.execute(&amp;#34;INSERT INTO users (name, age) VALUES (?, ?)&amp;#34;, (&amp;#34;Alice&amp;#34;, 25)) cursor.execute(&amp;#34;INSERT INTO users (name, age) VALUES (?, ?)&amp;#34;, (&amp;#34;Bob&amp;#34;, 30)) ## 查询数据 cursor.execute(&amp;#34;SELECT * FROM users&amp;#34;) rows = cursor.fetchall() for row in rows: print(row) ## 关闭连接 conn.</description>
    </item>
    <item>
      <title>QEMU - QuickStart</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/system/qemu-quickstart/</link>
      <pubDate>Sun, 06 Aug 2023 18:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/system/qemu-quickstart/</guid>
      <description>https://cyan-io.github.io/ Intro# QEMU是一款跨平台的开源虚拟机工具，因为无GUI配置工具，有一定使用门槛&#xA;根据冯诺依曼结构，一个计算机可分为：&#xA;运算器 控制器 存储器 输入设备 输出设备 使用QEMU时，应该尽量往该模型联想 创建存储器# 创建一个16G的虚拟磁盘文件&#xA;qemu-img create -f qcow2 drive 16G 虚拟硬件环境# 运算器、控制器 -&amp;gt; CPU、各种加速器* 输入、输出设备 -&amp;gt; 网卡、CXL设备等 QEMU本身没有像VMware那样的GUI配置界面，所有配置通过命令行参数指定&#xA;qemu-system-x86_64 -machine q35 \ -smp 4,sockets=1,cores=4,threads=1 \ -m 4096 现在启动了一个机型为q35，处理器1插槽4核4线程，内存4096MB，使用默认网络配置的虚拟机，由于没有启动盘，并不会启动某个系统&#xA;利用虚拟硬件环境启动系统# 我们已经有了一块硬盘drive作为启动盘，指定给虚拟环境：&#xA;qemu-system-x86_64 -machine q35 \ -smp 4,sockets=1,cores=4,threads=1 \ -m 4096 \ -drive file=drive 会发现，指定后并没有什么区别，是因为这个“硬盘”我们没有给它“安装”系统&#xA;安装系统# 参考为物理机安装系统：&#xA;物理机硬盘 -&amp;gt; 虚拟磁盘文件drive 安装媒介（写入了镜像的U盘） -&amp;gt; 系统镜像文件&#xA;qemu-system-x86_64 -machine q35 \ -smp 4,sockets=1,cores=4,threads=1 \ -m 4096 \ -drive file=drive \ -drive file=&amp;lt;系统镜像，如ubuntu-22.</description>
    </item>
    <item>
      <title>emoji</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/emoji/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/emoji/</guid>
      <description>🛐 宗教场所 place of worship&#xA;⚛️ 原子符号 atom symbol&#xA;🕉️ 奥姆 om&#xA;✡️ 六芒星 star of David&#xA;☸️ 法轮 wheel of dharma&#xA;☯️ 阴阳 yin yang&#xA;✝️ 十字架 latin cross&#xA;☦️ 东正教十字架 orthodox cross&#xA;☪️ 星月 star and crescent&#xA;☮️ 和平符号 pease symbol&#xA;🕎烛台 menorah&#xA;🔯带中间点的六芒星 dotted six-pointed star</description>
    </item>
    <item>
      <title>live_max_online</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/live_max_online/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/live_max_online/</guid>
      <description>-- step0 建表 -- drop table cm.tb_live_logs; create table cm.tb_live_logs ( live_id int, user_id int, ts datetime, type varchar(10) ); -- step1 插入数据 insert into cm.tb_live_logs (live_id, user_id, ts, type) values (901,1001,&amp;#39;2022-10-01 12:00:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1002,&amp;#39;2022-10-01 12:01:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1003,&amp;#39;2022-10-01 12:01:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1004,&amp;#39;2022-10-01 12:02:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1005,&amp;#39;2022-10-01 12:02:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1006,&amp;#39;2022-10-01 12:03:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1007,&amp;#39;2022-10-01 12:03:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1008,&amp;#39;2022-10-01 12:05:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1009,&amp;#39;2022-10-01 12:05:00&amp;#39;,&amp;#39;IN&amp;#39;), (901,1010,&amp;#39;2022-10-01 12:06:03&amp;#39;,&amp;#39;IN&amp;#39;), (902,1101,&amp;#39;2022-10-01 12:00:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1102,&amp;#39;2022-10-01 12:01:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1103,&amp;#39;2022-10-01 12:01:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1104,&amp;#39;2022-10-01 12:02:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1105,&amp;#39;2022-10-01 12:29:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1106,&amp;#39;2022-10-01 12:30:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1107,&amp;#39;2022-10-01 12:31:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1108,&amp;#39;2022-10-01 12:32:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1109,&amp;#39;2022-10-01 12:39:00&amp;#39;,&amp;#39;IN&amp;#39;), (902,1110,&amp;#39;2022-10-01 12:06:03&amp;#39;,&amp;#39;IN&amp;#39;), (901,1001,&amp;#39;2022-10-01 12:03:03&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1002,&amp;#39;2022-10-01 12:01:00&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1003,&amp;#39;2022-10-01 12:03:03&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1004,&amp;#39;2022-10-01 12:05:03&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1005,&amp;#39;2022-10-01 12:10:03&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1006,&amp;#39;2022-10-01 12:03:01&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1007,&amp;#39;2022-10-01 12:03:03&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1008,&amp;#39;2022-10-01 12:06:12&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1009,&amp;#39;2022-10-01 12:06:03&amp;#39;,&amp;#39;OUT&amp;#39;), (901,1010,&amp;#39;2022-10-01 12:10:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1101,&amp;#39;2022-10-01 12:03:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1102,&amp;#39;2022-10-01 12:03:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1103,&amp;#39;2022-10-01 12:03:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1104,&amp;#39;2022-10-01 12:05:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1105,&amp;#39;2022-10-01 12:30:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1106,&amp;#39;2022-10-01 12:30:01&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1107,&amp;#39;2022-10-01 12:40:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1108,&amp;#39;2022-10-01 12:44:12&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1109,&amp;#39;2022-10-01 12:42:03&amp;#39;,&amp;#39;OUT&amp;#39;), (902,1110,&amp;#39;2022-10-01 12:10:03&amp;#39;,&amp;#39;OUT&amp;#39;); -- step2 IN/OUT转数字 select live_id, user_id, ts , IF(type = &amp;#39;IN&amp;#39;, 1, -1) as contribution from cm.</description>
    </item>
    <item>
      <title>MySQL常用30种SQL查询语句优化方法</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/mysql-commonly-uses-30-sql-query-statement-optimization-methods/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/mysql-commonly-uses-30-sql-query-statement-optimization-methods/</guid>
      <description>引言# 在开发和维护MySQL数据库时，优化SQL查询语句是提高数据库性能和响应速度的关键。通过合理优化SQL查询，可以减少数据库的负载，提高查询效率，为用户提供更好的用户体验。本文将介绍常用的30种MySQL SQL查询优化方法，并通过实际案例演示它们的应用。&#xA;第一部分：基础优化方法# 1.使用索引# 索引是提高数据库查询性能的基础，通过为查询字段添加合适的索引，可以加快查询速度。在创建索引时，需要考虑查询的频率和数据的更新频率，避免过度索引或不必要的索引。&#xA;-- 创建索引 CREATE INDEX idx_column ON table_name(column_name); 2.避免使用SELECT *# 在查询数据时，尽量避免使用SELECT *，而是明确指定需要查询的字段。这样可以减少返回的数据量，提高查询效率。&#xA;-- 不推荐 SELECT * FROM table_name; -- 推荐 SELECT column1, column2 FROM table_name; 3.使用EXPLAIN分析查询计划# 使用EXPLAIN命令可以分析查询的执行计划，帮助优化查询语句，查找潜在的性能问题。&#xA;EXPLAIN SELECT * FROM table_name WHERE column_name = &amp;#39;value&amp;#39;; 第二部分：优化查询条件# 4.使用WHERE子句过滤数据# 在查询数据时，尽量使用WHERE子句对数据进行过滤，减少返回的数据量。&#xA;-- 不推荐 SELECT * FROM table_name; -- 推荐 SELECT * FROM table_name WHERE column_name = &amp;#39;value&amp;#39;; 5.使用索引覆盖查询# 索引覆盖查询是指查询的字段都包含在索引中，不需要回表查询数据。这样可以减少IO操作，提高查询效率。&#xA;-- 创建索引 CREATE INDEX idx_column ON table_name(column_name); -- 索引覆盖查询 SELECT column1, column2 FROM table_name WHERE column_name = &amp;#39;value&amp;#39;; 6.</description>
    </item>
    <item>
      <title>SQL每日一题(20230814)</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-20230814/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-20230814/</guid>
      <description>SQL每日一题(20230814)# 题目# 有如下两张表G0227A（客户表）&#xA;Id Name 1 曹操 2 关于 3 刘备 4 张飞 G0227B（订单表）&#xA;Id CustomerId 1 3 2 1 查询G0227B表（订单表）中找出从来没有买过商品的用户。&#xA;预计结果如下：&#xA;Id Name 2 关于 要求：用至少四种方法求解。# create table G0814A ( Id int, Name varchar(20) ) insert into G0814A values (1,&amp;#39;曹操&amp;#39;); insert into G0814A values (2,&amp;#39;关羽&amp;#39;); insert into G0814A values (3,&amp;#39;刘备&amp;#39;); insert into G0814A values (4,&amp;#39;张飞&amp;#39;); create table G0814B( Id int, CustomerId int ) insert into G0814B values (1,3); insert into G0814B values (2,1); 参考答案# -- 方法一: 关联查询 SELECT a.</description>
    </item>
    <item>
      <title>SQL每日一题F0215，多种方法及思路讲解</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f0215-a-variety-of-methods-and-ideas-explained/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f0215-a-variety-of-methods-and-ideas-explained/</guid>
      <description>SQL每日一题F0215，多种方法及思路讲解# CREATE TABLE F0215 ( StuID INT, CID VARCHAR(10), Course INT ) INSERT INTO F0215 VALUES (1,&amp;#39;001&amp;#39;,67), (1,&amp;#39;002&amp;#39;,89), (1,&amp;#39;003&amp;#39;,94), (2,&amp;#39;001&amp;#39;,95), (2,&amp;#39;002&amp;#39;,88), (2,&amp;#39;004&amp;#39;,78), (3,&amp;#39;001&amp;#39;,94), (3,&amp;#39;002&amp;#39;,77), (3,&amp;#39;003&amp;#39;,90) select * from f0215 /* 查询出既学过&amp;#39;001&amp;#39;课程，也学过&amp;#39;003&amp;#39;号课程的学生ID */ --错误写法 SELECT * FROM F0215 WHERE CID=&amp;#39;001&amp;#39; AND CID=&amp;#39;003&amp;#39; SELECT * FROM F0215 WHERE CID=&amp;#39;001&amp;#39; OR CID=&amp;#39;003&amp;#39; --思路一，取自连接符合条件的学生 SELECT T1.STUID FROM ( SELECT STUID FROM F0215 WHERE CID=&amp;#39;001&amp;#39; ) T1 INNER JOIN (SELECT STUID FROM F0215 WHERE CID=&amp;#39;003&amp;#39; ) T2 ON T2.</description>
    </item>
    <item>
      <title>SQL每日一题F1021，while循环操作</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f1021-while-loop-operation/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f1021-while-loop-operation/</guid>
      <description>SQL每日一题F1021，while循环操作# /* 写一个查询语句要求 求出整数1到100之间排除55后的和 预计结果是4995 该如何写这个查询？&#xA;要求：使用while循环 */&#xA;DECLARE @i INT DECLARE @sum INT SET @i=0 SET @sum=0 WHILE @i&amp;lt;100 BEGIN SET @i=@i+1 IF @i=55 CONTINUE ELSE SET @sum=@sum+@i END PRINT @sum</description>
    </item>
    <item>
      <title>SQL每日一题F1025，复杂逻辑处理</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f1025-complex-logic-processing/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f1025-complex-logic-processing/</guid>
      <description>SQL每日一题F1025，复杂逻辑处理# create table F1025 ( id int, num int ) insert into F1025 values(1,5); insert into F1025 values(2,11); insert into F1025 values(3,0); insert into F1025 values(4,-2); insert into F1025 values(5,2); insert into F1025 values(6,9); insert into F1025 values(7,1); insert into F1025 values(8,-4); insert into F1025 values(9,-7); &amp;ndash; Q：要求当Num中的数据同时大于上下两行数据，返回值为“是”， &amp;ndash; 当Num中的数据小于上下两行数据中的任何一行，返回值为“否” &amp;ndash; 例如：11大于5,11大于0，所以11那行返回值为“是”；5小于11，所以5那行返回值为“否”&#xA;SELECT a.id ,a.Num ,CASE WHEN a.Num&amp;gt;ISNULL(( SELECT Num FROM F1025 b WHERE b.id=a.id-1 ),a.Num-1) AND a.Num&amp;gt;ISNULL(( SELECT Num FROM F1025 c WHERE c.</description>
    </item>
    <item>
      <title>SQL每日一题F1028，关联子查询</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f1028-correlation-subquery/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/sql-daily-question-f1028-correlation-subquery/</guid>
      <description>SQL每日一题F1028，关联子查询# create table F1028A (aid varchar(20), bid varchar(20) ) insert into F1028A values (&amp;lsquo;跑步&amp;rsquo;,&amp;lsquo;张三&amp;rsquo;); insert into F1028A values (&amp;lsquo;游泳&amp;rsquo;,&amp;lsquo;张三&amp;rsquo;); insert into F1028A values (&amp;lsquo;跳远&amp;rsquo;,&amp;lsquo;李四&amp;rsquo;); insert into F1028A values (&amp;lsquo;跳高&amp;rsquo;,&amp;lsquo;王五&amp;rsquo;);&#xA;create table F1028B (aid varchar(20), bid varchar(20), cid varchar(20) ) insert into F1028B values (&amp;lsquo;跑步&amp;rsquo;,&amp;lsquo;张三&amp;rsquo;,&amp;lsquo;胜利&amp;rsquo;); insert into F1028B values (&amp;lsquo;游泳&amp;rsquo;,&amp;lsquo;张三&amp;rsquo;,&amp;lsquo;胜利&amp;rsquo;); insert into F1028B values (&amp;lsquo;跳高&amp;rsquo;,&amp;lsquo;王五&amp;rsquo;,&amp;lsquo;胜利&amp;rsquo;);&#xA;&amp;ndash; Q：anum表示每个人参加的项目数，bnum表示每个人在各自项目中胜利的次数，该如何写这个查询？&#xA;&amp;ndash;解法一： SELECT ISNULL(t1.bid, t2.bid) AS bid, ISNULL(t1.anum, 0) anum, ISNULL(t2.bnum, 0) bnum FROM ( SELECT bid, COUNT(1) AS anum FROM F1028A GROUP BY bid ) t1 FULL JOIN ( SELECT bid, SUM(CASE WHEN cid = &amp;lsquo;胜利&amp;rsquo; THEN 1 ELSE 0 END ) bnum FROM F1028B GROUP BY bid ) t2 ON t2.</description>
    </item>
    <item>
      <title>top10_sql_skills</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/top10_sql_skills/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/top10_sql_skills/</guid>
      <description>-- 01 -- bad create table cm.tb_user( id int, name varchar(255), age int, gender varchar(16) ); -- good create table cm.tb_user( id int primary key, name varchar(255), age int, gender varchar(16), store_time datetime default now() ); -- 02 -- bad create table cm.tb_user( id int primary key , name varchar(255) not null default &amp;#39;NULL&amp;#39;, age int, gender varchar(16), create_time datetime default now(), update_time datetime default now() ); -- good create table cm.</description>
    </item>
    <item>
      <title>查询连续登陆3天的用户id和登陆天数</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/online_users_with_3_consecutive_days/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/online_users_with_3_consecutive_days/</guid>
      <description>-- 查询连续登陆3天的用户id和登陆天数 -- step1:用户登录日期去重 select distinct user_id, date(visit_time) as dt from cm.tb_user_logs; -- step2:用row_number()计数 select *, row_number() over (PARTITION by user_id order by dt) as xrank from (select distinct user_id, date(visit_time) as dt from cm.tb_user_logs) a; -- step3: 日期减去计数值得到差值delta select *, date_sub(dt, INTERVAL xrank DAY) as delta from (select *, row_number() over (PARTITION by user_id order by dt) as xrank from (select distinct user_id, date(visit_time) as dt from cm.tb_user_logs) a ) b; -- step4:根据id和结果分组并计算总和,大于等于3的即为连续登录3天的用户 select user_id, min(dt) as start_date, count(*) as days from (select *, date_sub(dt, INTERVAL xrank DAY) as delta from (select *, row_number() over (PARTITION by user_id order by dt) as xrank from (select distinct user_id, date(visit_time) as dt from cm.</description>
    </item>
    <item>
      <title>给定用户登录表，求表中每一天的3天留存率</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/3days_alive_users/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/3days_alive_users/</guid>
      <description>-- 给定用户登录表，求表中每一天的&amp;#34;3天留存率&amp;#34; -- step 0 表准备，用户ID，登录时间 create table cm.tb_user_logs( user_id int, visit_time datetime ); insert into cm.tb_user_logs (user_id, visit_time) values (1001, &amp;#39;2022-10-01 08:01:23&amp;#39;), (1001, &amp;#39;2022-10-01 08:11:15&amp;#39;), (1002, &amp;#39;2022-10-01 08:22:19&amp;#39;), (1003, &amp;#39;2022-10-01 09:00:53&amp;#39;), (1002, &amp;#39;2022-10-02 18:00:13&amp;#39;), (1004, &amp;#39;2022-10-02 13:30:43&amp;#39;), (1004, &amp;#39;2022-10-02 15:06:22&amp;#39;), (1005, &amp;#39;2022-10-02 08:00:39&amp;#39;), (1002, &amp;#39;2022-10-03 08:00:13&amp;#39;), (1003, &amp;#39;2022-10-03 18:00:13&amp;#39;), (1004, &amp;#39;2022-10-03 21:00:13&amp;#39;), (1006, &amp;#39;2022-10-03 22:00:13&amp;#39;), (1001, &amp;#39;2022-10-04 11:10:13&amp;#39;), (1002, &amp;#39;2022-10-04 12:00:13&amp;#39;), (1002, &amp;#39;2022-10-04 09:00:13&amp;#39;), (1004, &amp;#39;2022-10-04 08:00:13&amp;#39;), (1006, &amp;#39;2022-10-04 08:00:13&amp;#39;), (1004, &amp;#39;2022-10-05 08:00:13&amp;#39;), (1005, &amp;#39;2022-10-05 08:00:13&amp;#39;), (1002, &amp;#39;2022-10-05 08:00:43&amp;#39;), (1003, &amp;#39;2022-10-05 12:00:13&amp;#39;), (1004, &amp;#39;2022-10-05 10:00:43&amp;#39;), (1006, &amp;#39;2022-10-05 08:00:11&amp;#39;), (1001, &amp;#39;2022-10-06 09:00:47&amp;#39;), (1001, &amp;#39;2022-10-06 07:00:15&amp;#39;), (1002, &amp;#39;2022-10-06 18:00:43&amp;#39;), (1003, &amp;#39;2022-10-07 20:00:19&amp;#39;), (1002, &amp;#39;2022-10-07 21:00:23&amp;#39;), (1004, &amp;#39;2022-10-07 22:00:43&amp;#39;); -- step 1 创建视图，进行用户ID和时间去重 create view A as select distinct user_id, date(visit_time) as dt from cm.</description>
    </item>
    <item>
      <title>求占据前90%销售额的商品类型</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/90_percent_contribution_goods/</link>
      <pubDate>Tue, 01 Aug 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/sql/90_percent_contribution_goods/</guid>
      <description>-- 求占据前90%销售额的商品类型 -- step0. 准备数据 create table cm.tb_sale_amount( good_category int comment &amp;#39;商品类型ID&amp;#39;, sale_date date comment &amp;#39;销售日期&amp;#39;, amount int comment &amp;#39;销售额&amp;#39;, primary key(good_category, sale_date) ); truncate cm.tb_sale_amount; insert into cm.tb_sale_amount (good_category, sale_date, amount) values (1003, &amp;#39;2022-01-10&amp;#39;, 264), (1001, &amp;#39;2022-06-01&amp;#39;, 21), (1005, &amp;#39;2022-06-01&amp;#39;, 73), (1002, &amp;#39;2022-06-27&amp;#39;, 44), (1006, &amp;#39;2022-06-27&amp;#39;, 405), (1003, &amp;#39;2022-09-10&amp;#39;, 16), (1005, &amp;#39;2022-09-13&amp;#39;, 72), (1004, &amp;#39;2022-10-01&amp;#39;, 29), (1005, &amp;#39;2022-10-03&amp;#39;, 332), (1001, &amp;#39;2022-10-29&amp;#39;, 10), (1006, &amp;#39;2022-10-29&amp;#39;, 137), (1002, &amp;#39;2022-12-02&amp;#39;, 23), (1007, &amp;#39;2022-12-02&amp;#39;, 19), (1003, &amp;#39;2022-12-02&amp;#39;, 30), (1008, &amp;#39;2022-12-03&amp;#39;, 3), (1009, &amp;#39;2022-12-04&amp;#39;, 1), (1010, &amp;#39;2022-12-05&amp;#39;, 9), (1003, &amp;#39;2022-12-30&amp;#39;, 121); -- step1.</description>
    </item>
    <item>
      <title>WSL（适用于 Linux 的 Windows 子系统）Kali在线安装</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/system/wsl%E9%80%82%E7%94%A8%E4%BA%8E-linux-%E7%9A%84-windows-%E5%AD%90%E7%B3%BB%E7%BB%9Fkali%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85/</link>
      <pubDate>Thu, 27 Jul 2023 18:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/system/wsl%E9%80%82%E7%94%A8%E4%BA%8E-linux-%E7%9A%84-windows-%E5%AD%90%E7%B3%BB%E7%BB%9Fkali%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85/</guid>
      <description>WSL-Kali安装说明：https://www.kali.org/docs/wsl/win-kex/ WSL-Kali软件安装：https://blog.csdn.net/NDASH/article/details/124147241 WSL-Kali报错解决：https://blog.csdn.net/m0_65228980/article/details/124748981 本文已过时，应适用WSL旧版本&#xA;PS：不建议使用WSL安装Kali，安装后Kali问题很多，不好解决，使用虚拟机更实用&#xA;1 安装虚拟镜像# powershell中执行&#xA;wsl -l -v&#xA;确认用的是version 2，才能开始下一步。&#xA;什么是WSL# WSL——适用于 Linux 的 Windows 子系统可让开发人员直接在 Windows 上按原样运行 GNU/Linux 环境（包括大多数命令行工具、实用工具和应用程序），且不会产生传统虚拟机或双启动设置开销。 WSL的安装# Windows环境配置# 使用版本：Windows 10 （自动更新到最新版） 1、启用Windows功能# 控制面板–&amp;gt;程序与功能–&amp;gt;启用或关闭Windows功能，选中 适用于Linux的Windows子系统 和 虚拟机平台。 见官方文档：https://docs.microsoft.com/zh-cn/windows/wsl/install-on-server&#xA;2、设置Windows预览体验计划# 开始–&amp;gt;设置–&amp;gt;更新和安全–&amp;gt;Windows预览体验计划，如下图。按提示重启电脑。 见官方文档：https://docs.microsoft.com/zh-cn/windows/wsl/install-win10 Windows预览体验计划文档：https://insider.windows.com/en-us/getting-started#flight&#xA;WSL简单安装（需PowerShell管理员权限）# 官方文档给出简单安装方法。 官方文档：https://devblogs.microsoft.com/commandline/install-wsl-with-a-single-command-now-available-in-windows-10-version-2004-and-higher/ 1、查看支持系统列表（默认Ubuntu，在线安装）# wsl --list --online 2、选中系统安装# 本文选中 Kali linux 安装 输入命令，等待安装完成。 wsl --install -d kali-linux 3、配置用户名密码# 用户名不支持大写首字母，输入密码是看不见的。 官方文档：https://docs.microsoft.com/zh-cn/windows/wsl/user-support 4、成功# 2 启用systemd# 在Kali环境终端输入&#xA;echo -e &amp;ldquo;[boot]\nsystemd=true&amp;rdquo; | sudo tee -a /etc/wsl.conf</description>
    </item>
    <item>
      <title>a段落处理</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/a%E6%AE%B5%E8%90%BD%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/a%E6%AE%B5%E8%90%BD%E5%A4%84%E7%90%86/</guid>
      <description>&lt;h2 id=&#39;a段落处理&#39;&gt;a段落处理&lt;a href=&#39;#a%e6%ae%b5%e8%90%bd%e5%a4%84%e7%90%86&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>b表单处理</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/b%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/b%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86/</guid>
      <description>&lt;h2 id=&#39;b表单处理&#39;&gt;b表单处理&lt;a href=&#39;#b%e8%a1%a8%e5%8d%95%e5%a4%84%e7%90%86&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>c数字</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/c%E6%95%B0%E5%AD%97/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/c%E6%95%B0%E5%AD%97/</guid>
      <description>&lt;h2 id=&#39;c数字&#39;&gt;c数字&lt;a href=&#39;#c%e6%95%b0%e5%ad%97&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>d文字</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/d%E6%96%87%E5%AD%97/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/d%E6%96%87%E5%AD%97/</guid>
      <description>&lt;h2 id=&#39;d文字&#39;&gt;d文字&lt;a href=&#39;#d%e6%96%87%e5%ad%97&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>e大纲</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/e%E5%A4%A7%E7%BA%B2/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/e%E5%A4%A7%E7%BA%B2/</guid>
      <description>&lt;h2 id=&#39;e大纲&#39;&gt;e大纲&lt;a href=&#39;#e%e5%a4%a7%e7%ba%b2&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>fExcel贴数</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/fexcel%E8%B4%B4%E6%95%B0/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/fexcel%E8%B4%B4%E6%95%B0/</guid>
      <description>&lt;h2 id=&#39;fexcel贴数&#39;&gt;fExcel贴数&lt;a href=&#39;#fexcel%e8%b4%b4%e6%95%b0&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>g批注</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/g%E6%89%B9%E6%B3%A8/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/g%E6%89%B9%E6%B3%A8/</guid>
      <description>&lt;h2 id=&#39;g批注&#39;&gt;g批注&lt;a href=&#39;#g%e6%89%b9%e6%b3%a8&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>h行列校验</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/h%E8%A1%8C%E5%88%97%E6%A0%A1%E9%AA%8C/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/h%E8%A1%8C%E5%88%97%E6%A0%A1%E9%AA%8C/</guid>
      <description>&lt;h2 id=&#39;h行列校验&#39;&gt;h行列校验&lt;a href=&#39;#h%e8%a1%8c%e5%88%97%e6%a0%a1%e9%aa%8c&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>i多表处理</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/i%E5%A4%9A%E8%A1%A8%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/i%E5%A4%9A%E8%A1%A8%E5%A4%84%E7%90%86/</guid>
      <description>&lt;h2 id=&#39;i多表处理&#39;&gt;i多表处理&lt;a href=&#39;#i%e5%a4%9a%e8%a1%a8%e5%a4%84%e7%90%86&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>JsonConverter</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/jsonconverter/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/jsonconverter/</guid>
      <description>&lt;h2 id=&#39;jsonconverter&#39;&gt;JsonConverter&lt;a href=&#39;#jsonconverter&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>j页面设置</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/j%E9%A1%B5%E9%9D%A2%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/j%E9%A1%B5%E9%9D%A2%E8%AE%BE%E7%BD%AE/</guid>
      <description>&lt;h2 id=&#39;j页面设置&#39;&gt;j页面设置&lt;a href=&#39;#j%e9%a1%b5%e9%9d%a2%e8%ae%be%e7%bd%ae&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>k访谈提纲</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/k%E8%AE%BF%E8%B0%88%E6%8F%90%E7%BA%B2/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/k%E8%AE%BF%E8%B0%88%E6%8F%90%E7%BA%B2/</guid>
      <description>&lt;h2 id=&#39;k访谈提纲&#39;&gt;k访谈提纲&lt;a href=&#39;#k%e8%ae%bf%e8%b0%88%e6%8f%90%e7%ba%b2&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>底稿小帮手代码</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/</guid>
      <description>&lt;h2 id=&#39;a段落处理&#39;&gt;a段落处理&lt;a href=&#39;#a%e6%ae%b5%e8%90%bd%e5%a4%84%e7%90%86&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>更新</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/%E6%9B%B4%E6%96%B0/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/%E6%9B%B4%E6%96%B0/</guid>
      <description>&lt;h2 id=&#39;更新&#39;&gt;更新&lt;a href=&#39;#%e6%9b%b4%e6%96%b0&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>类模块</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/%E7%B1%BB%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Mon, 15 May 2023 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/vba/%E5%BA%95%E7%A8%BF%E5%B0%8F%E5%B8%AE%E6%89%8B%E4%BB%A3%E7%A0%81/%E7%B1%BB%E6%A8%A1%E5%9D%97/</guid>
      <description>&lt;h2 id=&#39;类模块&#39;&gt;类模块&lt;a href=&#39;#%e7%b1%bb%e6%a8%a1%e5%9d%97&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>国内AI集锦</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/%E5%9B%BD%E5%86%85ai%E9%9B%86%E9%94%A6/</link>
      <pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/%E5%9B%BD%E5%86%85ai%E9%9B%86%E9%94%A6/</guid>
      <description>• 科大讯飞（讯飞星火）：https://xinghuo.xfyun.cn/&#xA;• 百度（文心一言）https://yiyan.baidu.com/welcome&#xA;• 阿里（通义千问）https://qianwen.aliyun.com/&#xA;• 抖音（云雀大模型）https://www.doubao.com/&#xA;• 360 （360智脑）https://ai.360.com/&#xA;• 智谱 AI（GLM大模型）https://chatglm.cn/&#xA;• 中科院（紫东太初大模型）https://xihe.mindspore.cn/&#xA;• 百川智能（百川大模型）https://www.baichuan-ai.com/&#xA;• 商汤（日日新大模型）https://techday.sensetime.com/&#xA;• MiniMax（ABAB大模型）https://api.minimax.chat/&#xA;• 上海人工智能实验室（书生通用大模型）https://intern-ai.org.cn/&#xA;• 华为（盘古大模型）https://www.huaweicloud.com/product/pangu.html</description>
    </item>
    <item>
      <title>史上最全的数据透视表用法</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/excel/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%8F%E8%A7%86%E8%A1%A8%E7%94%A8%E6%B3%95/</link>
      <pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/excel/%E5%8F%B2%E4%B8%8A%E6%9C%80%E5%85%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%8F%E8%A7%86%E8%A1%A8%E7%94%A8%E6%B3%95/</guid>
      <description>数据透视表是Excel中最实用最常用的功能，没有之一。今天小编对数据透视表进行一次全面的整理，共五大类，23个技巧。 目录&#xA;一、基本操作&#xA;1、创建数据透视表&#xA;2、更改数据源&#xA;3、转换为普通表格&#xA;4、刷新所有数据透视表&#xA;5、数据透视表排序&#xA;6、数据透视表插入公式&#xA;7、套用模板&#xA;8、使用切片器&#xA;9、恢复03经典数据透视表样式&#xA;二、布局有格式调整&#xA;1、计数项改为求和项&#xA;2、批量隐藏和显示汇总行&#xA;3、刷新后格式保持不变&#xA;4、合并行标签&#xA;5、删除“求和项：”&#xA;6、标签项重复显示&#xA;三、组合&#xA;1、日期组合&#xA;2、根据数字期间组合&#xA;四、数据分析&#xA;1、各部门人数占比&#xA;2、各个年龄段人数和占比&#xA;3、各个部门各年龄段占比&#xA;4、各部门学历统计&#xA;5、按年份统计各部门入职人数&#xA;五、多表合并&#xA;1、多区域合并生成&#xA;一、基本操作# 1、创建数据透视表# 2、更改数据源# 3、数据透视表转换为普通表格# 4、数据透视表刷新# 5、数据透视表排序# 6、数据透视表插入公式# 7、套用设计模板# 8、使用切片器# 9、恢复经典数据透视表样式# 07及以上版本制作的数据透视表无法用鼠标拖放，可以修改为经典模式：&#xA;二、布局与格式调整# 1、计数项改为求和项# 注：如果需要修改的很多，可以重新以前2行为数据源制作数据透视表，最后再更改数据源为全部数据行。&#xA;2、隐藏汇总行# 可以分字段隐藏，也可以一次性隐藏或显示&#xA;3、刷新后保持列宽不变# 4、合并标签所在单元格# 5、删除求和项# 6、标签项重复显示# 三、组合功能# 1、按年、季度、月汇总报表# 2、按数字步长组合# 四、数据分析# 1、各部门人数占比# 统计每个部门占总人数的百分比&#xA;2、各个年龄段人数和占比# 公司员工各个年龄段的人数和占比各是多少呢？&#xA;3、各个部门各年龄段占比# 分部门统计本部门各个年龄段的占比情况&#xA;4、各部门学历统计# 各部门大专、本科、硕士和博士各有多少人呢？&#xA;5、按年份统计各部门入职人数# 每年各部门入职人数情况&#xA;五、多表合并# 1、多区域合并# </description>
    </item>
    <item>
      <title>Golang入门笔记-CH01-Go语言介绍与安装</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch01-go%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch01-go%E8%AF%AD%E8%A8%80%E4%BB%8B%E7%BB%8D%E4%B8%8E%E5%AE%89%E8%A3%85/</guid>
      <description>1. Go 语言介绍# 1.1 Go 语言的发展# Go 语言又称 Golang，起源于 2007 年，来自于谷歌内部的一个项目，于 2009 年正式对外发布。创始团队有三人，都是计算机界的大佬：&#xA;Robert Griesemer：参与开发 Java HotSpot 虚拟机 Rob Pike：Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言 Ken Thompson：C 语言、Unix 和 Plan 9 的创始人之一 Go 语言是开源的，通过开源社区的力量得到了快速发展，越来越多的开发者开始使用 Go 语言。自 Go 语言发布以来，超过 200 名非谷歌员工贡献者对 Go 语言核心部分提交了超过 1000 个修改建议。在过去的 18 个月里，又有 150 开发者贡献了新的核心代码。&#xA;根据 TIOBE 2020 年 8 月份的编程语言排行榜，Go 语言位列第 11 位。&#xA;国内也有很多大厂在用 Go 语言，包括腾讯、阿里、百度、B 站、知乎等，我们可以看到 Go 语言的潜力还是非常大 的。&#xA;1.2 Go 语言的特点# Go 语言的主要特点有：</description>
    </item>
    <item>
      <title>Golang入门笔记-CH02-Go语言基本语法和结构</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch02-go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E7%BB%93%E6%9E%84/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch02-go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E5%92%8C%E7%BB%93%E6%9E%84/</guid>
      <description>1. 命名规范# 1.1 文件# Go 语言中，源文件以 .go 格式保存，例如 main.go，且文件名只能由小写字母组成，若有多个单词，可以用下划线 _ 进行拼接，例如 my_file.go。&#xA;1.2 标识符# Go 语言中，标识符是区分大小写的，标识符必须以字符或 _ 开头，后面可以跟 0 个或多个字符（字母、数字以及其他符号），例如 _，_abc，a1，b_2。同时标识符不能是 Go 语言中的保留关键字，不能以数字开头，也不能有运算符。&#xA;以下这些标识符是错误的：&#xA;2c（不能以数字开头） switch（不能是保留关键字） m+n（不能出现运算符） _ 是一个特殊的标识符，叫做空白标识符。它既可以被赋值或定义（任意类型的数据），但它接收的值将被抛弃，无法在代码中继续使用。有时候函数会返回多个值，我们可能不需要使用某些值，便可以用 _ 来接收，提高代码的灵活性。&#xA;用 _ 接收的变量统称为匿名变量。&#xA;1.3 保留关键字# 以下是 Go 语言中的保留关键字:&#xA;保留关键字仅 25 个，还是比较少的，有利于加快编译速度。&#xA;break default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var 1.4 预定义标识符# 以下是 Go 语言中 36 个预定义标识符，在后面我们会用到：</description>
    </item>
    <item>
      <title>Golang入门笔记-CH03-Go语言基本数据类型</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch03-go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch03-go%E8%AF%AD%E8%A8%80%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>1. 常量# 1.1 常量的定义# 常量是一种特殊的变量，被初始化之后就无法再改变。&#xA;Go 语言中，常量的类型只能是布尔型，数字型（整型、浮点型和复数）和字符串型。&#xA;常量可以使用关键字 const 来定义，定义格式为 const variable [type] = value。&#xA;const m string = &amp;#34;abc&amp;#34; // 显示声明 const n = &amp;#34;xyz&amp;#34; // 隐式声明 常量的值必须在编译时能确定，给常量赋值时可以涉及表达式的计算，但计算值必须能在编译时确定。&#xA;const m = 2/3 // 正确 const n = getValue() // 错误，编译时自定义函数属于未知，无法用于常量赋值，但可以使用内置函数，如 len() 1.2 枚举# 常量也可以用于枚举：&#xA;Unknown 表示未知性别，Female 表示女性，Male 表示男性。&#xA;const ( Unknown = 0 Female = 1 Male = 2 ) itoa 是一个特殊的常量，itoa 在 const 关键字出现时被重置为 0；const 中每多声明一行常量，itos 会自动加 1（ itoa 可理解成常量的行索引）。如：</description>
    </item>
    <item>
      <title>Golang入门笔记-CH04-Go语言流程控制</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch04-go%E8%AF%AD%E8%A8%80%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch04-go%E8%AF%AD%E8%A8%80%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</guid>
      <description>前言# 流程控制是每门语言控制程序逻辑和执行顺序的重要组成部分，Go 语言中常见的流程控制有 if，for，switch；break、continue 和 goto 是为了简化流程控制，降低代码复杂度。&#xA;if-else# if 分支结构的基本写法为：&#xA;if 分支结构多用于条件判断。&#xA;if 表达式1 { 分支1 } else if 表达式2 { 分支2 } else { 分支3 } 上述代码中，若表达式1的值为 true，程序将会执行分支1；若表达式1的值为 false，继续判断表达式2，若表达式2为 true，将会执行分支2；若表达式1和表达式2都为false，将会执行分支3。&#xA;if-else 分支结构会逐层判断表达式是否为 true，若为 true，则执行该表达式中对应的分支，否则继续判断下一个表达式，依次类推。&#xA;我们来看一个例子：&#xA;package main import &amp;#34;fmt&amp;#34; func testIf(score int) { if score &amp;gt;= 90 { fmt.Println(&amp;#34;优秀&amp;#34;) } else if score &amp;gt;= 75 { fmt.Println(&amp;#34;良好&amp;#34;) } else if score &amp;gt; 60 { fmt.Println(&amp;#34;及格&amp;#34;) } else { fmt.Println(&amp;#34;不及格&amp;#34;) } } func main() { testIf(90) } 运行结果为:</description>
    </item>
    <item>
      <title>Golang入门笔记-CH05-数组和切片</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch05-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch05-%E6%95%B0%E7%BB%84%E5%92%8C%E5%88%87%E7%89%87/</guid>
      <description>数组# 初始化# 数组可以保存指定长度的多个数据，且这些数据的类型都相同，数据类型可以是原始类型，如整型和字符串等，也可以是自定义类型。&#xA;数组通过索引来访问元素，索引从 0 开始，第一个元素的索引为 0，第二个为 1，依此类推。&#xA;在 Go 语言中声明数组的格式为：&#xA;var variable [len]type 例如，声明名称为arr1，长度和类型分别为5和 int 的数组：&#xA;var arr1 [5]int 我们可以让编译器根据元素个数自动推断数组长度，只需要在声明长度时用 ... 替代：&#xA;var numArray = [...]int{1, 2, 3} 我们还可以根据索引来声明数组：&#xA;a := [...]string{0: &amp;#34;北京&amp;#34;, 1: &amp;#34;上海&amp;#34;} // 索引 0 对应的元素为&amp;#34;北京&amp;#34;，1 对应的元素为&amp;#34;上海&amp;#34; 整型数组中所有元素都初始化为 0，数组 arr中第 i 个元素为arr[i - 1]，最后一个元素为 arr[len(arr) - 1]。&#xA;数组是可变的，可以通过索引对元素进行赋值：arr[1] = 1。&#xA;注意：在程序中若索引超出数组最大有效索引，会引发 index out of range 错误。&#xA;遍历数组# 普通 for 循环&#xA;package main import &amp;#34;fmt&amp;#34; func main() { a := [.</description>
    </item>
    <item>
      <title>Golang入门笔记-CH06-Map</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch06-map/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch06-map/</guid>
      <description>声明和初始化 Map# map 是一种特殊的数据结构，通过键 key 和值 value 来保存数据，可以快速地根据 key 找到其对应的 value，与 python 中的字典和 Java 中的 HashMap 类似。&#xA;map 是引用类型，声明方式如下：&#xA;var variable map[keyType]valueType 在声明的时候不需要知道 map 的长度，map 是可以动态增长的。&#xA;未初始化的 map 的值是 nil。&#xA;map 中的 key 只能是可以用 == 和 != 来比较的变量类型，例如 string，int 和 float 等，不能是数组，结构体和切片，但指针和接口可以作为 key。如果要使用结构体来作为 key，需要提供 Key() 和 Hash() 方法，value 可以为任意类型。&#xA;可以通过赋值符号来设置 key1 对应的 value：&#xA;map1[key1] = value 也可以根据赋值符号获取 key1 对应的 value，若 map1 中没有 key1 对应的值，val 将会被赋值 map1 的值类型的空值。&#xA;val := map1[key1] 示例：</description>
    </item>
    <item>
      <title>Golang入门笔记-CH07-结构体和方法</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch07-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%96%B9%E6%B3%95/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch07-%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%96%B9%E6%B3%95/</guid>
      <description>Go 语言通过 定义结构体来支持用户自定义类型。一个结构体代表现实世界中的一个实体，类似于 Java 中的实体类。当要定义一个类型时，这个类型包含很多属性，例如定义一个用户类型，用户类型中包含用户名、密码和生日等属性，就可以使用结构体。&#xA;组成结构体属性的数据成为字段，每个字段都有类型和名称；在结构体中，字段名称必须唯一。由于 Go 语言中不存在类的概念，所以结构体 struct 在 Go 语言中有着较高的地位。&#xA;结构体的定义# 格式# 结构体定义的格式如下：&#xA;type variable struct { field1 type1 field2 type2 } 若结构体中有多个同类型字段，可以简写，如：&#xA;type T struct { a, b int } 若结构体中的字段并不需要使用，可以用匿名变量 _ 来定义，如：&#xA;type M struct { _ int } 结构体中字段的类型可以是任意类型（包括结构体、函数和接口等）。&#xA;使用 new# 可以使用 new 函数给新结构体变量分配内存，它返回指向分配内存的指针，如：&#xA;var t *T = new(T) 当然，也可以将上述语句拆成两行：&#xA;var t *T t = new(T) 在函数内部，一般采用短变量形式，如：&#xA;t := new(T) 声明 var t T 也会给 t 分配内存，并零值化内存，但此时 t 是类型 T。在这两种方式中，t 通常被称作 T 的一个实例（instance）或者对象（Object）。</description>
    </item>
    <item>
      <title>Golang入门笔记-CH08-接口</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch08-%E6%8E%A5%E5%8F%A3/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch08-%E6%8E%A5%E5%8F%A3/</guid>
      <description>1. 使用接口的原因# 我们来看一段代码：&#xA;type Cat struct{} func (c Cat) Say() string { return &amp;#34;喵喵喵&amp;#34; } type Dog struct{} func (d Dog) Say() string { return &amp;#34;汪汪汪&amp;#34; } func main() { c := Cat{} fmt.Println(&amp;#34;猫:&amp;#34;, c.Say()) d := Dog{} fmt.Println(&amp;#34;狗:&amp;#34;, d.Say()) } 上述代码中定义了狗 Dog 和猫 Cat 以及它们对应的方法 Say()，若要继续添加鸭 Duck 方法和其对应的方法 Say()，重复代码会非常多。我们可不可以从这三种动物类型中抽象出方法 Say()，这就是接口的作用，接口可以定义抽象方法，来规范我们的代码。&#xA;2. 接口的定义和使用# Go 语言非传统面对对象语言，没有类和继承的概念。但在 Go 语言中可以通过接口来实现面对对象的一些特性，接口是用来描述对象行为的，可以在其中定义一些抽象方法，这些方法不能被实现，同时接口中不能包含变量。&#xA;Go 语言中接口 interface 是一种抽象类型。&#xA;接口的定义格式：&#xA;type Namer interface { Method1(params) returnType Method2(params) returnType } 一般接口以 [e]r 结尾，例如 Writer、Logger 等。若 er 结尾不合适时，可以采用 able 结尾，例如 Recoverable。</description>
    </item>
    <item>
      <title>Golang入门笔记-CH09-反射</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch09-%E5%8F%8D%E5%B0%84/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch09-%E5%8F%8D%E5%B0%84/</guid>
      <description>反射是用程序检查其所拥有的结构，尤其是类型的一种能力。反射可以在运行时（不必在编译时）检查类型和变量，例如大小、变量、方法和动态调用这些方法。&#xA;方法和类型的反射# reflect 包提供了反射功能，它定义两个重要类型：Type 和 Value，分别表示动态类型和值。&#xA;有两个常用的方法：&#xA;reflect.TypeOf：返回对象的具体类型。 reflect.ValueOf：返回对象的值。 反射是先检查一个接口的值，再将变量转换成空接口类型，我们看下这两个函数的定义就能明白了：&#xA;func TypeOf(i interface{}) Type func ValueOf(i interface{}) Value reflect.TypeOf# 函数 reflect.Typeof() 可以接收任意 interface{} 类型数据，并返回其动态类型。&#xA;package main import ( &amp;#34;fmt&amp;#34; &amp;#34;reflect&amp;#34; ) func main() { t := reflect.TypeOf(3) // a reflect.Type fmt.Println(t.String()) // &amp;#34;int&amp;#34; fmt.Println(t) // &amp;#34;int&amp;#34; } 由于 reflect.TypeOf 返回的是一个动态类型的接口值，因此它返回的总是具体类型。下面的代码打印将是 *os.File，而不是 io.Writer：&#xA;package main import ( &amp;#34;fmt&amp;#34; &amp;#34;io&amp;#34; &amp;#34;os&amp;#34; &amp;#34;reflect&amp;#34; ) func main() { var w io.Writer = os.Stdout fmt.Println(reflect.TypeOf(w)) // &amp;#34;*os.</description>
    </item>
    <item>
      <title>Golang入门笔记-CH10-函数高级特性</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch10-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch10-%E5%87%BD%E6%95%B0%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/</guid>
      <description>传递变长参数# 如果函数最后一个参数采用 ...type 的形式，那么这个函数就可以处理一个变长参数（长度可以为 0），这样的函数被称为变参函数，如：&#xA;func myFunc(a int, args ...int) 如果参数存储在切片 arr 中，可以用 arr... 来传递参数，如：&#xA;package main import &amp;#34;fmt&amp;#34; func main() { x := Min(1, 3, 2, 0) fmt.Printf(&amp;#34;The minimum is: %d\n&amp;#34;, x) arr := []int{7, 9, 3, 5, 1} x = Min(arr...) fmt.Printf(&amp;#34;The minimum in the arr is: %d&amp;#34;, x) } func Min(a ...int) int { if len(a) == 0 { return 0 } min := a[0] for _, v := range a { if v &amp;lt; min { min = v } } return min } 上述代码运行结果为：</description>
    </item>
    <item>
      <title>Golang入门笔记-CH11-错误处理</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch11-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch11-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/</guid>
      <description>Go 没有像 Java 那样的 try/catch 异常处理机制，而是用 defer/panic/recover 机制来处理异常。&#xA;Go 语言的设计者认为 try/catch 机制使用过于泛滥，而且从底层向高层抛出错误太耗费资源，因此他给 Go 语言设计了一种返回值处理错误方式：通过在函数和方法中返回错误对象，这个错误对象一般在多个返回值的最后；如果返回 nil，则表明没有错误，且主调函数应该检查并处理每一个错误。&#xA;我们通过调用 pack1 包中的 Func1 函数来了解 Go 语言中的错误处理方式：&#xA;Func1返回了两个值，一个 value和 err，err 是错误对象，若 err 不为 nil（nil 是空的意思，类似于 Java 中的 null），则进行错误处理，打印出具体错误信息。&#xA;if value, err := pack1.Func1(param1); err != nil { fmt.Printf(&amp;#34;Error %s in pack1.Func1 with parameter %v&amp;#34;, err.Error(), param1) return // or: return err } Go 有一个预先定义的 error 接口类型 ：&#xA;type error interface { Error() string } 错误处理# 定义错误# 可以通过 errors 包中 New() 函数传递错误信息，从而自定义错误，如下：</description>
    </item>
    <item>
      <title>Golang入门笔记-CH12-并发</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch12-%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Sat, 01 Oct 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/golang/golang%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0-ch12-%E5%B9%B6%E5%8F%91/</guid>
      <description>基本概念# 线程和进程# 进程 ：是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个 独立单位 。 线程 ：是进程的一个执行实体，是 CPU 调度和分派的 基本单位 ，它是比进程更小的能独立运行的 基本单位 。 一个进程可以创建或撤销多个线程；同一个进程中的多个线程之间可以并发执行。&#xA;线程和协程# 协程 ：独立栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。 线程 ：一个线程上可以跑多个协程，协程是轻量级的线程。 并发和并行# 并发 和 并行 虽然相似，但是有所不同：&#xA;并发 ：逻辑上具备同时处理多个任务的能力。 并行 ：物理上在同一时刻执行多个并发任务。 我们一般会说程序是并发的，意思是说它允许多个任务同时进行，但不一定在同一时刻发生。对于单核处理器，它们能以间隔方式切换运行；而并行则依赖多核心处理器，是让多个任务真正能在同一时刻运行，是一种程序运行的状态。&#xA;多线程和多进程是并行的基本条件，但单线程也可用协程（coroutine）做到并发。虽然单线程只能通过主动切换来实现并发，但也有优点，可以避免由于切换线程导致的资源消耗。协程上运行多个任务本质上是串行的，且可控，无需做同步处理。&#xA;采用多进程也不一定能并行，Python 由于 GIL 的限制，默认只能并发而不能并行，转而使用“ 多进程 + 协程 ”来实现并行。&#xA;多进程、多线程和协程各有利弊，一般用多进程来实现分布式和负载均衡，减轻单进程垃圾回收压力；用多线程抢夺更多的处理器资源；用协程来提高处理器时间片利用率。&#xA;goroutine# 在 Java 中要实现并发编程，需要自己维护一个线程池，处理线程调度和上下文切换，非常麻烦。Go 语言的 goroutine 很好地解决了这一问题，goroutine 类似于线程，但 goroutine 由 Go 的运行时（runtime）来调度和管理，Go 程序会智能地将 goroutine 中的任务合理分配给每个 CPU。&#xA;在 Go 语言中使用 goroutine 很简单，只要在调用函数前加一个 go 关键字即可。&#xA;一个 goroutine 必须对应一个函数，可以创建多个 goroutine 去执行相同函数。&#xA;启动单个 goroutine# 启动单个 Goroutine 只需在调用函数时加一个 go 关键字即可，例如：</description>
    </item>
    <item>
      <title>2022年我在使用这些vim插件</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/vim-plugs-2022/</link>
      <pubDate>Mon, 27 Jun 2022 15:07:39 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/vim-plugs-2022/</guid>
      <description>&lt;h3 id=&#39;前言&#39;&gt;前言&lt;a href=&#39;#%e5%89%8d%e8%a8%80&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;从第一次接触 &lt;code&gt;vim&lt;/code&gt; 已逾期 10 年, 期间大部分都是一些简单操作,&#xA;最近一两年开始深度使用 &lt;code&gt;vim&lt;/code&gt;, 目前使用 &lt;code&gt;neovim&lt;/code&gt; 版本.&#xA;本文将记录一些笔者觉得好用的一些 &lt;code&gt;Plugin&lt;/code&gt;, 本文也将持续更新.&lt;/p&gt;</description>
    </item>
    <item>
      <title>butterfly</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/butterfly/</link>
      <pubDate>Wed, 23 Feb 2022 17:56:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/butterfly/</guid>
      <description>&lt;h2 id=&#39;hexo-butterfly-魔改&#39;&gt;hexo butterfly 魔改&lt;a href=&#39;#hexo-butterfly-%e9%ad%94%e6%94%b9&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>docsify</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/docsify/</link>
      <pubDate>Wed, 23 Feb 2022 17:56:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/docsify/</guid>
      <description>&lt;p&gt;Docsify&lt;/p&gt;</description>
    </item>
    <item>
      <title>Emoji</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/emoji/</link>
      <pubDate>Wed, 23 Feb 2022 17:56:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/emoji/</guid>
      <description>&lt;p&gt;Emoji&lt;/p&gt;</description>
    </item>
    <item>
      <title>ExcelToPDF</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/python/exceltopdf/</link>
      <pubDate>Wed, 23 Feb 2022 17:56:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/python/exceltopdf/</guid>
      <description>&lt;h2 id=&#39;excel-to-pdf&#39;&gt;Excel To PDF&lt;a href=&#39;#excel-to-pdf&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h2&gt;</description>
    </item>
    <item>
      <title>审计工具</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 23 Feb 2022 17:56:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/%E5%AE%A1%E8%AE%A1%E5%B7%A5%E5%85%B7/</guid>
      <description>&lt;p&gt;审计工具&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用Git将文件夹上传到Github以及使用Git LFS上传大文件</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8A%E4%BC%A0%E5%88%B0github%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8git-lfs%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6/</link>
      <pubDate>Wed, 23 Feb 2022 17:56:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/%E4%BD%BF%E7%94%A8git%E5%B0%86%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8A%E4%BC%A0%E5%88%B0github%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8git-lfs%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%96%87%E4%BB%B6/</guid>
      <description>&lt;p&gt;GIT&lt;/p&gt;</description>
    </item>
    <item>
      <title>博客搭建工具</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E5%B7%A5%E5%85%B7/</guid>
      <description>&lt;p&gt;博客搭建工具&lt;/p&gt;</description>
    </item>
    <item>
      <title>博客部署</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/blog-deployment/</link>
      <pubDate>Sat, 01 Jan 2022 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/blog/blog-deployment/</guid>
      <description>我的网站# 主要采用静态搭建，如Hexo、Gridea、NotionNext、GitHub Pages、Obsidian、Sharepoint。 - **一、&amp;lt;https://richfan.site&amp;gt;** - 博客内容：待定 - 部署平台：Vercel - 部署程序：NotionNext - 部署主题：Heo - **二、&amp;lt;https://richffan.github.io&amp;gt;** - 博客内容：美食 - 部署平台：Github Pages - 部署程序：Gridea - 部署主题：Fog - **三、&amp;lt;https://fanrich.github.io&amp;gt;** - 博客内容：待定 - 部署平台：Github Pages - 部署程序：Obsidian - 部署主题：Obsidian - **四、&amp;lt;https://richfan.link&amp;gt;** - 博客内容：待定 - 部署平台：Github Pages - 部署程序：Obsidian - 部署主题：Obsidian - **五、&amp;lt;https://richfan.eu.org&amp;gt;** - 博客内容：审计 - 部署平台：Github Pages - 部署程序：Hexo - 部署主题：3-hexo - **六、&amp;lt;https://fanrich.eu.org&amp;gt;** - 博客内容：编程 - 部署平台：Github Pages - 部署程序：Hexo - 部署主题：3-hexo - **七、&amp;lt;https://richffan.sharepoint.com&amp;gt;** - 博客内容：待定 - 部署平台：Sharepoint - 部署程序：Sharepoint - 部署主题：Sharepoint 服务器# 名称 网址 Github Pages https://github.</description>
    </item>
    <item>
      <title>每天一个linux命令（25）: gzip</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-25-gzip/</link>
      <pubDate>Fri, 25 Dec 2020 00:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-25-gzip/</guid>
      <description>减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip是在Linux系统中经常使用的一个对文件进行压缩和解压缩的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。&#xA;命令格式# $ gzip [参数] [文件或者目录] 命令功能# gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出&amp;quot;.gz&amp;quot;的扩展名。&#xA;命令参数# 参数 描述 -a或&amp;ndash;ascii 使用ASCII文字模式。 -c或&amp;ndash;stdout或&amp;ndash;to-stdout 把压缩后的文件输出到标准输出设备，不去更动原始文件。 -d或&amp;ndash;decompress或&amp;mdash;-uncompress 解开压缩文件。 -f或&amp;ndash;force 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 -h或&amp;ndash;help 在线帮助。 -l或&amp;ndash;list 列出压缩文件的相关信息。 -L或&amp;ndash;license 显示版本与版权信息。 -n或&amp;ndash;no-name 压缩文件时，不保存原来的文件名称及时间戳记。 -N或&amp;ndash;name 压缩文件时，保存原来的文件名称及时间戳记。 -q或&amp;ndash;quiet 不显示警告信息 -r或&amp;ndash;recursive 递归处理，将指定目录下的所有文件及子目录一并处理。 -S&amp;lt;压缩字尾字符串&amp;gt;或&amp;mdash;-suffix&amp;lt;压缩字尾字符串&amp;gt; 更改压缩字尾字符串。 -t或&amp;ndash;test 测试压缩文件是否正确无误。 -v或&amp;ndash;verbose 显示指令执行过程。 -V或&amp;ndash;version 显示版本信息。 -num 用指定的数字num调整压缩的速度，-1或&amp;ndash;fast表示最快压缩方法（低压缩比），-9或&amp;ndash;best表示最慢压缩方法（高压缩比）。系统缺省值为6。 命令实例# 例一：把test目录下的每个文件压缩成.gz文件&#xA;## 忽略目录，只打包其中文件 $ gzip * 例二：把例1中每个压缩的文件解压，并列出详细的信息&#xA;$ gzip -dv * 例三：详细显示例1中每个压缩的文件的信息，并不解压&#xA;$ gzip -l * 例四：压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gz&#xA;$ gzip -r log.tar 例五：递归的压缩目录&#xA;$ gzip -rv test6 例六：递归地解压目录</description>
    </item>
    <item>
      <title>Docker 技术整理</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker-%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/</link>
      <pubDate>Tue, 01 Sep 2020 22:11:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker-%E6%8A%80%E6%9C%AF%E6%95%B4%E7%90%86/</guid>
      <description>&lt;h3 id=&#39;一概述&#39;&gt;一、概述&lt;a href=&#39;#%e4%b8%80%e6%a6%82%e8%bf%b0&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 id=&#39;11-什么是docker&#39;&gt;1.1 什么是docker&lt;a href=&#39;#11-%e4%bb%80%e4%b9%88%e6%98%afdocker&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;Docker 诞生于 2013 年初，由 dotCloud 公司（后改名为 Docker Inc）基于 Go 语言实现并开源的项目。此项目后来加入 Linux基金会，遵从了 Apache 2.0 协议&lt;/p&gt;</description>
    </item>
    <item>
      <title>Linux</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/system/linux/archlinux/</link>
      <pubDate>Wed, 01 Jan 2020 10:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/system/linux/archlinux/</guid>
      <description>安装# ARCHLINUX官网 ARCOLINUX官网 UBUNTU官网 DEBIAN官网 使用# 总结# </description>
    </item>
    <item>
      <title>windows重装</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/system/windows/windows%E9%87%8D%E8%A3%85/</link>
      <pubDate>Wed, 01 Jan 2020 10:00:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/system/windows/windows%E9%87%8D%E8%A3%85/</guid>
      <description>更新# 软件# 日常&#xA;WinRAR 7ZIP 微信 office 编程&#xA;vscode Dbeaver duckdb 设计&#xA;Photoshop Acrobat Illustrator 图压 审计&#xA;鼎信诺 悦审 云审 新纪元 魔法&#xA;clash for windows </description>
    </item>
    <item>
      <title>shell速查表</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/shell%E9%80%9F%E6%9F%A5%E8%A1%A8/</link>
      <pubDate>Sat, 08 Sep 2018 11:48:24 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/shell%E9%80%9F%E6%9F%A5%E8%A1%A8/</guid>
      <description>&lt;h3 id=&#39;1-变量&#39;&gt;1. 变量&lt;a href=&#39;#1-%e5%8f%98%e9%87%8f&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#!/bin/bash&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;&lt;/span&gt;msg&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello world&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;echo $msg&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
    </item>
    <item>
      <title>nginx配置记录</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/nginx%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</link>
      <pubDate>Thu, 08 Feb 2018 09:19:09 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/nginx%E9%85%8D%E7%BD%AE%E8%AE%B0%E5%BD%95/</guid>
      <description>&lt;h3 id=&#39;启用https&#39;&gt;启用https&lt;a href=&#39;#%e5%90%af%e7%94%a8https&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;</description>
    </item>
    <item>
      <title>linux下修改按键ESC&lt;=&gt;CAPSLOCK和Control=&gt;ALT_R</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux%E4%B8%8B%E4%BF%AE%E6%94%B9%E6%8C%89%E9%94%AEesc-capslock%E5%92%8Ccontrol-alt-r/</link>
      <pubDate>Fri, 20 Oct 2017 17:38:49 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux%E4%B8%8B%E4%BF%AE%E6%94%B9%E6%8C%89%E9%94%AEesc-capslock%E5%92%8Ccontrol-alt-r/</guid>
      <description>&lt;p&gt;使用 &lt;code&gt;vim&lt;/code&gt; 过程中发现 &lt;code&gt;esc&lt;/code&gt; 和 &lt;code&gt;ctrl&lt;/code&gt; 按键很难按，小拇指没有那么长啊～～，而 &lt;code&gt;caps_lock&lt;/code&gt; 和 &lt;code&gt;alt_r&lt;/code&gt;(右alt) 很少用。&lt;/p&gt;&#xA;&lt;p&gt;本教程将 &lt;code&gt;esc&lt;/code&gt; 和 &lt;code&gt;caps_lock&lt;/code&gt; 两个按键交换， &lt;code&gt;alt_r&lt;/code&gt;(右alt) 改为 &lt;code&gt;ctrl&lt;/code&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>[转]字符编解码的故事（ASCII，ANSI，Unicode，Utf-8区别）</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E8%BD%AC-%E5%AD%97%E7%AC%A6%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9A%84%E6%95%85%E4%BA%8Basciiansiunicodeutf-8%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Mon, 25 Sep 2017 19:15:00 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E8%BD%AC-%E5%AD%97%E7%AC%A6%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9A%84%E6%95%85%E4%BA%8Basciiansiunicodeutf-8%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;p&gt;很久很久以前，有一群人，他们决定用8个可以开合的晶体管来组合成不同的状态，以表示世界上的万物。他们认为8个开关状态作为原子单位很好，于是他们把这称为&amp;quot;字节&amp;quot;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>docker报错集锦</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker%E6%8A%A5%E9%94%99%E9%9B%86%E9%94%A6/</link>
      <pubDate>Mon, 25 Sep 2017 10:03:50 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker%E6%8A%A5%E9%94%99%E9%9B%86%E9%94%A6/</guid>
      <description>&lt;h3 id=&#39;docker创建容器&#39;&gt;docker创建容器&lt;a href=&#39;#docker%e5%88%9b%e5%bb%ba%e5%ae%b9%e5%99%a8&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;</description>
    </item>
    <item>
      <title>CentOS7使用Firewalld</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/centos7%E4%BD%BF%E7%94%A8firewalld/</link>
      <pubDate>Tue, 19 Sep 2017 09:53:53 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/centos7%E4%BD%BF%E7%94%A8firewalld/</guid>
      <description>&lt;h3 id=&#39;介绍&#39;&gt;介绍&lt;a href=&#39;#%e4%bb%8b%e7%bb%8d&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;FirewallD 提供了支持网络/防火墙区域(zone)定义网络链接以及接口安全等级的动态防火墙管理工具。它支持 IPv4, IPv6 防火墙设置以及以太网桥接，并且拥有运行时配置和永久配置选项。它也支持允许服务或者应用程序直接添加防火墙规则的接口。&lt;/p&gt;</description>
    </item>
    <item>
      <title>docker备份恢复之save与export</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker-save-%E4%B8%8E-docker-export/</link>
      <pubDate>Mon, 18 Sep 2017 22:38:52 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker-save-%E4%B8%8E-docker-export/</guid>
      <description>&lt;h3 id=&#39;docker-save&#39;&gt;docker save&lt;a href=&#39;#docker-save&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;</description>
    </item>
    <item>
      <title>sudo命令免密码设置</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/sudo%E5%91%BD%E4%BB%A4%E5%85%8D%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE/</link>
      <pubDate>Mon, 11 Sep 2017 09:30:55 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/sudo%E5%91%BD%E4%BB%A4%E5%85%8D%E5%AF%86%E7%A0%81%E8%AE%BE%E7%BD%AE/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;如果某台linux只有自己在使用，比如个人系统，每次调用 &lt;code&gt;sudo&lt;/code&gt; 时都需要输入密码，长期下来着实厌烦，因此本文介绍如何配置 &lt;code&gt;sudo&lt;/code&gt; 命令，使其在运行时不需要输入密码。&lt;/p&gt;&#xA;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>600 条最强 Linux 命令总结</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/600-%E6%9D%A1%E6%9C%80%E5%BC%BA-linux-%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</link>
      <pubDate>Wed, 06 Sep 2017 23:01:31 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/600-%E6%9D%A1%E6%9C%80%E5%BC%BA-linux-%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</guid>
      <description>&lt;p&gt;600条最强Linux命令&lt;/p&gt;</description>
    </item>
    <item>
      <title>搭建Maven私服-Nexus</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E6%90%AD%E5%BB%BAmaven%E7%A7%81%E6%9C%8D-nexus/</link>
      <pubDate>Wed, 06 Sep 2017 23:01:31 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E6%90%AD%E5%BB%BAmaven%E7%A7%81%E6%9C%8D-nexus/</guid>
      <description>&lt;blockquote&gt;&#xA;&lt;p&gt;Maven 私服，可以代理远程仓库和部署自己或第三方构件。本文介绍使用最广泛搭建 Maven 私服的工具： Sonatype Nexus。&lt;/p&gt;&#xA;&lt;/blockquote&gt;</description>
    </item>
    <item>
      <title>CentOS7安装配置匿名访问Samba</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/centos7-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8C%BF%E5%90%8D%E8%AE%BF%E9%97%AEsamba/</link>
      <pubDate>Mon, 03 Jul 2017 19:40:14 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/centos7-%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8C%BF%E5%90%8D%E8%AE%BF%E9%97%AEsamba/</guid>
      <description>&lt;h3 id=&#39;介绍&#39;&gt;介绍&lt;a href=&#39;#%e4%bb%8b%e7%bb%8d&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;Samba&lt;/strong&gt;，是种用来让UNIX系列的操作系统与微软Windows操作系统的SMB/CIFS（Server Message Block/Common Internet File System）网络协议做链接的自由软件   &amp;ndash;wikipedia&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&lt;p&gt;本文就以 CentOS7 搭建 Samba 匿名完全访问（读/写）为目标，实现一个局域网内的文件共享平台。&lt;/p&gt;</description>
    </item>
    <item>
      <title>解决粘贴到vim缩进错乱问题</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E8%A7%A3%E5%86%B3%E7%B2%98%E8%B4%B4%E5%88%B0vim%E7%BC%A9%E8%BF%9B%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98/</link>
      <pubDate>Thu, 01 Jun 2017 19:45:24 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E8%A7%A3%E5%86%B3%E7%B2%98%E8%B4%B4%E5%88%B0vim%E7%BC%A9%E8%BF%9B%E9%94%99%E4%B9%B1%E9%97%AE%E9%A2%98/</guid>
      <description>&lt;h3 id=&#39;遇见&#39;&gt;遇见&lt;a href=&#39;#%e9%81%87%e8%a7%81&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;当我使用vim，想要粘贴下面这段脚本到 xx.sh 文件中&lt;/p&gt;</description>
    </item>
    <item>
      <title>进入docker容器命令制作</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E8%BF%9B%E5%85%A5docker%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4%E5%88%B6%E4%BD%9C/</link>
      <pubDate>Thu, 01 Jun 2017 17:25:11 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E8%BF%9B%E5%85%A5docker%E5%AE%B9%E5%99%A8%E5%91%BD%E4%BB%A4%E5%88%B6%E4%BD%9C/</guid>
      <description>&lt;h3 id=&#39;通过attach进入容器&#39;&gt;通过attach进入容器&lt;a href=&#39;#%e9%80%9a%e8%bf%87attach%e8%bf%9b%e5%85%a5%e5%ae%b9%e5%99%a8&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;</description>
    </item>
    <item>
      <title>docker数据管理</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/</link>
      <pubDate>Tue, 23 May 2017 21:43:06 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h3 id=&#39;数据卷&#39;&gt;数据卷&lt;a href=&#39;#%e6%95%b0%e6%8d%ae%e5%8d%b7&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;数据卷是一个可供一个或多个容器使用的特殊目录，它绕过 UFS，可以提供很多有用的特性：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;数据卷可以在容器之间共享和重用&lt;/li&gt;&#xA;&lt;li&gt;对数据卷的修改会立马生效&lt;/li&gt;&#xA;&lt;li&gt;对数据卷的更新，不会影响镜像&lt;/li&gt;&#xA;&lt;li&gt;数据卷默认会一直存在，即使容器被删除&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>docker容器</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Tue, 23 May 2017 21:29:38 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker%E5%AE%B9%E5%99%A8/</guid>
      <description>&lt;h3 id=&#39;容器&#39;&gt;容器&lt;a href=&#39;#%e5%ae%b9%e5%99%a8&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。&lt;/p&gt;&#xA;&lt;p&gt;容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 命名空间。因此容器可以拥有自己的 root 文件系统、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。&lt;/p&gt;</description>
    </item>
    <item>
      <title>docker仓库</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker%E4%BB%93%E5%BA%93/</link>
      <pubDate>Tue, 23 May 2017 21:15:52 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker%E4%BB%93%E5%BA%93/</guid>
      <description>&lt;h3 id=&#39;docker-hub&#39;&gt;Docker Hub&lt;a href=&#39;#docker-hub&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;目前 Docker 官方维护了一个公共仓库 &lt;a&#xA;  href=&#34;https://hub.docker.com/&#34;&#xA;    class=&#34;is-pretty-link&#34;&gt;Docker Hub&lt;/a&#xA;&gt;&#xA;，其中已经包括了超过 15,000 的镜像。大部分需求，都可以通过在 Docker Hub 中直接下载镜像来实现。&lt;/p&gt;</description>
    </item>
    <item>
      <title>每天一个linux命令（58）: sort</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-58-sort/</link>
      <pubDate>Tue, 23 May 2017 11:44:12 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-58-sort/</guid>
      <description>&lt;p&gt;sort是在Linux里非常常用的一个命令，管排序的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>CentOS修改DNS/GW/IP</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/centos%E4%BF%AE%E6%94%B9dns-gw-ip/</link>
      <pubDate>Tue, 23 May 2017 09:53:52 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/centos%E4%BF%AE%E6%94%B9dns-gw-ip/</guid>
      <description>&lt;h3 id=&#39;1修改dns&#39;&gt;1.修改DNS&lt;a href=&#39;#1%e4%bf%ae%e6%94%b9dns&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;解决方案一：&lt;/strong&gt;&#xA;修改网卡的DNS的配置文件&lt;/p&gt;</description>
    </item>
    <item>
      <title>Dockerfile指令详解</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Mon, 22 May 2017 19:11:42 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/dockerfile%E6%8C%87%E4%BB%A4%E8%AF%A6%E8%A7%A3/</guid>
      <description>&lt;p&gt;&lt;code&gt;Dockerfile&lt;/code&gt; 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。&lt;/p&gt;</description>
    </item>
    <item>
      <title>docker镜像</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker%E9%95%9C%E5%83%8F/</link>
      <pubDate>Fri, 19 May 2017 16:47:33 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker%E9%95%9C%E5%83%8F/</guid>
      <description>&lt;h3 id=&#39;what&#39;&gt;What&lt;a href=&#39;#what&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;Docker 镜像是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。&lt;/p&gt;&#xA;&lt;p&gt;因为镜像包含操作系统完整的 root 文件系统，其体积往往是庞大的，因此在 Docker 设计时，就充分利用 Union FS 的技术，将其设计为分层存储的架构。所以严格来说，镜像并非是像一个 ISO 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。&lt;/p&gt;</description>
    </item>
    <item>
      <title>docker初体验</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker%E5%88%9D%E4%BD%93%E9%AA%8C/</link>
      <pubDate>Fri, 19 May 2017 16:32:23 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/docker%E5%88%9D%E4%BD%93%E9%AA%8C/</guid>
      <description>&lt;h3 id=&#39;安装&#39;&gt;安装&lt;a href=&#39;#%e5%ae%89%e8%a3%85&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;h4 id=&#39;笔者环境&#39;&gt;笔者环境&lt;a href=&#39;#%e7%ac%94%e8%80%85%e7%8e%af%e5%a2%83&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h4&gt;&lt;p&gt;操作系统：deepin 15.4 Desktop 64Bit&lt;/p&gt;</description>
    </item>
    <item>
      <title>linux无损调整分区大小</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux%E6%97%A0%E6%8D%9F%E8%B0%83%E6%95%B4%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/</link>
      <pubDate>Wed, 17 May 2017 22:00:42 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux%E6%97%A0%E6%8D%9F%E8%B0%83%E6%95%B4%E5%88%86%E5%8C%BA%E5%A4%A7%E5%B0%8F/</guid>
      <description>&lt;h3 id=&#39;summary&#39;&gt;summary&lt;a href=&#39;#summary&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;ul&gt;&#xA;&lt;li&gt;系统环境: Red Hat 4.8.5-11&lt;/li&gt;&#xA;&lt;li&gt;情况：&#xA;&lt;ol&gt;&#xA;&lt;li&gt;home：500G&lt;/li&gt;&#xA;&lt;li&gt;root：50G&lt;/li&gt;&#xA;&lt;li&gt;root分区不够用&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;思路：把home分区的空间划一部分到root分区&lt;/li&gt;&#xA;&lt;/ul&gt;</description>
    </item>
    <item>
      <title>解决linux下zip文件解压乱码</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E8%A7%A3%E5%86%B3linux%E4%B8%8Bzip%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E4%B9%B1%E7%A0%81/</link>
      <pubDate>Tue, 25 Apr 2017 09:10:40 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E8%A7%A3%E5%86%B3linux%E4%B8%8Bzip%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E4%B9%B1%E7%A0%81/</guid>
      <description>&lt;h3 id=&#39;原因&#39;&gt;原因&lt;a href=&#39;#%e5%8e%9f%e5%9b%a0&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;由于zip格式并没有指定编码格式，Windows下生成的zip文件中的编码是GBK/GB2312等，因此，导致这些zip文件在Linux下解压时出现乱码问题，因为Linux下的默认编码是UTF8。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Vim命令速查表</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/vim%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/</link>
      <pubDate>Mon, 06 Mar 2017 11:23:36 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/vim%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5%E8%A1%A8/</guid>
      <description>&lt;p&gt;去年上半年开始全面使用linux进行开发和娱乐了，现在已经回不去windows了。&lt;/p&gt;&#xA;&lt;p&gt;话归正传，在linux上一直使用vim，慢慢熟悉了它的命令，才终于领悟了什么是编辑器之神。&lt;/p&gt;</description>
    </item>
    <item>
      <title>如何在linux中搭建ftp服务</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E5%A6%82%E4%BD%95%E5%9C%A8linux%E4%B8%AD%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1/</link>
      <pubDate>Mon, 06 Mar 2017 08:47:48 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/%E5%A6%82%E4%BD%95%E5%9C%A8linux%E4%B8%AD%E6%90%AD%E5%BB%BAftp%E6%9C%8D%E5%8A%A1/</guid>
      <description>&lt;h3 id=&#39;什么是-ftp&#39;&gt;什么是 FTP&lt;a href=&#39;#%e4%bb%80%e4%b9%88%e6%98%af-ftp&#39; class=&#39;anchor&#39;&gt;#&lt;/a&gt;&#xA;&lt;/h3&gt;&lt;p&gt;&lt;code&gt;FTP&lt;/code&gt; 是文件传输协议File Transfer Protocol的缩写。顾名思义，FTP用于计算机之间通过网络进行文件传输。你可以通过FTP在计算机账户间进行文件传输，也可以在账户和桌面计算机之间传输文件，或者访问在线软件归档。但是，需要注意的是多数的FTP站点的使用率非常高，可能需要多次重连才能连接上。&lt;/p&gt;</description>
    </item>
    <item>
      <title>每天一个linux命令（57）: sftp</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-57-sftp/</link>
      <pubDate>Sun, 05 Mar 2017 16:29:38 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-57-sftp/</guid>
      <description>&lt;p&gt;sFTP（安全文件传输程序）是一种安全的交互式文件传输程序，其工作方式与 FTP（文件传输协议）类似。 然而，sFTP 比 FTP 更安全；它通过加密 SSH 传输处理所有操作。&lt;/p&gt;</description>
    </item>
    <item>
      <title>每天一个linux命令（56）: tailf</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-56-tailf/</link>
      <pubDate>Mon, 20 Feb 2017 15:11:06 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-56-tailf/</guid>
      <description>　tailf 一个实时监听文件或日志的强大的命令&#xA;命令格式# $ tailf [option] file 命令描述# tailf 将会打印出一个文件的最后10行,等待并持续输出此文件的增长，它和tail -f相似，不同之处是当文件没有增长时，是不访问此文件的；但这会有一个副作用：不会更新文件的访问时间。当没有发生日志活动时，文件系统的冲洗（flush）不会定期发生。 tailf 对于打印日志不频繁，而又在使用笔记本电脑时是非常有用的，这样用户就能降低磁盘转速从而增加笔记本续航。&#xA;命令参数# 参数 描述 -n,&amp;ndash;lines=N,-N 输出最后N行,而不是默认的最后10行 命令实例# 例一：展示一个文件的最后5行并监听文件的新行（新增加的内容）&#xA;$ tailf -n 5 myfile.txt $ tailf -5 myfile.txt $ tailf --lines=5 myfile.txt 注：这是一个实时监听文件或日志的强大的命令&#xA;例二：实时新增日志内容，并通过管道过滤出自己想要的内容&#xA;## 实时监听ip地址为24.10.160.10的访问日志 $ tailf access.log | grep 24.10.160.10 </description>
    </item>
    <item>
      <title>每天一个linux命令（55）: crontab</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-55-crontab/</link>
      <pubDate>Mon, 23 Jan 2017 10:44:50 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-55-crontab/</guid>
      <description>前一天学习了 at 命令是针对仅运行一次的任务，循环运行的例行性计划任务，linux系统则是由 cron (crond) 这个系统服务来控制的。Linux 系统上面原本就有非常多的计划性工作，因此这个系统服务是默认启动的。另外, 由于使用者自己也可以设置计划任务，所以， Linux 系统也提供了使用者控制计划任务的命令 :crontab 命令。&#xA;crond简介# crond是linux下用来周期性的执行某种任务或等待处理某些事件的一个守护进程，与windows下的计划任务类似，当安装完成操作系统后，默认会安装此服务工具，并且会自动启动crond进程，crond进程每分钟会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。&#xA;Linux下的任务调度分为两类，系统任务调度和用户任务调度。&#xA;系统任务调度：系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。&#xA;/etc/crontab文件包括下面几行：&#xA;## /etc/crontab: system-wide crontab ## Unlike any other crontab you don&amp;#39;t have to run the `crontab&amp;#39; ## command to install the new version when you edit this file ## and files in /etc/cron.d. These files also have username fields, ## that none of the other crontabs do. SHELL=/bin/sh PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin ## m h dom mon dow user&#x9;command 17 *&#x9;* * *&#x9;root cd / &amp;amp;&amp;amp; run-parts --report /etc/cron.</description>
    </item>
    <item>
      <title>每天一个linux命令（54）: at</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-54-at/</link>
      <pubDate>Sun, 22 Jan 2017 10:23:44 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-54-at/</guid>
      <description>在windows系统中，windows提供了计划任务这一功能，在控制面板 -&amp;gt; 性能与维护 -&amp;gt; 任务计划， 它的功能就是安排自动运行的任务。 通过&amp;rsquo;添加任务计划&amp;rsquo;的一步步引导，则可建立一个定时执行的任务。&#xA;在linux系统中你可能已经发现了为什么系统常常会自动的进行一些任务？这些任务到底是谁在支配他们工作的？在linux系统如果你想要让自己设计的备份程序可以自动在某个时间点开始在系统底下运行，而不需要手动来启动它，又该如何处置呢？ 这些例行的工作可能又分为一次性定时工作与循环定时工作，在系统内又是哪些服务在负责？ 还有，如果你想要每年在老婆的生日前一天就发出一封信件提醒自己不要忘记，linux系统下该怎么做呢？&#xA;今天我们主要学习一下一次性定时计划任务的at命令的用法！&#xA;命令格式# $ at [参数] [时间] 命令功能# 在一个指定的时间执行一个指定任务，只能执行一次，且需要开启atd进程（ps -ef | grep atd查看， 开启用/etc/init.d/atd start or restart； 开机即启动则需要运行 chkconfig &amp;ndash;level 2345 atd on）。&#xA;命令参数# 参数 描述 -m 当指定的任务被完成之后，将给用户发送邮件，即使没有标准输出 -I atq的别名 -d atrm的别名 -v 显示任务将被执行的时间 -c 打印任务的内容到标准输出 -V 显示版本信息 -q&amp;lt;列队&amp;gt; 使用指定的列队 -f&amp;lt;文件&amp;gt; 从指定文件读入任务而不是从标准输入读入 -t&amp;lt;时间参数&amp;gt; 以时间参数的形式提交要运行的任务at允许使用一套相当复杂的指定时间的方法。他能够接受在当天的hh:mm（小时:分钟）式的时间指定。假如该时间已过去，那么就放在第二天执行。当然也能够使用midnight（深夜），noon（中午），teatime（饮茶时间，一般是下午4点）等比较模糊的 词语来指定时间。用户还能够采用12小时计时制，即在时间后面加上AM（上午）或PM（下午）来说明是上午还是下午。 也能够指定命令执行的具体日期，指定格式为month day（月 日）或mm/dd/yy（月/日/年）或dd.mm.yy（日.月.年）。指定的日期必须跟在指定时间的后面。 上面介绍的都是绝对计时法，其实还能够使用相对计时法，这对于安排不久就要执行的命令是很有好处的。指定格式为：now + count time-units ，now就是当前时间，time-units是时间单位，这里能够是minutes（分钟）、hours（小时）、days（天）、weeks（星期）。count是时间的数量，究竟是几天，还是几小时，等等。 更有一种计时方法就是直接使用today（今天）、tomorrow（明天）来指定完成命令的时间。 TIME 时间格式，这里可以定义出什么时候要进行 at 这项任务的时间 TIME的格式： HH:MM ex&amp;gt; 04:00 在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此任务。 HH:MM YYYY-MM-DD ex&amp;gt; 04:00 2009-03-17 强制规定在某年某月的某一天的特殊时刻进行该项任务</description>
    </item>
    <item>
      <title>每天一个linux命令（53）: watch</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-53-watch/</link>
      <pubDate>Sat, 21 Jan 2017 10:12:30 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-53-watch/</guid>
      <description>watch是一个非常实用的命令，基本所有的Linux发行版都带有这个小工具，如同名字一样，watch可以帮你监测一个命令的运行结果，省得你一遍遍的手动运行。在Linux下，watch是周期性的执行下个程序，并全屏显示执行结果。你可以拿他来监测你想要的一切命令的结果变化，比如 tail 一个 log 文件，ls 监测某个文件的大小变化，看你的想象力了！&#xA;命令格式# $ watch[参数][命令] 命令功能# 可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令&#xA;命令参数# 参数 描述 -n或&amp;ndash;interval watch缺省每2秒运行一下程序，可以用-n或-interval来指定间隔的时间 -d或&amp;ndash;differences watch 会高亮显示变化的区域 -d=cumulative 会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来 -t 或-no-title 会关闭watch命令在顶部的时间间隔,命令，当前时间的输出 -h, &amp;ndash;help 查看帮助文档 使用实例# 例一：每隔一秒高亮显示网络链接数的变化情况&#xA;$ watch -n 1 -d netstat -ant 说明： 其它操作： 切换终端： Ctrl+x 退出watch：Ctrl+g (deepin系统没效果，只能使用Ctrl+c退出了)&#xA;例二：每隔一秒高亮显示http链接数的变化情况&#xA;## 每隔一秒高亮显示http链接数的变化情况。 后面接的命令若带有管道符，需要加&amp;#39;&amp;#39;将命令区域归整。 $ watch -n 1 -d &amp;#39;pstree|grep http&amp;#39; 例三：实时查看模拟攻击客户机建立起来的连接数&#xA;$ watch &amp;#39;netstat -an | grep:21 | \ grep&amp;lt;模拟攻击客户机的IP&amp;gt;| wc -l&amp;#39; 例四：监测当前目录中 scf&amp;rsquo; 的文件的变化&#xA;$ watch -d &amp;#39;ls -l|grep scf&amp;#39; 例五：10秒一次输出系统的平均负载</description>
    </item>
    <item>
      <title>每天一个linux命令（52）: ps</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-52-ps/</link>
      <pubDate>Fri, 20 Jan 2017 09:46:16 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-52-ps/</guid>
      <description>Linux中的ps命令是Process Status的缩写。ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。&#xA;要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而 ps 命令就是最基本同时也是非常强大的进程查看命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。&#xA;ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。&#xA;kill 命令用于杀死进程。 linux上进程有5种状态:&#xA;运行(正在运行或在运行队列中等待) 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) ps工具标识进程的5种状态码: D 不可中断 uninterruptible sleep (usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (”zombie”) process&#xA;命令格式# $ ps [参数] 命令功能# 用来现实当前进程的状态&#xA;命令参数# 参数 描述 a 显示所有进程 -a 显示同一终端下的所有程序 -A 显示所有进程 c 显示进程的真实名称 -N 反向选择 -e 等于“-A” e 显示环境变量 f 显示程序间的关系 -H 显示树状结构 r 显示当前终端的进程 T 显示当前终端的所有程序 u 指定用户的所有进程 -au 显示较详细的资讯 -aux 显示所有包含其他使用者的行程 -C&amp;lt;命令&amp;gt; 列出指定命令的状况 &amp;ndash;lines&amp;lt;行数&amp;gt; 每页显示的行数 &amp;ndash;width&amp;lt;字符数&amp;gt; 每页显示的字符数 &amp;ndash;help 显示帮助信息 &amp;ndash;version 显示版本显示 使用实例# 例一：显示所有进程信息</description>
    </item>
    <item>
      <title>每天一个linux命令（51）: wc</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-51-wc/</link>
      <pubDate>Thu, 19 Jan 2017 09:33:59 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-51-wc/</guid>
      <description>　Linux系统中的wc(Word Count)命令的功能为统计指定文件中的字节数、字数、行数，并将统计结果显示输出。&#xA;命令格式# $ wc [选项]文件... 命令功能# 统计指定文件中的字节数、字数、行数，并将统计结果显示输出。该命令统计指定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数。&#xA;命令参数# 参数 描述 -c 统计字节数 -l 统计行数 -m 统计字符数。这个标志不能与 -c 标志一起使用 -w 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串 -L 打印最长行的长度 -help 显示帮助信息 &amp;ndash;version 显示版本信息 使用实例# 例一：查看文件的字节数、字数、行数&#xA;$ wc 1.txt 5 19 105 1.txt 行数 单词数 字节数 文件名 例二：用wc命令怎么做到只打印统计数字不打印文件名&#xA;$ wc -l 1.txt 5 1.txt ## 5行 $ cat 1.txt | wc -l 5 ## 值输出数字 例三：用来统计当前目录下的文件和文件夹总数&#xA;## 数量中包含当前目录 $ ls -l | wc -l 10 ## 7个文件 + 2个文件夹 + 1个当前目录 </description>
    </item>
    <item>
      <title>每天一个linux命令（50）: grep</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-50-grep/</link>
      <pubDate>Wed, 18 Jan 2017 10:12:46 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-50-grep/</guid>
      <description>Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。&#xA;grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。&#xA;grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。&#xA;命令格式# $ grep [option] pattern file 命令功能# 用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。&#xA;命令参数# 参数 描述 -a &amp;ndash;text 不要忽略二进制的数据 -A&amp;lt;显示行数&amp;gt; &amp;ndash;after-context=&amp;lt;显示行数&amp;gt; 除了显示符合范本样式的那一列之外，并显示该行之后的内容 -b &amp;ndash;byte-offset 在显示符合样式的那一行之前，标示出该行第一个字符的编号 -B&amp;lt;显示行数&amp;gt; &amp;ndash;before-context=&amp;lt;显示行数&amp;gt; 除了显示符合样式的那一行之外，并显示该行之前的内容 -c &amp;ndash;count 计算符合样式的列数 -C&amp;lt;显示行数&amp;gt; &amp;ndash;context=&amp;lt;显示行数&amp;gt;或-&amp;lt;显示行数&amp;gt; 显示上下文n行 -d &amp;lt;动作&amp;gt; &amp;ndash;directories=&amp;lt;动作&amp;gt; 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作 -e&amp;lt;范本样式&amp;gt; &amp;ndash;regexp=&amp;lt;范本样式&amp;gt; 指定字符串做为查找文件内容的样式 -E &amp;ndash;extended-regexp 将样式为延伸的普通表示法来使用 -f&amp;lt;规则文件&amp;gt; &amp;ndash;file=&amp;lt;规则文件&amp;gt; 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式 -F &amp;ndash;fixed-regexp 将样式视为固定字符串的列表 -G &amp;ndash;basic-regexp 样式视为普通的表示法来使用 -h &amp;ndash;no-filename 在显示符合样式的那一行之前，不标示该行所属的文件名称 -H &amp;ndash;with-filename 在显示符合样式的那一行之前，表示该行所属的文件名称 -i &amp;ndash;ignore-case 忽略字符的大小写 -l &amp;ndash;file-with-matches 只列出匹配的文件名 -L &amp;ndash;files-without-match 列出不匹配的文件名 -n &amp;ndash;line-number 显示行号 -q &amp;ndash;quiet或&amp;ndash;silent 不显示任何信息 -r &amp;ndash;recursive 递归查询， 此参数的效果和指定“-d recurse”参数相同 -s &amp;ndash;no-messages 不显示错误信息 -v &amp;ndash;revert-match 显示不包含匹配文本的所有行 -V &amp;ndash;version 显示版本信息 -w &amp;ndash;word-regexp 只显示全字符合的列 -x &amp;ndash;line-regexp 只显示全列符合的列 -y 此参数的效果和指定“-i”参数相同 规则表达式# grep的规则表达式 ^ #锚定行的开始 如：&#39;^grep&#39;匹配所有以grep开头的行。 $ #锚定行的结束 如：&#39;grep$&#39;匹配所有以grep结尾的行。 .</description>
    </item>
    <item>
      <title>每天一个linux命令（49）: cal</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-49-cal/</link>
      <pubDate>Tue, 17 Jan 2017 09:38:32 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-49-cal/</guid>
      <description>　cal命令可以用来显示公历（阳历）日历。公历是现在国际通用的历法，又称格列历，通称阳历。“阳历”又名“太阳历”，系以地球绕行太阳一周为一年，为西方各国所通用，故又名“西历”。&#xA;命令格式# $ cal [参数][月份][年份] 命令功能# 用于查看日历等时间信息，如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份&#xA;命令参数# 参数 描述 -1 显示一个月的月历 -3 显示系统前一个月，当前月，下一个月的月历 -s 显示星期天为一个星期的第一天，默认的格式 -m 显示星期一为一个星期的第一天 -j 显示在当年中的第几天（一年日期按天算，从1月1号算起，默认显示当前月在一年中的天数） -y 显示当前年份的日历 使用实例# 例一：显示当前月份日历&#xA;$ cal 例二：显示指定月份的日历&#xA;$ cal 6 2016 例三：显示2016年的日历&#xA;$ cal -y 2016 $ cal 2016 例四：显示自1月1日的天数&#xA;$ cal -j 例五：星期一显示在第一列&#xA;$ cal -m </description>
    </item>
    <item>
      <title>每天一个linux命令（48）: date</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-48-date/</link>
      <pubDate>Mon, 16 Jan 2017 14:39:27 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-48-date/</guid>
      <description>在linux环境中，不管是编程还是其他维护，时间是必不可少的，也经常会用到时间的运算，熟练运用date命令来表示自己想要表示的时间，肯定可以给自己的工作带来诸多方便。&#xA;命令格式# $ date [参数]... [+格式] 命令功能# date 可以用来显示或设定系统的日期与时间。&#xA;命令参数# 命令参数&#xA;参数 描述 %H 小时(以00-23来表示) %I 小时(以01-12来表示) %K 小时(以0-23来表示) %l 小时(以0-12来表示) %M 分钟(以00-59来表示) %P AM或PM %r 时间(含时分秒，小时以12小时AM/PM来表示) %s 总秒数。起算时间为1970-01-01 00:00:00 UTC %S 秒(以本地的惯用法来表示) %T 时间(含时分秒，小时以24小时制来表示) %X 时间(以本地的惯用法来表示) %Z 市区 %a 星期的缩写 %A 星期的完整名称 %b 月份英文名的缩写 %B 月份的完整英文名称 %c 日期与时间。只输入date指令也会显示同样的结果 %d 日期(以01-31来表示) %D 日期(含年月日) %j 该年中的第几天 %m 月份(以01-12来表示) %U 该年中的周数 %w 该周的天数，0代表周日，1代表周一，异词类推 %x 日期(以本地的惯用法来表示) %y 年份(以00-99来表示) %Y 年份(以四位数来表示) %n 在显示时，插入新的一行 %t 在显示时，插入tab MM 月份(必要) DD 日期(必要) hh 小时(必要) mm 分钟(必要) ss 秒(选择性) 选择参数</description>
    </item>
    <item>
      <title>每天一个linux命令（47）: diff</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-47-diff/</link>
      <pubDate>Sun, 15 Jan 2017 14:08:08 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-47-diff/</guid>
      <description>diff 命令是 linux上非常重要的工具，用于比较文件的内容，特别是比较两个版本不同的文件以找到改动的地方。diff在命令行中打印每一个行的改动。最新版本的diff还支持二进制文件。diff程序的输出被称为补丁 (patch)，因为Linux系统中还有一个patch程序，可以根据diff的输出将a.c的文件内容更新为b.c。diff是svn、cvs、git等版本控制工具不可或缺的一部分。&#xA;命令格式# $ diff [参数] [文件1或目录1] [文件2或目录2] 命令功能# diff命令能比较单个文件或者目录内容。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff 命令会比较两个目录下名字相同的文本文件。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。&#xA;命令参数# 参数 描述 - 指定要显示多少行的文本。此参数必须与-c或-u参数一并使用 -a或&amp;ndash;text diff预设只会逐行比较文本文件 -b或&amp;ndash;ignore-space-change 不检查空格字符的不同 -B或&amp;ndash;ignore-blank-lines 不检查空白行 -c 显示全部内文，并标出不同之处 -C或&amp;ndash;context 与执行&amp;quot;-c&amp;quot;指令相同 -d或&amp;ndash;minimal 使用不同的演算法，以较小的单位来做比较 -D或ifdef 此参数的输出格式可用于前置处理器巨集 -e或&amp;ndash;ed 此参数的输出格式可用于ed的script文件 -f或-forward-ed 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处 -H或&amp;ndash;speed-large-files 比较大文件时，可加快速度 -l或&amp;ndash;ignore-matching-lines 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异 -i或&amp;ndash;ignore-case 不检查大小写的不同 -l或&amp;ndash;paginate 将结果交由pr程序来分页 -n或&amp;ndash;rcs 将比较结果以RCS的格式来显示 -N或&amp;ndash;new-file 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较 -p 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称 -P或&amp;ndash;unidirectional-new-file 与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较 -q或&amp;ndash;brief 仅显示有无差异，不显示详细的信息 -r或&amp;ndash;recursive 比较子目录中的文件 -s或&amp;ndash;report-identical-files 若没有发现任何差异，仍然显示信息 -S或&amp;ndash;starting-file 在比较目录时，从指定的文件开始比较 -t或&amp;ndash;expand-tabs 在输出时，将tab字符展开 -T或&amp;ndash;initial-tab 在每行前面加上tab字符以便对齐 -u,-U或&amp;ndash;unified= 以合并的方式来显示文件内容的不同 -v或&amp;ndash;version 显示版本信息 -w或&amp;ndash;ignore-all-space 忽略全部的空格字符 -W或&amp;ndash;width 在使用-y参数时，指定栏宽 -x或&amp;ndash;exclude 不比较选项中所指定的文件或目录 -X或&amp;ndash;exclude-from 您可以将文件或目录类型存成文本文件，然后在=中指定此文本文件 -y或&amp;ndash;side-by-side 以并列的方式显示文件的异同之处 &amp;ndash;left-column 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容 &amp;ndash;suppress-common-lines 在使用-y参数时，仅显示不同之处 &amp;ndash;help 显示帮助 使用实例# 例一：比较两个文件</description>
    </item>
    <item>
      <title>每天一个linux命令（46）: ln</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-46-ln/</link>
      <pubDate>Sat, 14 Jan 2017 11:00:33 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-46-ln/</guid>
      <description>ln是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。&#xA;命令格式# $ ln [参数][源文件或目录][目标文件或目录] 命令功能# Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。 软连接 1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 2.软链接可以 跨文件系统 ，硬链接不可以 3.软链接可以对一个不存在的文件名进行链接 4.软链接可以对目录进行链接 硬链接 1.硬链接，以文件副本的形式存在。但不占用实际空间。 2.不允许给目录创建硬链接 3.硬链接只有在同一个文件系统中才能创建 两点注意 第一，ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化； 第二，ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。&#xA;命令参数# 必要参数&#xA;参数 描述 -b 删除，覆盖以前建立的链接 -d 允许超级用户制作目录的硬链接 -f 强制执行 -i 交互模式，文件存在则提示用户是否覆盖 -n 把符号链接视为一般目录 -s 软链接(符号链接) -v 显示详细的处理过程 选择参数&#xA;参数 描述 -S “-S&amp;lt;字尾备份字符串&amp;gt; ”或 “&amp;ndash;suffix=&amp;lt;字尾备份字符串&amp;gt;” -V “-V&amp;lt;备份方式&amp;gt;”或“&amp;ndash;version-control=&amp;lt;备份方式&amp;gt;” &amp;ndash;help 显示帮助信息 &amp;ndash;version 显示版本信息 使用实例# 例一：给文件创建软链接&#xA;## 为2.txt文件创建软链接2，如果2.txt丢失，2将失效 $ ln -s 2.</description>
    </item>
    <item>
      <title>每天一个linux命令（45）: scp</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-45-scp/</link>
      <pubDate>Fri, 13 Jan 2017 10:53:48 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-45-scp/</guid>
      <description>scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然 rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。&#xA;命令格式# $ scp [参数] [原路径] [目标路径] 命令功能# scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。&#xA;命令参数# 参数 描述 -1 强制scp命令使用协议ssh1 -2 强制scp命令使用协议ssh2 -4 强制scp命令只使用IPv4寻址 -6 强制scp命令只使用IPv6寻址 -B 使用批处理模式（传输过程中不询问传输口令或短语） -C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能） -p 保留原文件的修改时间，访问时间和访问权限 -q 不显示传输进度条 -r 递归复制整个目录 -v 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题 -c cipher 以cipher将数据传输进行加密，这个选项将直接传递给ssh -F ssh_config 指定一个替代的ssh配置文件，此参数直接传递给ssh -i identity_file 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh -l limit 限定用户所能使用的带宽，以Kbit/s为单位 -o ssh_option 如果习惯于使用ssh_config(5)中的参数传递方式 -P port 注意是大写的P, port是指定数据传输用到的端口号 -S program 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项 使用实例# 从本地服务器复制到远程服务器：&#xA;## 指定了用户名，命令执行后需输入密码 $ scp -r img/* root@server:/var/project/img/ ## 没有指定用户名，命令执行后需要输入用户名密码 $ scp -r img/* server:/var/project/img/ 从远程服务器复制到本地当前目录：</description>
    </item>
    <item>
      <title>每天一个linux命令（44）: rcp</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-44-rcp/</link>
      <pubDate>Thu, 12 Jan 2017 10:36:06 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-44-rcp/</guid>
      <description>rcp代表“remote file copy”（远程文件拷贝）。该命令用于在计算机之间拷贝文件。rcp命令有两种格式。第一种格式用于文件到文件的拷贝；第二种格式用于把文件或目录拷贝到另一个目录中。&#xA;命令格式# $ rcp [参数] [源文件] [目标文件] 命令功能# rcp命令用在远端复制文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则它会把前面指定的所有文件或目录复制到该目录中。&#xA;命令参数# 命令 描述 -r 递归地把源目录中的所有内容拷贝到目的目录中。要使用这个选项，目的必须是一个目录 -p 试图保留源文件的修改时间和模式，忽略umask -k 请求rcp获得在指定区域内的远程主机的Kerberos 许可，而不是获得由krb_relmofhost⑶确定的远程主机区域内的远程主机的Kerberos许可。 -x 为传送的所有数据打开DES加密。这会影响响应时间和CPU利用率，但是可以提高安全性。如果在文件名中指定的路径不是完整的路径名，那么这个路径被解释为相对远程机上同名用户的主目录。如果没有给出远程用户名，就使用当前用户名。如果远程机上的路径包含特殊shell字符，需要用反斜线（\）、双引号（”）或单引号（’）括起来，使所有的shell元字符都能被远程地解释。需要说明的是，rcp不提示输入口令，它通过rsh命令来执行拷贝。 directory 每个文件或目录参数既可以是远程文件名也可以是本地文件名。远程文件名具有如下形式：rname@rhost：path，其中rname是远程用户名，rhost是远程计算机名，path是这个文件的路径。 使用实例# 使用rcp，需要具备的条件 如果系统中有 /etc/hosts 文件，系统管理员应确保该文件包含要与之进行通信的远程主机的项。 /etc/hosts 文件中有一行文字，其中包含每个远程系统的以下信息： internet_address official_name alias 例如： 9.186.10.*** webserver1.com.58.webserver .rhosts 文件 .rhosts 文件位于远程系统的主目录下，其中包含本地系统的名称和本地登录名。 例如，远程系统的 .rhosts 文件中的项可能是： webserver1 root 其中，webserver1 是本地系统的名称，root 是本地登录名。这样，webserver1 上的 root 即可在包含.rhosts 文件的远程系统中来回复制文件。 配置过程: 只对root用户生效&#xA;在双方root用户根目录下建立.rhosts文件,并将双方的hostname加进去.在此之前应在双方的 /etc/hosts文件中加入对方的IP和hostname&#xA;把rsh服务启动起来,redhat默认是不启动的。 方法：用执行ntsysv命令,在rsh选项前用空格键选中,确定退出。然后执行： service xinetd restart即可。&#xA;3.到/etc/pam.d/目录下,把rsh文件中的auth required /lib/security/pam_securetty.so 一行用“#”注释掉即可。（只有注释掉这一行，才能用root用户登录）&#xA;例一：将本地img文件夹内的所有内容 复制到服务器相应的img目录下</description>
    </item>
    <item>
      <title>每天一个linux命令（43）: telnet</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-43-telnet/</link>
      <pubDate>Thu, 12 Jan 2017 09:24:01 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-43-telnet/</guid>
      <description>telnet命令通常用来远程登录。telnet程序是基于TELNET协议的远程登录客户端程序。Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的 能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个 telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。&#xA;但是，telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。&#xA;telnet命令还可做别的用途，比如确定远程服务的状态，比如确定远程服务器的某个端口是否能访问。&#xA;命令格式# $ telnet [参数][主机] 命令功能# 执行telnet指令开启终端机阶段作业，并登入远端主机。&#xA;命令参数# 命令 描述 -8 允许使用8位字符资料，包括输入与输出 -a 尝试自动登入远端系统 -b&amp;lt;主机别名&amp;gt; 使用别名指定远端主机名称 -c 不读取用户专属目录里的.telnetrc文件 -d 启动排错模式 -e&amp;lt;脱离字符&amp;gt; 设置脱离字符 -E 滤除脱离字符 -f 此参数的效果和指定&amp;quot;-F&amp;quot;参数相同 -F 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机 -k&amp;lt;域名&amp;gt; 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名 -K 不自动登入远端主机 -l&amp;lt;用户名称&amp;gt; 指定要登入远端主机的用户名称 -L 允许输出8位字符资料 -n&amp;lt;记录文件&amp;gt; 指定文件记录相关信息 -r 使用类似rlogin指令的用户界面 -S&amp;lt;服务类型&amp;gt; 设置telnet连线所需的IP TOS信息 -x 假设主机有支持数据加密的功能，就使用它 -X&amp;lt;认证形态&amp;gt; 关闭指定的认证形态 使用实例# 例一：远程服务器无法访问&#xA;$ telnet 192.168.120.206 Trying 192.168.120.209... telnet: connect to address 192.168.120.209: No route to host telnet: Unable to connect to remote host: No route to host 说明： 处理这种情况方法： （1）确认ip地址是否正确？ （2）确认ip地址对应的主机是否已经开机？ （3）如果主机已经启动，确认路由设置是否设置正确？（使用route命令查看） （4）如果主机已经启动，确认主机上是否开启了telnet服务？（使用netstat命令查看，TCP的23端口是否有LISTEN状态的行） （5）如果主机已经启动telnet服务，确认防火墙是否放开了23端口的访问？（使用iptables-save查看）</description>
    </item>
    <item>
      <title>每天一个linux命令（42）: ss</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-42-ss/</link>
      <pubDate>Wed, 11 Jan 2017 10:34:47 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-42-ss/</guid>
      <description>ss是Socket Statistics的缩写。顾名思义，ss命令可以用来获取socket统计信息，它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。&#xA;当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接cat /proc/net/tcp，执行速度都会很慢。可能你不会有切身的感受，但请相信我，当服务器维持的连接达到上万个的时候，使用netstat等于浪费 生命，而用ss才是节省时间。&#xA;天下武功唯快不破。ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢。（但仍然比 netstat要快。）&#xA;命令格式# $ ss [参数] $ ss[参数] [过滤] 命令功能# ss(Socket Statistics的缩写)命令可以用来获取 socket统计信息，此命令输出的结果类似于 netstat输出的内容，但它能显示更多更详细的 TCP连接状态的信息，且比 netstat 更快速高效。它使用了 TCP协议栈中 tcp_diag（是一个用于分析统计的模块），能直接从获得第一手内核信息，这就使得 ss命令快捷高效。在没有 tcp_diag，ss也可以正常运行。&#xA;命令参数# 命令 描述 -h, &amp;ndash;help 帮助信息 -V, &amp;ndash;version 程序版本信息 -n, &amp;ndash;numeric 不解析服务名称 -r, &amp;ndash;resolve 解析主机名 -a, &amp;ndash;all 显示所有套接字（sockets） -l, &amp;ndash;listening 显示监听状态的套接字（sockets） -o, &amp;ndash;options 显示计时器信息 -e, &amp;ndash;extended 显示详细的套接字（sockets）信息 -m, &amp;ndash;memory 显示套接字（socket）的内存使用情况 -p, &amp;ndash;processes 显示使用套接字（socket）的进程 -i, &amp;ndash;info 显示 TCP内部信息 -s, &amp;ndash;summary 显示套接字（socket）使用概况 -4, &amp;ndash;ipv4 仅显示IPv4的套接字（sockets） -6, &amp;ndash;ipv6 仅显示IPv6的套接字（sockets） -0, &amp;ndash;packet 显示 PACKET 套接字（socket） -t, &amp;ndash;tcp 仅显示 TCP套接字（sockets） -u, &amp;ndash;udp 仅显示 UCP套接字（sockets） -d, &amp;ndash;dccp 仅显示 DCCP套接字（sockets） -w, &amp;ndash;raw 仅显示 RAW套接字（sockets） -x, &amp;ndash;unix 仅显示 Unix套接字（sockets） -f, &amp;ndash;family=FAMILY 显示 FAMILY类型的套接字（sockets），FAMILY可选，支持 unix, inet, inet6, link, netlink -A, &amp;ndash;query=QUERY, &amp;ndash;socket=QUERYQUERY := {all inet -D, &amp;ndash;diag=FILE 将原始TCP套接字（sockets）信息转储到文件 -F, &amp;ndash;filter=FILE 从文件中都去过滤器信息 FILTER := [ state TCP-STATE ] [ EXPRESSION ] 使用实例# 例一：显示TCP连接</description>
    </item>
    <item>
      <title>每天一个linux命令（41）: netstat</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-41-netstat/</link>
      <pubDate>Tue, 10 Jan 2017 09:54:16 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-41-netstat/</guid>
      <description>netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。&#xA;如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用netstat查一查为什么会出现这些情况了。&#xA;命令格式# $ netstat [-acCeFghilMnNoprstuvVwx][-A&amp;lt;网络类型&amp;gt;][--ip] 命令功能# netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。&#xA;命令参数# 命令 描述 -a或–all 显示所有连线中的Socket -A&amp;lt;网络类型&amp;gt;或–&amp;lt;网络类型&amp;gt; 列出该网络类型连线中的相关地址 -c或–continuous 持续列出网络状态 -C或–cache 显示路由器配置的快取信息 -e或–extend 显示网络其他相关信息 -F或–fib 显示FIB -g或–groups 显示多重广播功能群组组员名单 -h或–help 在线帮助 -i或–interfaces 显示网络界面信息表单 -l或–listening 显示监控中的服务器的Socket -M或–masquerade 显示伪装的网络连线 -n或–numeric 直接使用IP地址，而不通过域名服务器 -N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称 -o或–timers 显示计时器 -p或–programs 显示正在使用Socket的程序识别码和程序名称 -r或–route 显示Routing Table -s或–statistice 显示网络工作信息统计表 -t或–tcp 显示TCP传输协议的连线状况 -u或–udp 显示UDP传输协议的连线状况 -v或–verbose 显示指令执行过程 -V或–version 显示版本信息 -w或–raw 显示RAW传输协议的连线状况 -x或–unix 此参数的效果和指定”-A unix”参数相同 –ip或–inet 此参数的效果和指定”-A inet”参数相同 使用实例# 例一：无参数使用&#xA;$ netstat Active Internet connections (w/o servers) Proto Recv-Q Send-Q Local Address Foreign Address State tcp 0 268 192.</description>
    </item>
    <item>
      <title>每天一个linux命令（40）: traceroute</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-40-traceroute/</link>
      <pubDate>Mon, 09 Jan 2017 10:56:53 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-40-traceroute/</guid>
      <description>通过traceroute我们可以知道信息从你的计算机到互联网另一端的主机是走的什么路径。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。linux系统中，我们称之为traceroute,在MS Windows中为tracert。 traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。&#xA;在大多数情况下，我们会在linux主机系统下，直接执行命令行： traceroute hostname 而在Windows系统下是执行tracert的命令： tracert hostname&#xA;命令格式# $ traceroute [参数] [主机] 命令功能# traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。 具体参数格式：traceroute [-dFlnrvx][-f&amp;lt;存活数值&amp;gt;][-g&amp;lt;网关&amp;gt;&amp;hellip;][-i&amp;lt;网络界面&amp;gt;][-m&amp;lt;存活数值&amp;gt;][-p&amp;lt;通信端口&amp;gt;][-s&amp;lt;来源地址&amp;gt;][-t&amp;lt;服务类型&amp;gt;][-w&amp;lt;超时秒数&amp;gt;][主机名称或IP地址][数据包大小]&#xA;命令参数# 命令 描述 -d 使用Socket层级的排错功能 -f 设置第一个检测数据包的存活数值TTL的大小 -F 设置勿离断位 -g 设置来源路由网关，最多可设置8个 -i 使用指定的网络界面送出数据包 -I 使用ICMP回应取代UDP资料信息 -m 设置检测数据包的最大存活数值TTL的大小 -n 直接使用IP地址而非主机名称 -p 设置UDP传输协议的通信端口 -r 忽略普通的Routing Table，直接将数据包送到远端主机上 -s 设置本地主机送出数据包的IP地址 -t 设置检测数据包的TOS数值 -v 详细显示指令的执行过程 -w 设置等待远端主机回报的时间 -x 开启或关闭数据包的正确性检验 使用实例# 例一：traceroute 用法简单、最常用的用法&#xA;$ traceroute yelog.github.com traceroute to yelog.github.com (151.101.192.133), 30 hops max, 60 byte packets 1 vrouter (192.</description>
    </item>
    <item>
      <title>每天一个linux命令（39）: ping</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-39-ping/</link>
      <pubDate>Sun, 08 Jan 2017 10:24:50 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-39-ping/</guid>
      <description>Linux系统的ping命令是常用的网络命令，它通常用来测试与目标主机的连通性，我们经常会说“ping一下某机器，看是不是开着”、不能打开网页时会说“你先ping网关地址192.168.1.1试试”。它通过发送ICMP ECHO_REQUEST数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。&#xA;linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数。&#xA;命令格式# $ ping [参数] [主机名或IP地址] 命令功能# ping命令用于：确定网络和各外部主机的状态；跟踪和隔离硬件和软件问题；测试、评估和管理网络。如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个 tim 结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。 ping 命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping 命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping 命令在程序超时或当接收到 SIGINT 信号时结束。Host 参数或者是一个有效的主机名或者是因特网地址。&#xA;命令参数# 命令 描述 -d 使用Socket的SO_DEBUG功能 -f 极限检测。大量且快速地送网络封包给一台机器，看它的回应 -n 只输出数值 -q 不显示任何传送封包的信息，只显示最后的结果 -r 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题 -R 记录路由过程 -v 详细显示指令的执行过程 -c 数目 在发送指定数目的包后停止 -i 秒数 设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次 -I 网络界面 使用指定的网络界面送出数据包 -l 前置载入 设置在送出要求信息之前，先行发出的数据包 -p 范本样式 设置填满数据包的范本样式 -s 字节数 指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节 -t 存活数值 设置存活数值TTL的大小 使用实例# 例一：ping通的情况&#xA;$ ping 192.</description>
    </item>
    <item>
      <title>每天一个linux命令（38）: route</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-38-route/</link>
      <pubDate>Sat, 07 Jan 2017 10:16:34 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-38-route/</guid>
      <description>Linux系统的route命令用于显示和操作IP路由表（show / manipulate the IP routing table）。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在/etc/rc.local中添加route命令来保证该路由设置永久有效。&#xA;命令格式# route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] 命令功能# Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用&amp;quot;add&amp;quot;或者&amp;quot;del&amp;quot;参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。&#xA;命令参数# 命令 描述 -c 显示更多信息 -n 不解析名字 -v 显示详细的处理信息 -F 显示发送信息 -C 显示路由缓存 -f 清除所有网关入口的路由表 -p 与 add 命令 -p 与 add 命令一起使用时使路由具有永久性。 add 添加一条新路由 del 删除一条路由 -net 目标地址是一个网络 -host 目标地址是一个主机 netmask 当添加一个网络路由时，需要使用网络掩码 gw 路由数据包通过网关。注意，你指定的网关必须能够达到 metric 设置路由跳数 Command 指定您想运行的命令 (Add/Change/Delete/Print) Destination 指定该路由的网络目标 mask Netmask 指定与网络目标相关的网络掩码（也被称作子网掩码） Gateway 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址 metric Metric 为路由指定一个整数成本值标（从 1 至 9999），当在路由表(与转发的数据包目标地址最匹配)的多个路由中进行选择时可以使用 if Interface 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引 使用实例# 例一：显示当前路由</description>
    </item>
    <item>
      <title>每天一个linux命令（37）: ifconfig</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-37-ifconfig/</link>
      <pubDate>Fri, 06 Jan 2017 09:57:01 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-37-ifconfig/</guid>
      <description>许多windows非常熟悉ipconfig命令行工具，它被用来获取网络接口配置信息并对此进行修改。Linux系统拥有一个类似的工具，也就是ifconfig(interfaces config)。通常需要以root身份登录或使用sudo以便在Linux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息，还可以修改这些配置。&#xA;命令格式# $ ifconfig [网络设备] [参数] 命令功能# ifconfig 命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。&#xA;注意： 用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。&#xA;命令参数# 命令 描述 up 启动指定网络设备/网卡 down 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除 arp 设置指定网卡是否支持ARP协议 -promisc 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包 -allmulti 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包 -a 显示全部接口信息 -s 显示摘要信息（类似于 netstat -i） add 给指定网卡配置IPv6地址 del 删除指定网卡的IPv6地址 &amp;lt;硬件地址&amp;gt; 配置网卡最大的传输单元 mtu&amp;lt;字节数&amp;gt; 设置网卡的最大传输单元 (bytes) netmask&amp;lt;子网掩码&amp;gt; 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码 tunel 建立隧道 dstaddr 设定一个远端地址，建立点对点通信 -broadcast&amp;lt;地址&amp;gt; 为指定网卡设置广播协议 -pointtopoint&amp;lt;地址&amp;gt; 为网卡设置点对点通讯协议 multicast 为网卡设置组播标志 address 为网卡设置IPv4地址 txqueuelen&amp;lt;长度&amp;gt; 为网卡设置传输列队的长度 使用实例# 例一：显示网络设备信息（激活状态的）&#xA;$ ifconfig 说明： eth0 表示第一块网卡， 其中 HWaddr 表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是 00:50:56:BF:26:20 inet addr 用来表示网卡的IP地址，此网卡的 IP地址是 192.</description>
    </item>
    <item>
      <title>每天一个linux命令（36）: lsof</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-36-lsof/</link>
      <pubDate>Thu, 05 Jan 2017 10:28:13 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-36-lsof/</guid>
      <description>lsof（list open files）是一个列出当前系统打开文件的工具。在linux环境下，任何事物都以文件的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。&#xA;命令格式# $ lsof [参数][文件] 命令功能# 用于查看你进程开打的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为 lsof 需要访问核心内存和各种文件，所以需要root用户执行。 lsof打开的文件可以是：&#xA;普通文件 目录 网络文件系统的文件 字符或设备文件 (函数)共享库 管道，命名管道 符号链接 网络文件（例如：NFS file、网络socket，unix域名socket） 还有其它类型的文件，等等 命令参数# 命令 描述 -a 列出打开文件存在的进程 -c&amp;lt;进程名&amp;gt; 列出指定进程所打开的文件 -g 列出GID号进程详情 -d&amp;lt;文件号&amp;gt; 列出占用该文件号的进程 +d&amp;lt;目录&amp;gt; 列出目录下被打开的文件 +D&amp;lt;目录&amp;gt; 递归列出目录下被打开的文件 -n&amp;lt;目录&amp;gt; 列出使用NFS的文件 -i&amp;lt;条件&amp;gt; 列出符合条件的进程。（4、6、协议、:端口、 @ip ） -p&amp;lt;进程号&amp;gt; 列出指定进程号所打开的文件 -u 列出UID号进程详情 -h 显示帮助信息 -v 显示版本信息 使用实例# 例一：无任何参数&#xA;$ lsof COMMAND PID USER FD TYPE DEVICE SIZE NODE NAME init 1 root cwd DIR 8,2 4096 2 / init 1 root rtd DIR 8,2 4096 2 / init 1 root txt REG 8,2 43496 6121706 /sbin/init init 1 root mem REG 8,2 143600 7823908 /lib64/ld-2.</description>
    </item>
    <item>
      <title>每天一个linux命令（35）: iostat</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-35-iostat/</link>
      <pubDate>Wed, 04 Jan 2017 10:10:02 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-35-iostat/</guid>
      <description>Linux系统中的 iostat是I/O statistics（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。iostat属于sysstat软件包。可以用yum install sysstat 直接安装。&#xA;命令格式# $ iostat [参数][时间][次数] 命令功能# 通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况,&#x9;负载信息。&#xA;命令参数# 命令 描述 -C 显示CPU使用情况 -d 显示磁盘使用情况 -k 以 KB 为单位显示 -m 以 M 为单位显示 -N 显示磁盘阵列(LVM) 信息 -n 显示 NFS 使用情况 -p[磁盘] 显示磁盘和分区的情况 -t 显示终端和CPU的信息 -x 显示详细信息 -V 显示版本信息 使用实例# 例一：显示所有设备负载情况&#xA;$ iostat Linux 3.10.0-327.el7.x86_64 (s88) 2017年01月22日 _x86_64_&#x9;(24 CPU) avg-cpu: %user %nice %system %iowait %steal %idle 0.62 0.00 0.20 1.46 0.00 97.72 Device: tps kB_read/s kB_wrtn/s kB_read kB_wrtn sda 64.</description>
    </item>
    <item>
      <title>每天一个linux命令（34）: vmstat</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-34-vmstat/</link>
      <pubDate>Tue, 03 Jan 2017 09:46:57 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-34-vmstat/</guid>
      <description>vmstat是Virtual Meomory Statistics（虚拟内存统计）的缩写，可对操作系统的虚拟内存、进程、CPU活动进行监控。他是对系统的整体情况进行统计，不足之处是无法对某个进程进行深入分析。vmstat 工具提供了一种低开销的系统性能观察方式。因为 vmstat 本身就是低开销工具，在非常高负荷的服务器上，你需要查看并监控系统的健康情况,在控制窗口还是能够使用vmstat 输出结果。在学习vmstat命令前，我们先了解一下Linux系统中关于物理内存和虚拟内存相关信息。&#xA;物理内存和虚拟内存区别# 我们知道，直接从物理内存读写数据要比从硬盘读写数据要快的多，因此，我们希望所有数据的读取和写入都在内存完成，而内存是有限的，这样就引出了物理内存与虚拟内存的概念。&#xA;物理内存就是系统硬件提供的内存大小，是真正的内存，相对于物理内存，在linux下还有一个虚拟内存的概念，虚拟内存就是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块逻辑内存，用作虚拟内存的磁盘空间被称为交换空间（Swap Space）。&#xA;作为物理内存的扩展，linux会在物理内存不足时，使用交换分区的虚拟内存，更详细的说，就是内核会将暂时不用的内存块信息写到交换空间，这样以来，物理内存得到了释放，这块内存就可以用于其它目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。&#xA;linux的内存管理采取的是分页存取机制，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。&#xA;要深入了解linux内存运行机制，需要知道下面提到的几个方面：&#xA;首先，Linux系统会不时的进行页面交换操作，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，Linux也会交换出暂时不用的内存页面。这可以避免等待交换所需的时间。&#xA;其次，linux进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，linux内核根据”最近最经常使用“算法，仅仅将一些不经常使用的页面文件交换到虚拟内存，有时我们会看到这么一个现象：linux物理内存还有很多，但是交换空间也使用了很多。其实，这并不奇怪，例如，一个占用很大内存的进程运行时，需要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存时，刚才被交换出去的页面文件并不会自动的交换进物理内存，除非有这个必要，那么此刻系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。关于这点，不用担心什么，只要知道是怎么一回事就可以了。&#xA;最后，交换空间的页面在使用时会首先被交换到物理内存，如果此时没有足够的物理内存来容纳这些页面，它们又会被马上交换出去，如此以来，虚拟内存中可能没有足够空间来存储这些交换页面，最终会导致linux出现假死机、服务异常等问题，linux虽然可以在一段时间内自行恢复，但是恢复后的系统已经基本不可用了。&#xA;因此，合理规划和设计linux内存的使用，是非常重要的。&#xA;虚拟内存原理：# 在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物理内存，将这部分资料存储在磁盘上直到进程下一次调用，并将释放出的内存提供给有需要的进程使用。&#xA;在Linux内存管理中，主要是通过“调页Paging”和“交换Swapping”来完成上述的内存调度。调页算法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整个进程，而不是部分页面，全部交换到磁盘上。&#xA;分页(Page)写入磁盘的过程被称作Page-Out，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误（Page Fault）。&#xA;当系统内核发现可运行内存变少时，就会通过Page-Out来释放一部分物理内存。经管Page-Out不是经常发生，但是如果Page-out频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系统效能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态亦被称作thrashing(颠簸)。&#xA;命令格式# $ vmstat [-a] [-n] [-S unit] [delay [ count]] $ vmstat [-s] [-n] [-S unit] $ vmstat [-m] [-n] [delay [ count]] $ vmstat [-d] [-n] [delay [ count]] $ vmstat [-p disk partition] [-n] [delay [ count]] $ vmstat [-f] $ vmstat [-V] 命令功能# 用来显示虚拟内存的信息</description>
    </item>
    <item>
      <title>每天一个linux命令（33）: free</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-33-free/</link>
      <pubDate>Mon, 02 Jan 2017 21:43:26 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-33-free/</guid>
      <description>　free命令可以显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer。在Linux系统监控的工具中，free命令是最经常使用的命令之一。&#xA;命令格式# $ free [参数] 命令功能# free 命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。共享内存将被忽略&#xA;命令参数# 命令 描述 -b 以Byte为单位显示内存使用情况 -k 以KB为单位显示内存使用情况 -m 以MB为单位显示内存使用情况 -g 以GB为单位显示内存使用情况 -o 不显示缓冲区调节列 -s&amp;lt;间隔秒数&amp;gt; 持续观察内存使用状况 -t 显示内存总和列 -V 显示版本信息 使用实例# 例一：显示内存使用情况&#xA;$ free total used free shared buff/cache available Mem: 12095180 8362640 198460 1379116 3534080 2100004 Swap: 8185112 40008 8145104 说明： total:总计物理内存的大小。 used:已使用多大。 free:可用有多少。 Shared:多个进程共享的内存总额。 Buffers/cached:磁盘缓存的大小。&#xA;例二：显示内存使用情况&#xA;$ free -t 例三：周期性的查询内存使用信息&#xA;## 每10s 执行一次命令 $ free -s 10 </description>
    </item>
    <item>
      <title>每天一个linux命令（32）: top</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-32-top/</link>
      <pubDate>Sun, 01 Jan 2017 19:31:28 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-32-top/</guid>
      <description>top命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。下面详细介绍它的使用方法。top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定。&#xA;命令格式# $ top [参数] 命令功能# 显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等&#xA;命令参数# 参数 描述 -b 批处理 -c 显示完整的治命令 -I 忽略失效过程 -s 保密模式 -S 累积模式 -i&amp;lt;时间&amp;gt; 设置间隔时间 -u&amp;lt;用户名&amp;gt; 指定用户名 -p&amp;lt;进程号&amp;gt; 指定进程 -n&amp;lt;次数&amp;gt; 循环显示的次数 top交互命令# 在top 命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了s 选项， 其中一些命令可能会被屏蔽。&#xA;参数 描述 h 显示帮助画面，给出一些简短的命令总结说明 k 终止一个进程。 i 忽略闲置和僵死进程。这是一个开关式命令 q 退出程序 r 重新安排一个进程的优先级别 S 切换到累计模式 s 改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s f或者F 从当前显示中添加或者删除项目 o或者O 改变显示项目的顺序 l 切换显示平均负载和启动时间信息 m 切换显示内存信息 t 切换显示进程和CPU状态信息 c 切换显示命令名称和完整命令行 M 根据驻留内存大小进行排序 P 根据CPU使用百分比大小进行排序 T 根据时间/累计时间进行排序 W 将当前设置写入~/.</description>
    </item>
    <item>
      <title>每天一个linux命令（31）: du</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-31-du/</link>
      <pubDate>Sat, 31 Dec 2016 14:36:01 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-31-du/</guid>
      <description>Linux du命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对文件和目录磁盘使用的空间的查看，还是和df命令有一些区别的.&#xA;命令格式# $ du [选项][文件] 命令功能# 显示每个文件和目录的磁盘使用空间。&#xA;命令参数# 参数 描述 -a或-all 显示目录中个别文件的大小。 -b或-bytes 显示目录或文件大小时，以byte为单位。 -c或&amp;ndash;total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 -k或&amp;ndash;kilobytes 以KB(1024bytes)为单位输出。 -m或&amp;ndash;megabytes 以MB为单位输出。 -s或&amp;ndash;summarize 仅显示总计，只列出最后加总的值。 -h或&amp;ndash;human-readable 以K，M，G为单位，提高信息的可读性。 -x或&amp;ndash;one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。 -L&amp;lt;符号链接&amp;gt;或&amp;ndash;dereference&amp;lt;符号链接&amp;gt; 显示选项中所指定符号链接的源文件大小。 -S或&amp;ndash;separate-dirs 显示个别目录的大小时，并不含其子目录的大小。 -X&amp;lt;文件&amp;gt;或&amp;ndash;exclude-from=&amp;lt;文件&amp;gt; 在&amp;lt;文件&amp;gt;指定目录或文件。 &amp;ndash;exclude=&amp;lt;目录或文件&amp;gt; 略过指定的目录或文件。 -D或&amp;ndash;dereference-args 显示指定符号链接的源文件大小。 -H或&amp;ndash;si 与-h参数相同，但是K，M，G是以1000为换算单位。 -l或&amp;ndash;count-links 重复计算硬件链接的文件。 使用实例# 例一：显示目录或者文件所占空间&#xA;$ du 说明： 只显示当前目录下面的子目录的目录大小和当前目录的总的大小，最下面的1288为当前目录的总大小&#xA;例二：显示指定文件所占空间&#xA;$ du log2012.log 例三：查看指定目录的所占空间&#xA;$ du scf 例四：显示多个文件所占空间&#xA;$ du log30.tar.gz log31.tar.gz 例五：只显示总和的大小&#xA;$ du -s 例六：方便阅读的格式显示&#xA;$ du -h test 例七：文件和目录都显示</description>
    </item>
    <item>
      <title>每天一个linux命令（30）: df</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-30-df/</link>
      <pubDate>Fri, 30 Dec 2016 14:23:31 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-30-df/</guid>
      <description>linux中df命令的功能是用来检查linux服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息。&#xA;命令格式# $ df [选项] [文件] 命令功能# 显示指定磁盘文件的可用空间。如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示&#xA;命令参数# 必要参数&#xA;参数 描述 -a 全部文件系统列表 -h 方便阅读方式显示 -H 等于“-h”，但是计算式，1K=1000，而不是1K=1024 -i 显示inode信息 -k 区块为1024字节 -l 只显示本地文件系统 -m 区块为1048576字节 &amp;ndash;no-sync 忽略 sync 命令 -P 输出格式为POSIX &amp;ndash;sync 在取得磁盘信息前，先执行sync命令 -T 文件系统类型 选择参数&#xA;参数 描述 &amp;ndash;block-size=&amp;lt;区块大小&amp;gt; 指定区块大小 -t&amp;lt;文件系统类型&amp;gt; 只显示选定文件系统的磁盘信息 -x&amp;lt;文件系统类型&amp;gt; 不显示选定文件系统的磁盘信息 &amp;ndash;help 显示帮助信息 &amp;ndash;version 显示版本信息 使用实例# 例一：显示磁盘使用情况&#xA;$ df 说明： linux中df命令的输出清单的第1列是代表文件系统对应的设备文件的路径名（一般是硬盘上的分区）；第2列给出分区包含的数据块（1024字节）的数目；第3，4列分别表示已用的和可用的数据块数目。用户也许会感到奇怪的是，第3，4列块数之和不等于第2列中的块数。这是因为缺省的每个分区都留了少量空间供系统管理员使用。即使遇到普通用户空间已满的情况，管理员仍能登录和留有解决问题所需的工作空间。清单中Use% 列表示普通用户空间使用的百分比，即使这一数字达到100％，分区仍然留有系统管理员使用的空间。最后，Mounted on列表示文件系统的挂载点。&#xA;例二：以inode模式来显示磁盘使用情况&#xA;$ df -i 例三：显示指定类型磁盘&#xA;$ df -t ext3 例四：列出各文件系统的i节点使用情况</description>
    </item>
    <item>
      <title>每天一个linux命令（29）: /etc/group文件详解</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-29-group/</link>
      <pubDate>Thu, 29 Dec 2016 14:13:05 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-29-group/</guid>
      <description>Linux /etc/group文件与/etc/passwd和/etc/shadow文件都是有关于系统管理员对用户和用户组管理时相关的文件。linux /etc/group文件是有关于系统管理员对用户和用户组管理的文件,linux用户组的所有信息都存放在/etc/group文件中。具有某种共同特征的用户集合起来就是用户组（Group）。用户组（Group）配置文件主要有 /etc/group和/etc/gshadow，其中/etc/gshadow是/etc/group的加密信息文件。&#xA;将用户分组是Linux系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不 同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。&#xA;用户组的所有信息都存放在/etc/group文件中。此文件的格式是由冒号(:)隔开若干个字段，这些字段具体如下：&#xA;组名:口令:组标识号:组内用户列表&#xA;解释# 组名： 组名是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。 口令： 口令字段存放的是用户组加密后的口令字。一般Linux系统的用户组都没有口令，即这个字段一般为空，或者是*。 组标识号： 组标识号与用户标识号类似，也是一个整数，被系统内部用来标识组。别称GID. 组内用户列表： 是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。&#xA;使用实例# $ cat /etc/group 说明： 我们以root:x:0:root,linuxsir 为例： 用户组root，x是密码段，表示没有设置密码，GID是0,root用户组下包括root、linuxsir以及GID为0的其它用户。</description>
    </item>
    <item>
      <title>每天一个linux命令（28）: chown</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-28-chown/</link>
      <pubDate>Wed, 28 Dec 2016 09:51:30 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-28-chown/</guid>
      <description>　chown将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。系统管理员经常使用chown命令，在将文件拷贝到另一个用户的名录下之后，让用户拥有使用该文件的权限。&#xA;命令格式# $ chown [选项]... [所有者][:[组]] 文件... 命令功能# 通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限一般为管理员。&#xA;命令参数# 必要参数&#xA;参数 描述 -c 显示更改的部分的信息 -f 忽略错误信息 -h 修复符号链接 -R 处理指定目录以及其子目录下的所有文件 -v 显示详细的处理信息 -deference 作用于符号链接的指向，而不是链接文件本身 选择参数&#xA;参数 描述 &amp;ndash;reference=&amp;lt;目录或文件&amp;gt; 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组 &amp;ndash;from=&amp;lt;当前用户：当前群组&amp;gt; 只有当前用户和群组跟指定的用户和群组相同时才进行改变 &amp;ndash;help 显示帮助信息 &amp;ndash;version 显示版本信息 命令实例# 例一：改变拥有者和群组&#xA;$ chown mail:mail log2012.log 例二：改变文件拥有者和群组&#xA;## 组可为空，默认为root所在组 $ chown root: log2012.log 例三：改变文件群组&#xA;## 只改变所在组 $ chown :mail log2012.log 例四：改变指定目录以及其子目录下的所有文件的拥有者和群组&#xA;$ chown -R -v root:mail test6 </description>
    </item>
    <item>
      <title>每天一个linux命令（27）: chgrp</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-27-chgrp/</link>
      <pubDate>Tue, 27 Dec 2016 09:40:06 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-27-chgrp/</guid>
      <description>　在lunix系统里，文件或目录的权限的掌控以拥有者及所诉群组来管理。可以使用chgrp指令取变更文件与目录所属群组，这种方式采用群组名称或群组识别码都可以。Chgrp命令就是change group的缩写！要被改变的组名必须要在/etc/group文件内存在才行。&#xA;命令格式# $ chgrp [选项] [组] [文件] 命令功能# chgrp命令可采用群组名称或群组识别码的方式改变文件或目录的所属群组。使用权限是超级用户。&#xA;命令参数# 必要参数&#xA;参数 描述 -c 当发生改变时，报告处理信息 -f 不显示错误信息 -R 处理指定目录以及其子目录下的所有文件 -v 运行时显示详细的处理信息 &amp;ndash;dereference 作用于符号链接的指向，而不是符号链接本身 &amp;ndash;no-dereference 作用于符号链接本身 选择参数&#xA;参数 描述 &amp;ndash;reference=&amp;lt;文件或者目录&amp;gt; 设置为和指定的文件或目录的权限一样 &amp;ndash;help 显示帮助信息 &amp;ndash;version 显示版本信息 命令实例# 例一：改变文件的群组属性&#xA;## 将log2012.log文件由root群组改为bin群组 $ chgrp -v bin log2012.log “log2012.log” 的所属组已更改为 bin 例二：根据指定文件改变文件的群组属性&#xA;## 改变文件log2013.log 的群组属性，使得文件log2013.log的群组属性和参考文件log2012.log的群组属性相同 $ chgrp --reference=log2012.log log2013.log 例三：改变指定目录以及其子目录下的所有文件的群组属性&#xA;## 改变指定目录以及其子目录下的所有文件的群组属性 $ chgrp -R bin test6 例四：通过群组识别码改变文件群组属性&#xA;## 通过群组识别码改变文件群组属性，100为users群组的识别码，具体群组和群组识别码可以去/etc/group文件中查看 $ chgrp -R 100 test6 </description>
    </item>
    <item>
      <title>每天一个linux命令（26）: chmod</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-26-chmod/</link>
      <pubDate>Mon, 26 Dec 2016 20:22:43 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-26-chmod/</guid>
      <description>chmod命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。&#xA;Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。&#xA;文件或目录的访问权限分为只读，只写和可执行三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。&#xA;有三种不同类型的用户可对文件或目录进行访问：文件所有者，同组用户、其他用户。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。&#xA;每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 例如：&#xA;$ ls -al -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log 第一列共有10个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是d，表示是一个目录。从第二个字符开始到第十个共9个字符，3个字符一组，分别表示了3组用户对文件或者目录的权限。权限字符用横线代表空许可，r代表只读，w代表写，x代表可执行。&#xA;- rw- r-- r-- 表示log2012.log是一个普通文件；log2012.log的属主有读写权限；与log2012.log属主同组的用户只有读权限；其他用户也只有读权限。&#xA;确定了一个文件的访问权限后，用户可以利用Linux系统提供的chmod命令来重新设定不同的访问权限。也可以利用chown命令来更改某个文件或目录的所有者。利用chgrp命令来更改某个文件或目录的用户组。&#xA;chmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。chmod命令详细情况如下。&#xA;命令格式# $ chmod [-cfvR] [--help] [--version] mode file 命令功能# 用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。&#xA;命令参数# 必要参数&#xA;参数 描述 -c 当发生改变时，报告处理信息 -f 错误信息不输出 -R 处理指定目录以及其子目录下的所有文件 -v 运行时显示详细处理信息 选择参数&#xA;参数 描述 &amp;ndash;reference=&amp;lt;目录或者文件&amp;gt; 设置成具有指定目录或者文件具有相同的权限 &amp;ndash;version 显示版本信息 &amp;lt;权限范围&amp;gt;+&amp;lt;权限设置&amp;gt; 使权限范围内的目录或者文件具有指定的权限 &amp;lt;权限范围&amp;gt;-&amp;lt;权限设置&amp;gt; 删除权限范围的目录或者文件的指定权限 &amp;lt;权限范围&amp;gt;=&amp;lt;权限设置&amp;gt; 设置权限范围内的目录或者文件的权限为指定的值 权限范围&#xA;参数 描述 u 目录或者文件的当前的用户 g 目录或者文件的当前的群组 o 除了目录或者文件的当前用户或群组之外的用户或者群组 a 所有的用户及群组 权限代号</description>
    </item>
    <item>
      <title>每天一个linux命令（24）: tar</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-24-tar/</link>
      <pubDate>Sat, 24 Dec 2016 10:24:17 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-24-tar/</guid>
      <description>通过SSH访问服务器，难免会要用到压缩，解压缩，打包，解包等，这时候tar命令就是是必不可少的一个功能强大的工具。linux中最流行的tar是麻雀虽小，五脏俱全，功能强大。&#xA;tar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（备份文件），也可以在档案中改变文件，或者向档案中加入新的文件。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。&#xA;首先要弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件。&#xA;为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。&#xA;linux下最常用的打包程序就是tar了，使用tar程序打出来的包我们常称为tar包，tar包文件的命令通常都是以.tar结尾的。生成tar包后，就可以用其它的程序来进行压缩。&#xA;命令格式# $ tar [必要参数] [选择参数] [文件] 命令功能# 用来压缩和解压文件。tar本身不具有压缩功能。他是调用压缩功能实现的&#xA;命令参数# 必要参数&#xA;参数 描述 -A 新增压缩文件到已存在的压缩 -B 设置区块大小 -c 建立新的压缩文件 -d 记录文件的差别 -r 添加文件到已经压缩的文件 -u 添加改变了和现有的文件到已经存在的压缩文件 -x 从压缩的文件中提取文件 -t 显示压缩文件的内容 -z 支持gzip解压文件 -j 支持bzip2解压文件 -Z 支持compress解压文件 -v 显示操作过程 -l 文件系统边界设置 -k 保留原有文件不覆盖 -m 保留文件不被覆盖 -W 确认压缩文件的正确性 可选参数 参数 描述 -b 设置区块数目 -C 切换到指定目录 -f 指定压缩文件 &amp;ndash;help 显示帮助信息 &amp;ndash;version 显示版本信息 使常见解压/压缩命令# 例一：.tar文件&#xA;$ tar xvf FileName.tar ## 解包 $ tar cvf FileName.</description>
    </item>
    <item>
      <title>每天一个linux命令（23）: 用SecureCRT来上传和下载文件</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-23-securecrt/</link>
      <pubDate>Fri, 23 Dec 2016 09:48:15 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-23-securecrt/</guid>
      <description>用SSH管理linux服务器时经常需要远程与本地之间交互文件.而直接用SecureCRT自带的上传下载功能无疑是最方便的，SecureCRT下的文件传输协议有ASCII、Xmodem、Zmodem。&#xA;文件传输协议 文件传输是数据交换的主要形式。在进行文件传输时，为使文件能被正确识别和传送，我们需要在两台计算机之间建立统一的传输协议。这个协议包括了文件的识别、传送的起止时间、错误的判断与纠正等内容。常见的传输协议有以下几种：&#xA;ASCII：这是最快的传输协议，单只能传输文本文件。 Xmodem：这种古老的传输协议速度较慢，但由于使用了CRC错误侦测方法，传输的准确率可高达99.6%。 Ymodem：这是Xmodem的改良版，使用了1024位区段传送，速度比Xmodem要快 Zmodem：Zmodem采用了串流式（streaming）传输方式，传输速度较快，而且还具有自动改变区段大小和断点续传、快速错误侦测等功能。这是目前最流行的文件传输协议。 除以上几种外，还有Imodem、Jmodem、Bimodem、Kermit、Lynx等协议，由于没有多数厂商支持，这里就略去不讲。&#xA;SecureCRT可以使用linux下的zmodem协议来快速的传送文件,使用非常方便.具体步骤：&#xA;在使用SecureCRT上传下载之前需要给服务器安装lrzsz# 从下面的地址下载 lrzsz-0.12.20.tar.gz 我是下载地址 查看里面的INSTALL文档了解安装参数说明和细节 解压文件 $ tar zxvf lrzsz-0.12.20.tar.gz 进入目录，配置编译 $ cd lrzsz-0.12.20 $ ./configure --prefix=/usr/local/lrzsz $ make $ make install 建立软链接 $ cd /usr/bin $ ln -s /usr/local/lrzsz/bin/lrz rz $ ln -s /usr/local/lrzsz/bin/lsz sz 测试 运行 rz 弹出 SecureCrt上传窗口，用SecureCRT来上传和下载文件。&#xA;设置SecureCRT上传和下载的默认目录# options-&amp;gt;session options -&amp;gt;Terminal-&amp;gt;Xmodem/Zmodem 右栏directory设置上传和下载的目录&#xA;使用Zmodem从客户端上传文件到linux服务器# 用SecureCRT登陆linux终端&#xA;选中你要放置上传文件的路径，在目录下然后输入rz命令,SecureCRT会弹出文件选择对话框，在查找范围中找到你要上传的文件，按Add按钮。然后OK就可以把文件上传到linux上了。&#xA;或者在Transfer-&amp;gt;Zmodem Upoad list弹出文件选择对话框，选好文件后按Add按钮。然后OK窗口自动关闭。然后在linux下选中存放文件的目录，输入rz命令。liunx就把那个文件上传到这个目录下了。&#xA;使用Zmodem下载文件到客户端# $ sz filename zmodem 接收可以自行启动.下载的文件存放在你设定的默认下载目录下&#xA;rz，sz 是 Linux/Unix 同 Windows 进行 ZModem 文件传输的命令行工具 , windows 端需要支持ZModem的telnet/ssh客户端，SecureCRT 就可以用 SecureCRT 登陆到 Unix/Linux 主机（telnet或ssh均可）O 运行命令rz，即是接收文件，SecureCRT就会弹出文件选择对话框，选好文件之后关闭对话框，文件就会上传到当前目录 O 运行命令sz file1 file2就是发文件到windows上（保存的目录是可以配置） 比ftp命令方便多了，而且服务器不用再开FTP服务了</description>
    </item>
    <item>
      <title>每天一个linux命令（22）: find命令的参数详解</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-22-find-args/</link>
      <pubDate>Thu, 22 Dec 2016 11:44:14 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-22-find-args/</guid>
      <description>find一些常用参数的一些常用实例和一些具体用法和注意事项。&#xA;使用name选项# 文件名选项是find命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。&#xA;## 在自己的根目录$HOME中查找文件名符合*.log的文件，使用~作为 &amp;#39;pathname&amp;#39;参数，波浪号~代表了你的$HOME目录。 $ find ~ -name &amp;#34;*.log&amp;#34; -print ## 在当前目录及子目录中查找所有的‘ *.log‘文件 $ find . -name &amp;#34;*.log&amp;#34; -print ## 当前目录及子目录中查找文件名以一个大写字母开头的文件 $ find . -name &amp;#34;[A-Z]*&amp;#34; -print ## 在/etc目录中查找文件名以host开头的文件 $ find /etc -name &amp;#34;host*&amp;#34; -print ## 想要查找$HOME目录中的文件 $ find ~ -name &amp;#34;*&amp;#34; -print $ find . -print ## 让系统高负荷运行，就从根目录开始查找所有的文件 $ find / -name &amp;#34;*&amp;#34; -print ## 在当前目录查找文件名以一个个小写字母开头，最后是4到9加上.log结束的文件 $ find . -name &amp;#34;[a-z]*[4-9].log&amp;#34; -print 用perm选项# 按照文件权限模式用-perm选项,按文件权限模式来查找文件的话。最好使用八进制的权限表示法&#xA;## 在当前目录下查找文件权限位为755的文件 $ find .</description>
    </item>
    <item>
      <title>每天一个linux命令（21）: find命令之xargs</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-21-find-xargs/</link>
      <pubDate>Wed, 21 Dec 2016 11:08:01 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-21-find-xargs/</guid>
      <description>在使用 find命令的-exec选项处理匹配到的文件时， find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是xargs命令的用处所在，特别是与find命令一起使用。&#xA;find命令把匹配到的文件传递给xargs命令，而xargs命令每次只获取一部分文件而不是全部，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。&#xA;在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高； 而使用xargs命令则只有一个进程。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。&#xA;使用实例# 例一：查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件&#xA;$ find . -type f -print | xargs file 例二：在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中&#xA;$ find / -name &amp;#34;core&amp;#34; -print | xargs echo &amp;#34;&amp;#34; &amp;gt;/tmp/core.log 例三：在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限&#xA;$ find . -perm -7 -print | xargs chmod o-w 例四：用grep命令在所有的普通文件中搜索hostname这个词&#xA;$ find . -type f -print | xargs grep &amp;#34;hostname&amp;#34; 例五：用grep命令在当前目录下的所有普通文件中搜索hostnames这个词&#xA;## \用来取消find命令中的*在shell中的特殊含义 $ find . -name \* -type f -print | xargs grep &amp;#34;hostnames&amp;#34; 例六：使用xargs执行mv</description>
    </item>
    <item>
      <title>每天一个linux命令（20）: find命令之exec</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-20-find-exec/</link>
      <pubDate>Tue, 20 Dec 2016 10:47:32 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-20-find-exec/</guid>
      <description>find是我们很常用的一个Linux命令，但是我们一般查找出来的并不仅仅是看看而已，还会有进一步的操作，这个时候exec的作用就显现出来了&#xA;命令介绍# -exec 参数后面跟的是command命令，它的终止是以;为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。&#xA;{} 花括号代表前面find查找出来的文件名。&#xA;使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，很方便的。在有些操作系统中只允许-exec选项执行诸如ls或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。 exec选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最后是一个分号。为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。&#xA;使用实例# 例一：ls -l命令放在find命令的-exec选项中&#xA;## find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出 $ find . -type f -exec ls -l {} \; 例二：在目录中查找更改时间在n日以前的文件并删除它们&#xA;$ find . -type f -mtime +14 -exec rm {} \; 例三：在目录中查找更改时间在n日以前的文件并删除它们，在删除之前先给出提示&#xA;$ find . -name &amp;#34;*.log&amp;#34; -mtime +5 -ok rm {} \; 例四：-exec中使用grep命令&#xA;$ find /etc -name &amp;#34;passwd*&amp;#34; -exec grep &amp;#34;root&amp;#34; {} \; 例五：查找文件移动到指定目录&#xA;$ find . -name &amp;#34;*.log&amp;#34; -exec mv {} .</description>
    </item>
    <item>
      <title>每天一个linux命令（19）: find命令概览</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-19-find/</link>
      <pubDate>Mon, 19 Dec 2016 15:19:10 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-19-find/</guid>
      <description>Linux下find命令在目录结构中搜索文件，并执行指定的操作。Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只你具有相应的权限。 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。&#xA;命令格式# $ find pathname -options [-print -exec -ok ...] 命令功能# 用于在文件树种查找文件，并作出相应的处理&#xA;命令参数# 参数 描述 pathname find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录 -print find命令将匹配的文件输出到标准输出 -exec find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&amp;rsquo;command&amp;rsquo; { } ;，注意{ }和\；之间的空格 -ok 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行 命令选项# 选项 描述 -name 按照文件名查找文件 -perm 按照文件权限来查找文件 -prune 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略 -user 按照文件属主来查找文件 -group 按照文件所属的组来查找文件 -mtime -n +n 按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime 选项，但它们都和-m time选项 -nogroup 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在 -nouser 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在 -newer file1 ! file2 查找更改时间比文件file1新但比文件file2旧的文件 -type 查找某一类型的文件,诸如：b - 块设备文件d - 目录c - 字符设备文件p - 管道文件l - 符号链接文件f - 普通文件 -size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找 -fstype 查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息 -mount 在查找文件时不跨越文件系统mount点 -follow 如果find命令遇到符号链接文件，就跟踪至链接所指向的文件 -cpio 对匹配的文件使用cpio命令，将这些文件备份到磁带设备中 -amin n 查找系统中最后N分钟访问的文件 -atime n 查找系统中最后n*24小时访问的文件 -cmin n 查找系统中最后N分钟被改变文件状态的文件 -ctime n 查找系统中最后n*24小时被改变文件状态的文件 -mmin n 查找系统中最后N分钟被改变文件数据的文件 -mtime n 查找系统中最后n*24小时被改变文件数据的文件 使用实例# 例一：查找指定时间内修改过的文件</description>
    </item>
    <item>
      <title>每天一个linux命令（18）: locate</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-18-locate/</link>
      <pubDate>Sun, 18 Dec 2016 15:09:28 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-18-locate/</guid>
      <description>　locate 让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的 distribution 之中，数据库的建立都被放在 crontab 中自动执行。&#xA;命令格式# $ locate [选择参数] [样式] 命令功能# locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab)&#xA;locate指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录，可以使用特殊字元（如* 或 ?等）来指定范本样式，如指定范本为kcpa*ner, locate会找出所有起始字串为kcpa且结尾为ner的档案或目录，如名称为kcpartner若目录录名称为kcpa_ner则会列出该目录下包括 子目录在内的所有档案。&#xA;locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在 执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。&#xA;命令参数# 参数 描述 -e 将排除在寻找的范围之外 -1 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的权限资料 -f 将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案放在资料库中 -q 安静模式，不会显示任何错误讯息 -n 至多显示 n个输出 -r 使用正规运算式 做寻找的条件 -o 指定资料库存的名称 -d 指定资料库的路径 -h 显示辅助讯息 -V 显示程式的版本讯息 使用实例# 例一：查找和pwd相关的所有文件&#xA;$ locate pwd 例二：搜索etc目录下所有以sh开头的文件&#xA;$ locate /etc/sh </description>
    </item>
    <item>
      <title>每天一个linux命令（17）: whereis</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-17-whereis/</link>
      <pubDate>Sat, 17 Dec 2016 10:42:58 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-17-whereis/</guid>
      <description>whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。&#xA;和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。&#xA;但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。&#xA;命令格式# $ whereis [-bmsu] [BMS 目录名 -f ] 文件名 命令功能# whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。&#xA;命令参数# 参数 描述 -b 定位可执行文件 -m 定位帮助文件 -s 定位源代码文件 -u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件 -B 指定搜索可执行文件的路径 -M 指定搜索帮助文件的路径 -S 指定搜索源代码文件的路径 使用实例# 例一：将和git文件相关的文件都查找出来&#xA;$ whereis git 例二：只将二进制文件 查找出来&#xA;$ whereis -b svn whereis -m svn 查出说明文档路径，whereis -s svn 找source源文件</description>
    </item>
    <item>
      <title>每天一个linux命令（16）: which</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-16-which/</link>
      <pubDate>Fri, 16 Dec 2016 11:25:49 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-16-which/</guid>
      <description>　我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。&#xA;命令格式# $ which 可执行文件名称 命令功能# which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。&#xA;命令参数# 参数 描述 -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名 -p 与-n参数相同，但此处的包括了文件的路径 -w 指定输出时栏位的宽度 -V 显示版本信息 使用实例# 例一：查找文件、显示命令路径&#xA;## which 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！ ## 所以，不同的 PATH 配置内容所找到的命令当然不一样的！ $ which pwd 例二：用 which 去找出 which&#xA;## 竟然会有两个 which ，其中一个是 alias 这就是所谓的『命令别名』，意思是输入 which 会等於后面接的那串命令！ $ which which 例三：找出 cd 这个命令&#xA;## cd 这个常用的命令竟然找不到啊！为什么呢？这是因为 cd 是bash 内建的命令！ ## 但是 which 默认是找 PATH 内所规范的目录，所以当然一定找不到的！ $ which cd </description>
    </item>
    <item>
      <title>每天一个linux命令（15）: tail</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-15-tail/</link>
      <pubDate>Thu, 15 Dec 2016 15:00:26 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-15-tail/</guid>
      <description>　tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容.&#xA;命令格式# tail[必要参数][选择参数][文件] 命令功能# 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。&#xA;命令参数# 参数 描述 -f 循环读取 -q 不显示处理信息 -v 显示详细的处理信息 -c&amp;lt;数目&amp;gt; 显示的字节数 -n&amp;lt;行数&amp;gt; 显示行数 &amp;ndash;pid=PID 与-f合用,表示在进程ID,PID死掉之后结束 -q, &amp;ndash;quiet, &amp;ndash;silent 从不输出给出文件名的首部 -s, &amp;ndash;sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 使用实例# 例一：显示文件末尾内容&#xA;## 显示文件最后5行内容 $ tail -n 5 log2014.log 例二：循环查看文件内容&#xA;$ tail -f test.log 例三：从第5行开始显示文件&#xA;$ tail -n +5 log2014.log </description>
    </item>
    <item>
      <title>每天一个linux命令（14）: head</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-14-head/</link>
      <pubDate>Wed, 14 Dec 2016 14:35:49 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-14-head/</guid>
      <description>　head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾。&#xA;命令格式# head [参数]... [文件]... 命令功能# head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。&#xA;命令参数# 参数 描述 -q 隐藏文件名 -v 显示文件名 -c&amp;lt;字节&amp;gt; 显示字节数 -n&amp;lt;行数&amp;gt; 显示的行数 使用实例# 例一：显示文件的前n行&#xA;$ head -n 5 log2014.log 例二：显示文件前n个字节&#xA;$ head -c 20 log2014.log 例三：文件的除了最后n个字节以外的内容&#xA;$ head -c -32 log2014.log 例四：输出文件除了最后n行的全部内容&#xA;$ head -n -6 log2014.log </description>
    </item>
    <item>
      <title>每天一个linux命令（13）: less</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-13-less/</link>
      <pubDate>Tue, 13 Dec 2016 21:46:14 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-13-less/</guid>
      <description>less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。&#xA;命令格式# $ less [参数] 文件 命令功能# less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。&#xA;命令参数# 参数 描述 -b &amp;lt;缓冲区大小&amp;gt; 设置缓冲区的大小 -e 当文件显示结束后，自动离开 -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 -g 只标志最后搜索的关键词 -i 忽略搜索时的大小写 -m 显示类似more命令的百分比 -N 显示每行的行号 -o &amp;lt;文件名&amp;gt; 将less 输出的内容在指定文件中保存起来 -Q 不使用警告音 -s 显示连续空行为一行 -S 行过长时间将超出部分舍弃 -x &amp;lt;数字&amp;gt; 将“tab”键显示为规定的数字空格 /字符串 向下搜索“字符串”的功能 ?字符串 向上搜索“字符串”的功能 n 重复前一个搜索（与 / 或 ?</description>
    </item>
    <item>
      <title>每天一个linux命令（12）: more</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-12-more/</link>
      <pubDate>Mon, 12 Dec 2016 21:29:39 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-12-more/</guid>
      <description>more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。&#xA;命令格式# $ more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] 命令功能# more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。&#xA;命令参数# 参数 描述 +n 从笫n行开始显示 -n 定义屏幕大小为n行 +/pattern 每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 常用操作# 操作 描述 Enter 向下n行，需要定义。默认为1行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 ：f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 命令实例# 例一：显示文件中从第3行起的内容</description>
    </item>
    <item>
      <title>每天一个linux命令（11）: nl</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-11-nl/</link>
      <pubDate>Sun, 11 Dec 2016 21:11:48 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-11-nl/</guid>
      <description>nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。&#xA;命令格式# $ nl [选项]... [文件]... 命令功能# nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。 输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。&#xA;命令参数# 种类 参数 描述 -b -b a 表示不论是否为空行，也同样列出行号(类似 cat -n) -b t 如果有空行，空的那一行不要列出行号(默认值) -n -n ln 行号在萤幕的最左方显示 -n rn 行号在自己栏位的最右方显示，且不加 0 -n rz 行号在自己栏位的最右方显示，且加 0 -w -w 行号栏位的占用的位数 -p -p 在逻辑定界符处不重新开始计算 命令实例# 例一：用 nl 列出 log2012.log 的内容&#xA;## 文件中的空白行，nl 不会加上行号 $ nl log2012.</description>
    </item>
    <item>
      <title>每天一个linux命令（10）: cat</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-10-cat/</link>
      <pubDate>Sat, 10 Dec 2016 10:52:50 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-10-cat/</guid>
      <description>cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。&#xA;命令格式# $ cat [选项] [文件]... 命令功能# cat主要有三大功能&#xA;一次显示整个文件:cat filename 从键盘创建一个文件:cat &amp;gt; filename 只能创建新文件,不能编辑已有文件. 将几个文件合并为一个文件:cat file1 file2 &amp;gt; file 命令参数# 参数 描述 -A, &amp;ndash;show-all 等价于 -vET -b, &amp;ndash;number-nonblank 对非空输出行编号 -e 等价于 -vE -E, &amp;ndash;show-ends 在每行结束处显示 $ -n, &amp;ndash;number 对输出的所有行编号,由1开始对所有输出的行数编号 -s, &amp;ndash;squeeze-blank 有连续两行以上的空白行，就代换为一行的空白行 -t 与 -vT 等价 -T, &amp;ndash;show-tabs 将跳格字符显示为 ^I -u (被忽略) -v, &amp;ndash;show-nonprinting 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 命令实例# 例一：把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里</description>
    </item>
    <item>
      <title>每天一个linux命令（9）: touch</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-9-touch/</link>
      <pubDate>Fri, 09 Dec 2016 07:15:12 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-9-touch/</guid>
      <description>linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。&#xA;命令格式# $ touch [选项]... 文件... 命令功能# touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。&#xA;命令参数# 参数 描述 -a 或&amp;ndash;time=atime或&amp;ndash;time=access或&amp;ndash;time=use 只更改存取时间 -c 或&amp;ndash;no-create 不建立任何文档 -d 使用指定的日期时间，而非现在的时间 -f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题 -m 或&amp;ndash;time=mtime或&amp;ndash;time=modify 只更改变动时间 -r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同 -t 使用指定的日期时间，而非现在的时间 命令实例# 例一：创建不存在的文件&#xA;$ touch 1.txt 例二：更新1.txt的时间和2.txt时间戳相同&#xA;$ touch -r 1.txt 2.txt 例三：设定文件的时间戳&#xA;$ touch -t 201211142234.50 1.txt 例四：创建不存在的文件&#xA;$ touch 1.txt 说明： -t time 使用指定的时间值 time 作为指定文件相应时间戳记的新值．此处的 time规定为如下形式的十进制数: [[CC]YY]MMDDhhmm[.SS] 这里，CC为年数中的前两位，即”世纪数”；YY为年数的后两位，即某世纪中的年数．如果不给出CC的值，则touch 将把年数CCYY限定在1969&amp;ndash;2068之内．MM为月数，DD为天将把年数CCYY限定在1969&amp;ndash;2068之内．MM为月数，DD为天数，hh 为小时数(几点)，mm为分钟数，SS为秒数．此处秒的设定范围是0&amp;ndash;61，这样可以处理闰秒．这些数字组成的时间是环境变量TZ指定的时区中的一个时 间．由于系统的限制，早于1970年1月1日的时间是错误的。</description>
    </item>
    <item>
      <title>每天一个linux命令（8）: cp</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-8-cp/</link>
      <pubDate>Thu, 08 Dec 2016 16:31:43 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-8-cp/</guid>
      <description>cp命令用来复制文件或者目录，是Linux系统中最常用的命令之一。一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。&#xA;命令格式# $ cp [选项]... [-T] 源 目的 $ cp [选项]... -t 目录 源... 命令功能# 将源文件复制至目标文件，或将多个源文件复制至目标目录。&#xA;命令参数# 参数 描述 -a,&amp;ndash;archive 为每个已存在的目标文件创建备份 -f, &amp;ndash;force 如果目标文件无法打开则将其移除并重试(当 -n 选项存在时则不需再选此项) -i, &amp;ndash;interactive 覆盖前询问(使前面的 -n 选项失效) -H 跟随源文件中的命令行符号链接 -l, &amp;ndash;link 链接文件而不复制 -L, &amp;ndash;dereference 总是跟随符号链接 -n, &amp;ndash;no-clobber 不要覆盖已存在的文件(使前面的 -i 选项失效) -P, &amp;ndash;no-dereference 不跟随源文件中的符号链接 -p 等于&amp;ndash;preserve=模式,所有权,时间戳 -R, -r, &amp;ndash;recursive 复制目录及目录内的所有项目 命令实例# 例一：复制单个文件到目标目录，文件在目标文件中存在，会询问覆盖&#xA;## 在没有带-a参数时，两个文件的时间是不一样的。在带了-a参数时，两个文件的时间是一致的。 $ cp 1.txt test5 例二：复制整个目录&#xA;## 注意目标目录存在与否结果是不一样的。目标目录存在时，整个源目录被复制到目标目录里面。 $ cp -a test3 test5 例三：复制的 log.</description>
    </item>
    <item>
      <title>每天一个linux命令（7）: mv</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-7-mv/</link>
      <pubDate>Wed, 07 Dec 2016 15:55:20 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-7-mv/</guid>
      <description>mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录&#xA;命令格式# $ mv [选项] 源文件或目录 目标文件或目录 命令功能# 视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。&#xA;命令参数# 参数 描述 -b 若需覆盖文件，则覆盖前先行备份。 -f force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 -i 若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u 若目标文件已经存在，且 source 比较新，才会更新(update) -t &amp;ndash;target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。 命令实例# 例一：文件改名&#xA;$ mv test.txt test1.txt 例二：移动文件&#xA;#将文件test.txt 移动到/usr/doc目录下 $ mv test.txt /usr/doc 例三：将文件log1.txt,log2.txt,log3.txt移动到目录/usr/doc中&#xA;$ mv log1.txt log2.txt log3.txt /usr/doc $ mv -t /usr/doc log1.txt log2.txt log3.txt 例四：将文件file1改名为file2，如果file2已经存在，则询问是否覆盖&#xA;$ mv -i log1.txt log2.txt 例五：将文件file1改名为file2，即使file2存在，也是直接覆盖掉</description>
    </item>
    <item>
      <title>每天一个linux命令（6）: rmdir</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-6-rmdir/</link>
      <pubDate>Tue, 06 Dec 2016 15:24:32 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-6-rmdir/</guid>
      <description>　今天学习一下linux中命令： rmdir命令。rmdir是常用的命令，该命令的功能是删除空目录，一个目录被删除之前必须是空的。（注意，rm - r dir命令可代替rmdir，但是有很大危险性。）删除某目录时也必须具有对父目录的写权限。&#xA;命令格式# $ rmdir [选项]... 目录... 命令功能# 该命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对父目录的写权限。&#xA;命令参数# 参数 描述 - p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息 -v, &amp;ndash;verbose 显示指令执行过程 命令实例# 例一：rmdir 不能删除非空目录&#xA;$ rmdir doc rmdir: doc: 目录非空 例二：rmdir -p 当子目录被删除后使它也成为空目录的话，则顺便一并删除&#xA;$ rmdir -p log/product </description>
    </item>
    <item>
      <title>每天一个linux命令（5）: rm</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-5-rm/</link>
      <pubDate>Mon, 05 Dec 2016 13:40:38 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-5-rm/</guid>
      <description>　rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。 rm是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。&#xA;命令格式# $ rm [选项] 文件... 命令功能# 参数 描述 -f, &amp;ndash;force 忽略不存在的文件，从不给出提示 -i, &amp;ndash;interactive 进行交互式删除 -r, -R, &amp;ndash;recursive 指示rm将参数中列出的全部目录和子目录均递归地删除 -v, &amp;ndash;verbose 详细显示进行的步骤 &amp;ndash;help 显示此帮助信息并退出 &amp;ndash;version 输出版本信息并退出 命令实例# 例一：删除文件file，系统会先询问是否删除&#xA;$ rm file 例二：强行删除file，系统不再提示&#xA;$ rm -f file **例三：删除任何.log文件；删除前逐一询问确认 **&#xA;$ rm -i *.log 例四：对test文件夹进行递归删除&#xA;$ rm -r test 例五：递归删除，系统不用一一确认&#xA;$ rm -rf test 例六：删除以 -f 开头的文件&#xA;$ rm -- -f 例七：自定义回收站功能&#xA;#下面的操作过程模拟了回收站的效果，即删除文件的时候只是把文件放到一个临时目录中，这样在需要的时候还可以恢复过来。 $ myrm(){ D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv &amp;#34;$@&amp;#34; $D &amp;amp;&amp;amp; echo &amp;#34;moved to $D ok&amp;#34;; } </description>
    </item>
    <item>
      <title>每天一个linux命令（4）: mkdir</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-4-mkdir/</link>
      <pubDate>Sun, 04 Dec 2016 09:27:32 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-4-mkdir/</guid>
      <description>　linux mkdir 命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。&#xA;命令格式# $ mkdir [选项] 目录... 命令功能# 通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。&#xA;命令参数# 参数 说明 -m, &amp;ndash;mode=模式 设定权限&amp;lt;模式&amp;gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask -p, &amp;ndash;parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录 -v, &amp;ndash;verbose 每次创建新目录都显示信息 &amp;ndash;help 显示此帮助信息并退出 &amp;ndash;version 输出版本信息并退出 命令是实例# 例一：创建一个空目录&#xA;$ mkdir test 例二：递归创建多个目录&#xA;#在当前目录创建一个嵌套文件夹test1/test11 $ mkdir -p test1/test11 例三：创建权限为777的目录&#xA;$ mkdir -m 777 test 例四：创建新目录都显示信息&#xA;$ mkdir -v test 例五：一个命令创建项目的目录结构&#xA;$ mkdir -vp scf/{lib/,bin/,doc/{info,product},logs/{info,product},service/deploy/{info,product}} mkdir: 已创建目录 “scf” mkdir: 已创建目录 “scf/lib” mkdir: 已创建目录 “scf/bin” mkdir: 已创建目录 “scf/doc” mkdir: 已创建目录 “scf/doc/info” mkdir: 已创建目录 “scf/doc/product” mkdir: 已创建目录 “scf/logs” mkdir: 已创建目录 “scf/logs/info” mkdir: 已创建目录 “scf/logs/product” mkdir: 已创建目录 “scf/service” mkdir: 已创建目录 “scf/service/deploy” mkdir: 已创建目录 “scf/service/deploy/info” mkdir: 已创建目录 “scf/service/deploy/product” [root@localhost test]## tree scf/ scf/ |-- bin |-- doc | |-- info | `-- product |-- lib |-- logs | |-- info | `-- product `-- service `-- deploy |-- info `-- product 12 directories, 0 files </description>
    </item>
    <item>
      <title>每天一个linux命令（3）: pwd</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-3-pwd/</link>
      <pubDate>Sat, 03 Dec 2016 09:15:52 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-3-pwd/</guid>
      <description>　Linux中用 pwd 命令来查看”当前工作目录“的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。 在不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置。&#xA;命令格式# $ pwd [选项] 命令功能# 查看”当前工作目录“的完整路径&#xA;常用参数# 一般情况下不带任何参数 如果目录是链接时： 格式：pwd -P 显示出实际路径，而非使用链接（link） 的路径&#xA;实用实例# 例一：用 pwd 命令查看当前工作目录的完整路径&#xA;$ pwd /home/faker 例二：目录连接链接时，pwd -P 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径&#xA;#目录为链接时，输出链接路径 $ pwd -L #目录为链接时，输出物理路径 $ pwd -P /home/faker 例三：当前目录被删除了，而pwd命令仍然显示那个目录&#xA;$ cd /opt/soft $ rm ../soft -rf $ pwd /opt/soft $ /bin/pwd /bin/pwd: couldnt find directory entry in “..” with matching i-node /home/faker </description>
    </item>
    <item>
      <title>每天一个linux命令（2）: cd</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-2-cd/</link>
      <pubDate>Fri, 02 Dec 2016 11:04:55 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-2-cd/</guid>
      <description>&lt;p&gt;　　Linux cd 命令可以说是Linux中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。所以，学习Linux 常用命令，首先就要学好 cd 命令的使用方法技巧。&lt;/p&gt;</description>
    </item>
    <item>
      <title>每天一个linux命令（1）: ls</title>
      <link>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-1-ls/</link>
      <pubDate>Thu, 01 Dec 2016 09:38:59 +0000</pubDate>
      <guid>https://richfan.site/%E7%A8%8B%E6%8A%80/linux/linux-command/linux-command-1-ls/</guid>
      <description>ls命令是linux下最常用的命令。ls命令就是list的缩写，缺省下ls用来打印出当前目录的清单，如果ls指定其他目录，那么就会显示指定目录里的文件及文件夹清单。 通过ls命令不仅可以查看linux文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)、查看目录信息等等。ls命令在日常的linux操作中用的很多!&#xA;命令格式# $ ls [选项] [目录名] 命令功能# 列出目标目录中所有的子目录和文件。&#xA;常用参数# 参数 说明 -a,&amp;ndash;all 列出目录下的所有文件，包括以 . 开头的隐含文件 -A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。 -c 配合 -lt 根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -lt：显示 ctime 但根据名称排序否则：根据 ctime 排序 -C 每栏由上至下列出项目 -color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是&amp;rsquo;never&amp;rsquo;、&amp;lsquo;always&amp;rsquo;或&amp;rsquo;auto&amp;rsquo;其中之一 -d,&amp;ndash;directory 将目录象文件一样显示，而不是显示其下的文件。 -D,&amp;ndash;dired 产生适合 Emacs 的 dired 模式使用的结果 -f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效 -g 类似 -l,但不列出所有者 -G, &amp;ndash;no-group 不列出任何有关组的信息 -h,&amp;ndash;human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G) &amp;ndash;si 类似 -h,但文件大小取 1000 的次方而不是 1024 -H, &amp;ndash;dereference-command-line 使用命令列中的符号链接指示的真正目的地 &amp;ndash;indicator-style=&amp;lt;方式&amp;gt; 指定在每个项目名称后加上指示符号&amp;lt;方式&amp;gt;：none (默认)，classify (-F)，file-type (-p) -i, &amp;ndash;inode 印出每个文件的 inode 号 -I,&amp;ndash;ignore=样式 不印出任何符合 shell 万用字符&amp;lt;样式&amp;gt;的项目 -k 即 –block-size=1K,以 k 字节的形式表示文件的大小 -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。 -L, &amp;ndash;dereference -m 所有项目以逗号分隔，并填满整行行宽 -o 类似 -l,显示文件的除组信息外的详细信息。 -r, &amp;ndash;reverse 依相反次序排列 -R, &amp;ndash;recursive 同时列出所有子目录层 -s,&amp;ndash;size 以块大小为单位列出所有文件的大小 -S 根据文件大小排序 &amp;ndash;sort=WORD 可选用的 WORD 和它们代表的相应选项： extension -X status -cnone -U time -tsize -S atime -utime -t access -uversion -v use -u -t 以文件修改时间排序 -u 配合 -lt:显示访问时间而且依访问时间排序配合 -l:显示访问时间但根据名称排序否则：根据访问时间排序 -U 不进行排序;依文件系统原有的次序列出项目 -v 根据版本进行排序 -w, &amp;ndash;width=COLS 自行指定屏幕宽度而不使用目前的数值 -x 逐行列出项目而不是逐栏列出 -X 根据扩展名排序 -1 每行只列出一个文件 &amp;ndash;help 显示此帮助信息并离开 &amp;ndash;version 显示版本信息并离开 常用范例# 例一：列出/home/faker/ 文件夹下的所有文件和目录的详细资料</description>
    </item>
  </channel>
</rss>
